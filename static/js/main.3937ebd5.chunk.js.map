{"version":3,"sources":["../../zaml-parser/lib/index.js","App.tsx","sample/default.ts","serviceWorker.ts","index.tsx","Editor/Pane.tsx","../../zaml-parser/lib/util.js","../../zaml-parser/lib/constants.js","../../zaml-parser/lib/Node.js","../../zaml-parser/lib/TextStream.js","../../zaml-parser/lib/ParseError.js","Editor/Editor.tsx","Editor/logo.svg","TreeView/TreeNode.tsx","TreeView/TreePathItem.tsx","TreeView/TreePath.tsx","TreeView/TreeToolbar.tsx","TreeView/TreePropEditor.tsx","Common/TabView.tsx","TreeView/TreeView.tsx","SourceEditor/codemirror-mode.ts","SourceEditor/SourceEditor.tsx","VisualEditor/VisualNode.tsx","VisualEditor/VisualEditor.tsx","../../zaml-parser/lib/Tokenizer.js","../../zaml-parser/lib/TextLine.js"],"names":["_interopRequireWildcard","__webpack_require__","_interopRequireDefault","Object","defineProperty","exports","value","tokenize","parse","enumerable","get","_Tokenizer","default","_TextStream","TextLine","_Node","NodeType","_ParseError","text","options","process","console","warn","_default","ParseError","Tokenizer","TextStream","Node","App","react_default","a","createElement","className","Editor","defaultSource","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","Pane","props","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","_this$props","title","children","react__WEBPACK_IMPORTED_MODULE_5___default","classNames","React","defaultProps","formatValue","parseValue","P_DATE_FORMAT","test","Date","spacer","stringify","node","indent","arguments","length","undefined","pos","defaultOptions","space","_constants","DEFAULT_INDENT_SPACES","simple","toSource","opt","_","isUndefined","isNumber","defaults","simpleTag","isSimpleTag","labels","keys","attributes","unwrapped","isBlockTag","start","textStart","isText","content","isEntity","child","first","Error","T_ENTITY_START","T_ENTITY_END","isTag","isBlock","T_TAG_START","name","listCount","forEach","key","i","T_SPACE","isBoolean","concat","each","label","T_TAG_END","T_LINE_BREAK","isParagraph","isEmpty","metadata","isRoot","T_METADATA_MARKER","isWrappingTag","subText","next","nextSibling","trimEnd","isLastChild","T_TAG_CLOSING","end","textEnd","replace","chalk","isAnsiSupported","isChrome","isNode","_slicedToArray2","isDate","toISOString","isString","P_STRING_LITERAL_UNQUOTED_TESTER","JSON","isNaN","Infinity","repeat","release","userAgent","colorful","mapValues","reset","bold","dim","italic","underline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","white","blackBright","grey","gray","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","whiteBright","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgBlackBright","bgGrey","bgGray","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhiteBright","_ref","_ref2","PROCESSING_TIMEOUT","P_MARKER","END_MARKERS","START_MARKERS","P_FULL_WIDTH_CHARACTER","P_BOOLEAN_FALSE","P_BOOLEAN_TRUE","P_STRING_LITERAL_UNQUOTED","P_STRING_LITERAL_QUOTED","P_NUMBER_LITERAL","P_NUMBER_START","P_DATE_LITERAL","T_STRING_START","P_TAG_NAME","P_ATTRIBUTE_LIST","P_ATTRIBUTE_NAME","P_ATTRIBUTE_ASSIGN","P_LABEL_NAME","P_LABEL_START","P_LIST_SEPARATOR","P_WHITE_SPACES_EXT","P_WHITE_SPACE","P_PARAGRAPH_BREAK","P_SPACE_WRAPPED_LINE_BREAK","P_LINE_BREAK","P_ASSIGN_YAML","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","T_METADATA_FAVORED_ASSIGN","T_PARAGRAPH_BREAK","T_LINE_BREAKS","T_ASSIGN_YAML","T_ASSIGN_XML","P_MULTIPLE_LINE_COMMENT","T_SINGLE_LINE_COMMENT","T_TAB","createPattern","combinePatterns","list","map","p","isRegExp","source","escapeRegExp","join","flags","RegExp","testNode","find","_find","findOne","_findOne","parseJson","toJsonMap","parseJsonMap","WrappingTags","BlockTags","BlockNodeTypes","NodeTypes","_regenerator","_asyncToGenerator2","_toConsumableArray2","_objectSpread2","_classCallCheck2","_createClass2","_defineProperty2","_util","_2","nanoid","values","ROOT","PARAGRAPH","defaultFinderCallback","pattern","isFunction","is","TypeError","result","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","json","create","type","id","childData","appendChild","normalize","toJSON","isPlainObject","_props$source","_props$start","_props$end","states","_props$attributes","_props$metadata","_props$labels","parent","_props$content","_props$text","includes","_source","appendText","ENTITY","TAG","FRAGMENT","TEXT","COMMENT","tagName","isArray","n1","n2","ancestor","path1","path","path2","shift","paths","range","startNode","startOffset","endNode","endOffset","RangeError","_parent","fragment","createFragment","block","createTag","substring","insertBefore","removeChild","findCommonAncestor","_paths","baseStartNode","baseEndNode","_startIndex","indexOf","_sort","sort","_sort2","startIndex","endIndex","_fragment","extractNodes","isStartSided","isSidedDescendantOf","isEndSided","foundBlock","n","_block2","createBlock","insertAt","inserting","startText","_block","endText","expression","toUpperCase","substr","validNode","side","firstChild","lastChild","prependChild","pull","index","pullAt","_this$children","_this","splice","apply","ref","validParent","refIndex","newChild","oldChild","contains","validChild","replaceChild","set","data","merge","has","unset","isObject","toString","_this2","selector","one","intersection","findBy","hasChild","findTextByRange","callback","separator","log","isInlineBlock","isOnlyChild","lastPos","lastIndex","exec","textNodes","filter","_startNode","tn","_endNode","createBlockByRange","_this3","stack","childLength","merged","textNode","createText","slice","mergeText","items","entityNodes","sortBy","item","entityNode","createChild","replaceWith","entities","_this4","cache","Map","createEntities","_extractEntities","mark","_callee","extractor","nodeList","textList","wrap","_context","prev","extract","sent","stop","_x","previousSibling","_options$position","position","_options$textPosition","textPosition","_options$internalId","internalId","omitBy","openDescriptorStart","openDescriptorEnd","descriptor","childIndex","rootNode","getRootNode","last","siblings","unshift","_TextLine","LINE_BREAKS","tabSize","lines","markers","cursorStack","init","matched","offset","ln","_text","_text2","lineOffsetIndexes","lineIndex","sortedLastIndex","line","col","trimSpaces","_this$getPosition","getPosition","trimStart","_this$getPosition2","charAt","ok","ch","lastMatch","chr","string","eat","eof","peek","caseInsensitive","left","_options$toEOL","toEOL","_options$toEOF","toEOF","_options$consume","consume","_options$skipMatched","skipMatched","_this$search","search","_line","readTo","nextLine","read","_options$consume2","_this$search2","marker","extend","_data","pop","trim","numWidth","padStart","_this$getPosition5","max","min","l","isCurrent","debugLine","debugCursor","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_wrapNativeSuper2","_Error","message","from","to","zaml","global","info","sourceBlock","querySelector","sourceText","findOneBy","createEntitiesFromText","error","state","root","sourcePaneHeight","onResize","throttle","bind","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__","preventSourceChange","addEventListener","passive","removeEventListener","nextProps","nextState","selectedNode","height","innerHeight","setState","selected","_this$state","hoveredNode","react__WEBPACK_IMPORTED_MODULE_7___default","href","_svgr_webpack_prettier_svgo_logo_svg__WEBPACK_IMPORTED_MODULE_16__","react_split_pane__WEBPACK_IMPORTED_MODULE_9__","split","defaultSize","minSize","_Pane__WEBPACK_IMPORTED_MODULE_10__","_SourceEditor_SourceEditor__WEBPACK_IMPORTED_MODULE_11__","onChange","handleSourceChange","_VisualEditor_VisualEditor__WEBPACK_IMPORTED_MODULE_12__","onSelect","r","handleNodeChange","_TreeView_TreeView__WEBPACK_IMPORTED_MODULE_17__","onHover","d","__webpack_exports__","SvgComponent","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","_extends","assign","target","prototype","hasOwnProperty","fill","_ref3","_ref4","cx","cy","_ref5","_ref6","x","y","width","rx","ry","_ref7","_ref8","points","data-name","viewBox","NodePart","nil","TreeNode","classCallCheck","possibleConstructorReturn","getPrototypeOf","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","Whole","Header","onClick","event","stopPropagation","commonProps","_onMouseEnter","_onMouseOut","_x2","react","onlyText","node-selected","truncate","Footer","closingDescriptor","TreePathItem","TreePath","buildNodeList","TreePathItem_TreePathItem","TreeToolbar","Tab","TabView","tabs","selectedTab","onTabChange","tab","defaultTab","defaultEditingIndex","TreePropEditor","editingIndex","inlineError","editingElement","renderEmptyTip","Labels","renderLabelEditor","Attributes","renderAttributeEditor","Metadata","focus","select","focusEditingElement","originalLabel","e","addLabel","removeLabel","cancelLabelEditing","toConsumableArray","defaultValue","onBlur","handleLabelUpdate","currentTarget","onKeyDown","handleLabelEdit","renderValue","_this5","TabView_TabView","renderTabContent","TreeView","without","nodeIds","union","index_esm","TreeToolbar_TreeToolbar","TreeNode_TreeNode","handleExpansionChange","TreePath_TreePath","TreePropEditor_TreePropEditor","CodeMirror","defineSimpleMode","regex","token","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","editor","setSize","setValue","react_codemirror2","onBeforeChange","_onChange","_x3","editorDidMount","VisualNode","element","node-name","node-id","url","toLowerCase","VisualEditor","ContextMenuTarget","handleContextMenu","currentNode","selection","getSelection","rangeCount","getRangeAt","domNode","startContainer","textContent","preventDefault","punctuationPattern","startPos","endPos","setStart","setEnd","commonNode","getNodeByElement","commonAncestorContainer","endContainer","removeAllRanges","_this$props2","flatten","_this$props3","anchorNode","focusNode","alert","_this$props4","removeEntity","_this$props5","splitText","nodeType","TEXT_NODE","classList","parentElement","getAttribute","getNodeById","_this$props6","onDoubleClick","handleDoubleClick","VisualNode_VisualNode","commonEntityNames","wrapperNode","menu","menuItem","disabled","menuDivider","handleCreateBlock","handleRemoveBlock","handleSplitSentences","handleCreateEntity","prompt","handleRemoveEntity","handleInspect","State","stateNames","getStateName","countLineBreaks","stream","verbose","NODE_ENV","PUBLIC_URL","DEBUG","parsed","_console","metadataMarkerRequired","needMetadataMarker","timeStart","now","METADATA","lastState","inline","embedded","isClosing","nodeStack","getNodeString","debugStack","lastNode","pushNode","debug","popNode","createError","levelUpBlock","blockNode","FINISH","debugState","eatWhile","metadataMatched","NORMAL","ATTRIBUTE_LIST","sol","eol","START","SINGLE_COMMENT","MULTIPLE_COMMENT","TAG_START","TAG_END","ENTITY_START","END","TAG_NAME","LABEL_START","_child","metaKey","pushCursor","popCursor","_child2","simpleBlock","spacePattern","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","_child3","clearLabels","clearMetadata","ATTRIBUTE_ASSIGN","ATTRIBUTE_NAME","_key","_ch2","ATTRIBUTE_FINISH","ATTRIBUTE_VALUE","_ch3","_value","parseFloat","isNull","_key2","_value2","setMetadata","setAttribute","parseMetadata","tagNode","setAttributes","ENTITY_END","skipOver","_child4","ENTITY_BODY"],"mappings":"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","file":"static/js/main.3937ebd5.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.parse = parse;\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _Tokenizer.default;\n  }\n});\nObject.defineProperty(exports, \"TextStream\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.default;\n  }\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.TextLine;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.default;\n  }\n});\nObject.defineProperty(exports, \"NodeType\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.NodeType;\n  }\n});\nObject.defineProperty(exports, \"ParseError\", {\n  enumerable: true,\n  get: function get() {\n    return _ParseError.default;\n  }\n});\nexports.default = void 0;\n\nvar _Tokenizer = _interopRequireDefault(require(\"./Tokenizer\"));\n\nvar _TextStream = _interopRequireWildcard(require(\"./TextStream\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/**\n * @module @zaml/parser\n * @typicalname parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\n\n\nfunction parse(text, options) {\n  var tokenizer = new _Tokenizer.default(text, options);\n  return tokenizer.process();\n}\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\n\n\nfunction tokenize(text, options) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nvar _default = {\n  ParseError: _ParseError.default,\n  Tokenizer: _Tokenizer.default,\n  TextStream: _TextStream.default,\n  TextLine: _TextStream.TextLine,\n  Node: _Node.default,\n  NodeType: _Node.NodeType,\n  tokenize: tokenize,\n  parse: parse\n};\nexports.default = _default;","import React, { Component } from 'react';\nimport './App.scss';\nimport Editor from './Editor/Editor';\nimport contract from './sample/default';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Editor defaultSource={contract} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export default `---\nfoo: bar\n---\n#Question #Q #Q1 \n  What is your name?\n\n#Answer #A \n  My name is [Jack]{PER}\n`\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatValue = formatValue;\nexports.parseValue = parseValue;\nexports.spacer = spacer;\nexports.stringify = stringify;\nexports.chalk = exports.isAnsiSupported = exports.isChrome = exports.isNode = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Node = _interopRequireDefault(require(\"./Node\"));\n\nvar P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n/**\n * Stringify attribute value\n * @param value \n */\n\nfunction formatValue(value) {\n  if (_.isDate(value)) {\n    return value.toISOString().replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString) {\n    return _constants.P_STRING_LITERAL_UNQUOTED_TESTER.test(value) ? value : JSON.stringify(value);\n  } else if (_.isBoolean(value)) {\n    return JSON.stringify(value);\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n/**\n * Parse attribute value\n * @param value \n */\n\n\nfunction parseValue(value) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\n\n\nfunction spacer(space, indent) {\n  if (indent <= 0) return '';\n  return _.repeat(_constants.T_SPACE, space * indent);\n}\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\n\n\nfunction stringify(node, options) {\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var defaultOptions = {\n    space: _constants.DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false\n  };\n  var opt;\n\n  if (_.isUndefined(options)) {\n    opt = defaultOptions;\n  } else if (_.isNumber(options)) {\n    opt = {\n      space: options\n    };\n  } else {\n    opt = _.defaults(options, defaultOptions);\n  }\n\n  var text = '';\n  var simpleTag = opt.simple && node.isSimpleTag && (node.labels.length > 0 || Object.keys(node.attributes).length > 0);\n  var unwrapped = simpleTag && node.isBlockTag && node.children.length === 1;\n\n  if (opt.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n\n  if (node.isText) {\n    text += node.content;\n  } else {\n    if (node.isEntity) {\n      var child = _.first(node.children);\n\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n\n      if (opt.toSource) {\n        text += _constants.T_ENTITY_START;\n      }\n\n      text += stringify(child, opt, indent, pos + text.length);\n\n      if (opt.toSource) {\n        text += _constants.T_ENTITY_END;\n      }\n    }\n\n    if (opt.toSource && (node.isTag || node.isEntity)) {\n      if (node.isBlock) {\n        text += spacer(opt.space, indent);\n      }\n\n      if (!unwrapped) {\n        text += _constants.T_TAG_START;\n      }\n\n      if (!simpleTag) {\n        text += node.name;\n      }\n\n      var listCount = 0;\n\n      _.keys(node.attributes).forEach(function (key, i) {\n        var value = node.attributes[key];\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        if (_.isBoolean(value) && value) {\n          text += key;\n        } else if (value instanceof _Node.default) {\n          text += stringify(node, opt, 0, pos + text.length);\n        } else {\n          text += \"\".concat(key, \"=\").concat(formatValue(value));\n        }\n      });\n\n      _.each(node.labels, function (label, i) {\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        text += \"#\".concat(label);\n      });\n\n      if (!unwrapped) {\n        text += simpleTag ? _constants.T_SPACE : _constants.T_TAG_END;\n      }\n\n      if (node.isBlock) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (opt.toSource && node.isParagraph) {\n      text += spacer(opt.space, indent);\n    }\n\n    if (opt.toSource && !_.isEmpty(node.metadata)) {\n      if (node.isRoot) {\n        text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n      }\n\n      _.each(node.metadata, function (value, key) {\n        text += spacer(opt.space, indent + 1);\n        text += \"\".concat(key, \": \");\n\n        if (value instanceof _Node.default) {\n          text += stringify(value, opt, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n\n        text += _constants.T_LINE_BREAK;\n      });\n\n      text += spacer(opt.space, indent + 1);\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n    }\n\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(function (child) {\n        var subText = stringify(child, opt, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n\n    var next = node.nextSibling;\n\n    if (node.isBlock) {\n      if (opt.toSource) {\n        text = _.trimEnd(text, _constants.T_LINE_BREAK);\n      }\n\n      text += _constants.T_LINE_BREAK;\n\n      if (node.isParagraph && !node.isLastChild) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (opt.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(opt.space, indent);\n      }\n\n      if (simpleTag) {\n        if (!unwrapped) {\n          text += _constants.T_TAG_END;\n        }\n      } else {\n        text += _constants.T_TAG_START + _constants.T_TAG_CLOSING + node.name + _constants.T_TAG_END;\n      }\n\n      if (node.isBlockTag) {\n        text += _constants.T_LINE_BREAK;\n\n        if (next && next.isBlock) {\n          text += _constants.T_LINE_BREAK;\n        }\n      }\n    }\n  }\n\n  if (opt.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}\n\nvar isNode = typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node';\nexports.isNode = isNode;\nvar isChrome = !isNode && /Chrome/.test(window.navigator.userAgent);\nexports.isChrome = isChrome;\nvar isAnsiSupported = isNode || isChrome; // lite version of https://github.com/chalk/chalk\n\nexports.isAnsiSupported = isAnsiSupported;\nvar colorful = isAnsiSupported ? function (start, end) {\n  return function (text) {\n    return \"\\x1B[\".concat(start, \"m\").concat(text, \"\\x1B[\").concat(end, \"m\");\n  };\n} : function (start, end) {\n  return function (text) {\n    return text;\n  };\n};\nvar chalkStyles = {\n  // modifier\n  reset: [0, 0],\n  // 21 isn't widely supported and 22 does the same thing\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  // color\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  // Bright color\n  blackBright: [90, 39],\n  grey: [90, 39],\n  gray: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  // bgColor\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  // Bright color\n  bgBlackBright: [100, 49],\n  bgGrey: [90, 39],\n  bgGray: [90, 39],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n};\n\nvar chalk = _.mapValues(chalkStyles, function (_ref) {\n  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n      start = _ref2[0],\n      end = _ref2[1];\n\n  return colorful(start, end);\n});\n\nexports.chalk = chalk;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROCESSING_TIMEOUT = exports.P_MARKER = exports.END_MARKERS = exports.START_MARKERS = exports.P_FULL_WIDTH_CHARACTER = exports.P_BOOLEAN_FALSE = exports.P_BOOLEAN_TRUE = exports.P_STRING_LITERAL_UNQUOTED_TESTER = exports.P_STRING_LITERAL_UNQUOTED = exports.P_STRING_LITERAL_QUOTED = exports.P_NUMBER_LITERAL = exports.P_NUMBER_START = exports.P_DATE_LITERAL = exports.T_STRING_START = exports.P_TAG_NAME = exports.P_ATTRIBUTE_LIST = exports.P_ATTRIBUTE_NAME = exports.P_ATTRIBUTE_ASSIGN = exports.P_LABEL_NAME = exports.P_LABEL_START = exports.P_LIST_SEPARATOR = exports.P_WHITE_SPACES_EXT = exports.P_WHITE_SPACE = exports.P_PARAGRAPH_BREAK = exports.P_SPACE_WRAPPED_LINE_BREAK = exports.P_LINE_BREAK = exports.P_ASSIGN_YAML = exports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = exports.T_METADATA_FAVORED_ASSIGN = exports.T_PARAGRAPH_BREAK = exports.T_LINE_BREAKS = exports.T_LINE_BREAK = exports.T_ASSIGN_YAML = exports.T_ASSIGN_XML = exports.T_TAG_END = exports.T_TAG_CLOSING = exports.T_TAG_START = exports.T_ENTITY_END = exports.T_ENTITY_START = exports.P_MULTIPLE_LINE_COMMENT = exports.T_SINGLE_LINE_COMMENT = exports.T_METADATA_MARKER = exports.T_TAB = exports.T_SPACE = exports.DEFAULT_INDENT_SPACES = exports.createPattern = exports.combinePatterns = void 0;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar combinePatterns = function combinePatterns(list) {\n  return list.map(function (p) {\n    return _.isRegExp(p) ? p.source : _.escapeRegExp(p);\n  }).join('|');\n};\n\nexports.combinePatterns = combinePatterns;\n\nvar createPattern = function createPattern(source) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'g';\n  return new RegExp(source, flags);\n};\n\nexports.createPattern = createPattern;\nvar DEFAULT_INDENT_SPACES = 2;\nexports.DEFAULT_INDENT_SPACES = DEFAULT_INDENT_SPACES;\nvar T_SPACE = ' ';\nexports.T_SPACE = T_SPACE;\nvar T_TAB = '\\t';\nexports.T_TAB = T_TAB;\nvar T_METADATA_MARKER = \"---\";\nexports.T_METADATA_MARKER = T_METADATA_MARKER;\nvar T_SINGLE_LINE_COMMENT = '~';\nexports.T_SINGLE_LINE_COMMENT = T_SINGLE_LINE_COMMENT;\nvar P_MULTIPLE_LINE_COMMENT = '~{3,}';\nexports.P_MULTIPLE_LINE_COMMENT = P_MULTIPLE_LINE_COMMENT;\nvar T_ENTITY_START = '[';\nexports.T_ENTITY_START = T_ENTITY_START;\nvar T_ENTITY_END = ']';\nexports.T_ENTITY_END = T_ENTITY_END;\nvar T_TAG_START = '{';\nexports.T_TAG_START = T_TAG_START;\nvar T_TAG_CLOSING = '/';\nexports.T_TAG_CLOSING = T_TAG_CLOSING;\nvar T_TAG_END = '}';\nexports.T_TAG_END = T_TAG_END;\nvar T_ASSIGN_XML = '=';\nexports.T_ASSIGN_XML = T_ASSIGN_XML;\nvar T_ASSIGN_YAML = ':：';\nexports.T_ASSIGN_YAML = T_ASSIGN_YAML;\nvar T_LINE_BREAK = '\\n';\nexports.T_LINE_BREAK = T_LINE_BREAK;\nvar T_LINE_BREAKS = '\\r\\n';\nexports.T_LINE_BREAKS = T_LINE_BREAKS;\nvar T_PARAGRAPH_BREAK = '\\n\\n';\nexports.T_PARAGRAPH_BREAK = T_PARAGRAPH_BREAK;\nvar T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexports.T_METADATA_FAVORED_ASSIGN = T_METADATA_FAVORED_ASSIGN;\nvar T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\nexports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_TAG_ATTRIBUTE_FAVORED_ASSIGN;\nvar P_ASSIGN_YAML = /[:：]/;\nexports.P_ASSIGN_YAML = P_ASSIGN_YAML;\nvar P_LINE_BREAK = /\\r?\\n/g;\nexports.P_LINE_BREAK = P_LINE_BREAK;\nvar P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexports.P_SPACE_WRAPPED_LINE_BREAK = P_SPACE_WRAPPED_LINE_BREAK;\nvar P_PARAGRAPH_BREAK = createPattern(\"\".concat(P_LINE_BREAK.source, \"\\\\s*\").concat(P_LINE_BREAK.source));\nexports.P_PARAGRAPH_BREAK = P_PARAGRAPH_BREAK;\nvar P_WHITE_SPACE = /[ \\t]/g;\nexports.P_WHITE_SPACE = P_WHITE_SPACE;\nvar P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexports.P_WHITE_SPACES_EXT = P_WHITE_SPACES_EXT;\nvar P_LIST_SEPARATOR = /[,，]/g;\nexports.P_LIST_SEPARATOR = P_LIST_SEPARATOR;\nvar P_LABEL_START = /[#＃]/g;\nexports.P_LABEL_START = P_LABEL_START;\nvar P_LABEL_NAME = /(?:[A-Za-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\.0-9A-Z_a-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])*/g;\nexports.P_LABEL_NAME = P_LABEL_NAME;\nvar P_ATTRIBUTE_ASSIGN = createPattern(\"[\".concat([T_ASSIGN_XML, T_ASSIGN_YAML].join(''), \"]\"), '');\nexports.P_ATTRIBUTE_ASSIGN = P_ATTRIBUTE_ASSIGN;\nvar P_ATTRIBUTE_NAME = createPattern(\"(?:\".concat(P_LABEL_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"));\nexports.P_ATTRIBUTE_NAME = P_ATTRIBUTE_NAME;\nvar P_ATTRIBUTE_LIST = createPattern(\"(\".concat(P_LABEL_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"|\").concat(P_LABEL_START.source).concat(P_LABEL_NAME.source, \")\"));\nexports.P_ATTRIBUTE_LIST = P_ATTRIBUTE_LIST;\nvar P_TAG_NAME = P_ATTRIBUTE_NAME;\nexports.P_TAG_NAME = P_TAG_NAME;\nvar T_STRING_START = '\"';\nexports.T_STRING_START = T_STRING_START;\nvar P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\d(?:T[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?/g;\nexports.P_DATE_LITERAL = P_DATE_LITERAL;\nvar P_NUMBER_START = /[\\d\\.]/;\nexports.P_NUMBER_START = P_NUMBER_START;\nvar P_NUMBER_LITERAL = /(\\d+|\\d*\\.\\d+|\\d+\\.\\d*)(e\\d+)?/g;\nexports.P_NUMBER_LITERAL = P_NUMBER_LITERAL;\nvar P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\\")*\"/g;\nexports.P_STRING_LITERAL_QUOTED = P_STRING_LITERAL_QUOTED;\nvar P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexports.P_STRING_LITERAL_UNQUOTED = P_STRING_LITERAL_UNQUOTED;\nvar P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(\"^\".concat(P_STRING_LITERAL_UNQUOTED.source, \"$\"));\nexports.P_STRING_LITERAL_UNQUOTED_TESTER = P_STRING_LITERAL_UNQUOTED_TESTER;\nvar P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexports.P_BOOLEAN_TRUE = P_BOOLEAN_TRUE;\nvar P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexports.P_BOOLEAN_FALSE = P_BOOLEAN_FALSE;\nvar P_FULL_WIDTH_CHARACTER = /(?:[\\xD7\\u2014\\u2026\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3001\\u3002\\u3005\\u3007\\u300A-\\u300D\\u3010\\u3011\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFF01\\uFF03\\uFF05\\uFF06\\uFF08\\uFF09\\uFF0B-\\uFF0D\\uFF1A\\uFF1B\\uFF1D\\uFF1F\\uFF20\\uFFE5]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])/g;\nexports.P_FULL_WIDTH_CHARACTER = P_FULL_WIDTH_CHARACTER;\nvar START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexports.START_MARKERS = START_MARKERS;\nvar END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexports.END_MARKERS = END_MARKERS;\nvar P_MARKER = createPattern(\"(\".concat(combinePatterns([P_PARAGRAPH_BREAK].concat(START_MARKERS, [T_TAG_END, P_MULTIPLE_LINE_COMMENT, T_SINGLE_LINE_COMMENT])), \")\"));\nexports.P_MARKER = P_MARKER;\nvar PROCESSING_TIMEOUT = Infinity;\nexports.PROCESSING_TIMEOUT = PROCESSING_TIMEOUT;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testNode = testNode;\nexports.find = _find;\nexports.findOne = _findOne;\nexports.parseJson = parseJson;\nexports.toJsonMap = toJsonMap;\nexports.parseJsonMap = parseJsonMap;\nexports.default = exports.WrappingTags = exports.BlockTags = exports.BlockNodeTypes = exports.NodeTypes = exports.NodeType = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _2 = require(\".\");\n\nvar nanoid = require('nanoid');\n\nvar NodeType;\nexports.NodeType = NodeType;\n\n(function (NodeType) {\n  NodeType[\"FRAGMENT\"] = \"fragment\";\n  NodeType[\"ROOT\"] = \"root\";\n  NodeType[\"PARAGRAPH\"] = \"paragraph\";\n  NodeType[\"TAG\"] = \"tag\";\n  NodeType[\"ENTITY\"] = \"entity\";\n  NodeType[\"TEXT\"] = \"text\";\n  NodeType[\"COMMENT\"] = \"comment\";\n})(NodeType || (exports.NodeType = NodeType = {}));\n\nvar NodeTypes = _.values(NodeType);\n\nexports.NodeTypes = NodeTypes;\nvar BlockNodeTypes = [NodeType.ROOT, NodeType.PARAGRAPH];\nexports.BlockNodeTypes = BlockNodeTypes;\nvar BlockTags = ['BLOCK', 'QUOTE', 'SECTION', 'HEADER', 'FOOTER'];\nexports.BlockTags = BlockTags;\nvar WrappingTags = BlockTags.concat(['INLINE', 'SENTENCE', 'NUM', 'HEADING']);\nexports.WrappingTags = WrappingTags;\n\nvar defaultFinderCallback = function defaultFinderCallback(node) {\n  return true;\n};\n\nfunction testNode(pattern, node) {\n  if (_.isFunction(pattern)) {\n    return pattern(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\n\n\nfunction _find(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        _find(childNode, pattern, result);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\n\n\nfunction _findOne(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n\n  if (testNode(pattern, node)) {\n    return node;\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var childNode = _step2.value;\n\n        var result = _findOne(childNode, pattern);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    ;\n  }\n\n  return undefined;\n}\n\nfunction parseJson(json) {\n  var node = Node.create(json.type, json.name, {\n    id: json.id,\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content\n  });\n\n  if (json.children) {\n    _.each(json.children, function (childData) {\n      node.appendChild(parseJson(childData));\n    });\n  }\n\n  node.normalize();\n  return node;\n}\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\n\n\nfunction toJsonMap(map) {\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n\n  return _.mapValues(map, function (value) {\n    if (value instanceof Node) {\n      return value.toJSON();\n    }\n\n    return value;\n  });\n}\n\nfunction parseJsonMap(json) {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n\n  return _.mapValues(json, function (value) {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n\n    return (0, _util.parseValue)(value);\n  });\n}\n/**\n * AST node class\n * @class\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Node, null, [{\n    key: \"create\",\n\n    /**\n     * Create node, shortcut for constructor \n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n    value: function create(type, name, props) {\n      return new Node(type, name, props);\n    }\n    /**\n     * Create paragraph node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createParagraph\",\n    value: function createParagraph(props) {\n      return new Node(NodeType.PARAGRAPH, undefined, props);\n    }\n    /**\n     * Create root node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createRoot\",\n    value: function createRoot(props) {\n      return new Node(NodeType.ROOT, undefined, props);\n    }\n    /**\n     * Create text node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(content, props) {\n      return new Node(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n        content: content\n      }));\n    }\n    /**\n     * Create a common tag\n     * @param tagName Tag name, e.g. `'BLOCK'`, `'INLINE'`, `'SENTENCE'`\n     * @param [props]\n     */\n\n  }, {\n    key: \"createTag\",\n    value: function createTag(tagName, props) {\n      return new Node(NodeType.TAG, tagName, props);\n    }\n    /**\n     * Create block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(props) {\n      return new Node(NodeType.TAG, 'BLOCK', props);\n    }\n    /**\n     * Create inline block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createInlineBlock\",\n    value: function createInlineBlock(props) {\n      return new Node(NodeType.TAG, 'INLINE', props);\n    }\n    /**\n     * Create node instance from ZAML source\n     * @param source \n     */\n\n  }, {\n    key: \"fromSource\",\n    value: function fromSource(source) {\n      return (0, _2.parse)(source);\n    }\n    /**\n     * Create node from json serializable data\n     * @param json \n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return parseJson(json);\n    }\n    /**\n     * Creating fragment node\n     */\n\n  }, {\n    key: \"createFragment\",\n    value: function createFragment() {\n      return Node.create(NodeType.FRAGMENT);\n    }\n    /**\n     * Check if a node is valid\n     * @param node \n     */\n\n  }, {\n    key: \"validNode\",\n    value: function validNode(node) {\n      if (!(node instanceof Node)) {\n        throw new TypeError('invalid node');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validParent\",\n    value: function validParent(node) {\n      if (!_.isArray(node.children)) {\n        throw new Error('node is not a valid parent');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validChild\",\n    value: function validChild(node) {\n      if (!node.parent) {\n        throw new Error('node is not a valid child');\n      }\n    }\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(n1, n2) {\n      var path1 = n1.path;\n      var path2 = n2.path;\n      var ancestor;\n\n      while (path1.length > 0 && path2.length > 0) {\n        if (_.first(path1) !== _.first(path2)) {\n          break;\n        }\n\n        ancestor = path1.shift();\n        path2.shift();\n      }\n\n      if (!ancestor) {\n        return undefined;\n      }\n\n      return {\n        ancestor: ancestor,\n        paths: [path1, path2]\n      };\n    }\n    /**\n     * Find the common ancestor of the range, and creates a wrapping block (or tag) with the nodes\n     * within the range in it.\n     * \n     * If the range is within a block (BLOCK tag or paragraph), a inline tag is created, otherwise\n     * a BLOCK tag is created.\n     * \n     * If a BLOCK tag is used, `startOffset` and `endOffset` will be ignored, to avoid block overlap.\n     * \n     * If either `startNode` or `endNode` is not direct child of common ancestor nor the node is not\n     * sided aligned with the direct child of the ancestor, text offset will be ignored to avoid\n     * split of tags or entity.\n     * \n     * @param range A range object which contains start and end node, alone with their text offset\n     * @param props Custom tag props\n     * @param tagName If inline tag is needed, specify the tag name instead of default `'INLINE'`\n     */\n\n  }, {\n    key: \"createBlockByRange\",\n    value: function createBlockByRange(range) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var startNode = range.startNode,\n          startOffset = range.startOffset,\n          endNode = range.endNode,\n          endOffset = range.endOffset;\n\n      if (!_.isNumber(startOffset) || !_.isNumber(endOffset)) {\n        throw new TypeError('range offset must be number');\n      }\n\n      if (!startNode.isText || !endNode.isText) {\n        throw new TypeError('range node must be text');\n      }\n\n      if (!startNode.content || !endNode.content) {\n        throw new Error('invalid text node');\n      }\n\n      if (startNode === endNode) {\n        if (startOffset < 0 || startOffset > startNode.content.length || endOffset < 0 || endOffset > startNode.content.length) {\n          throw new RangeError('sub text out of range');\n        }\n\n        if (!startNode.parent) {\n          throw new Error('can not create block on isolated text node');\n        }\n\n        var _parent = startNode.parent;\n        var fragment = Node.createFragment();\n        var block = Node.createTag(tagName, (0, _objectSpread2.default)({}, props, {\n          text: startNode.content.substring(startOffset, endOffset)\n        }));\n\n        if (startOffset > 0) {\n          fragment.appendText(startNode.content.substring(0, startOffset));\n        }\n\n        fragment.appendChild(block);\n\n        if (endOffset < startNode.content.length) {\n          fragment.appendText(startNode.content.substring(endOffset));\n        }\n\n        _parent.insertBefore(fragment, startNode);\n\n        _parent.removeChild(startNode);\n\n        return block;\n      } else {\n        var result = Node.findCommonAncestor(startNode, endNode);\n        if (!result || !result.ancestor) return undefined;\n        var ancestor = result.ancestor,\n            _paths = result.paths;\n        var baseStartNode = _paths[0][0];\n        var baseEndNode = _paths[1][0];\n\n        var _startIndex = ancestor.children.indexOf(baseStartNode);\n\n        var _endIndex = ancestor.children.indexOf(baseEndNode);\n\n        var _sort = [_startIndex, _endIndex].sort(),\n            _sort2 = (0, _slicedToArray2.default)(_sort, 2),\n            startIndex = _sort2[0],\n            endIndex = _sort2[1];\n\n        if (_startIndex !== startIndex) {\n          var _ref = [baseEndNode, baseStartNode];\n          baseStartNode = _ref[0];\n          baseEndNode = _ref[1];\n        }\n\n        var _fragment = ancestor.extractNodes(startIndex, endIndex + 1);\n\n        var isStartSided = startNode.isSidedDescendantOf(baseStartNode, 'start') && startOffset === 0;\n        var isEndSided = endNode.isSidedDescendantOf(baseEndNode, 'end') && endOffset === endNode.content.length;\n        var foundBlock = ancestor.findOne(function (n) {\n          return n.isBlock;\n        });\n        var hasBlock = foundBlock && foundBlock !== ancestor;\n\n        if (!hasBlock && (_paths[0].length === 1 || isStartSided || _paths[1].length === 1 || isEndSided)) {\n          var inserting = Node.createFragment();\n          var startText = startNode.content;\n\n          if (startOffset > 0) {\n            baseStartNode.content = startText.substring(startOffset);\n            inserting.appendText(startText.substring(0, startOffset));\n          }\n\n          var _block = Node.createTag(tagName, props);\n\n          _block.appendChild(_fragment);\n\n          inserting.appendChild(_block);\n          var endText = endNode.content;\n\n          if (endOffset < endNode.content.length) {\n            baseEndNode.content = endText.substring(0, endOffset);\n            inserting.appendText(endText.substring(endOffset));\n          }\n\n          ancestor.insertAt(inserting, startIndex);\n          return _block;\n        } else {\n          var _block2 = Node.createBlock(props);\n\n          ancestor.insertAt(_block2, startIndex);\n\n          _block2.appendChild(_fragment);\n\n          return _block2;\n        }\n      }\n    }\n  }]);\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n\n  function Node(type, name) {\n    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Node);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", '');\n    (0, _defineProperty2.default)(this, \"type\", void 0);\n    (0, _defineProperty2.default)(this, \"name\", void 0);\n    (0, _defineProperty2.default)(this, \"start\", -1);\n    (0, _defineProperty2.default)(this, \"end\", -1);\n    (0, _defineProperty2.default)(this, \"textStart\", -1);\n    (0, _defineProperty2.default)(this, \"textEnd\", -1);\n    (0, _defineProperty2.default)(this, \"states\", void 0);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"labels\", void 0);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"content\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", '');\n    (0, _defineProperty2.default)(this, \"children\", void 0);\n    var id = props.id,\n        _props$source = props.source,\n        source = _props$source === void 0 ? '' : _props$source,\n        _props$start = props.start,\n        start = _props$start === void 0 ? -1 : _props$start,\n        _props$end = props.end,\n        end = _props$end === void 0 ? -1 : _props$end,\n        states = props.states,\n        _props$attributes = props.attributes,\n        attributes = _props$attributes === void 0 ? {} : _props$attributes,\n        _props$metadata = props.metadata,\n        metadata = _props$metadata === void 0 ? {} : _props$metadata,\n        _props$labels = props.labels,\n        labels = _props$labels === void 0 ? [] : _props$labels,\n        parent = props.parent,\n        _props$content = props.content,\n        content = _props$content === void 0 ? '' : _props$content,\n        _props$text = props.text,\n        text = _props$text === void 0 ? '' : _props$text;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(\"invalid node type \".concat(type));\n    }\n\n    this.id = id || nanoid();\n    this.states = states || {};\n    this.type = type;\n    this.name = undefined;\n    this.start = start;\n    this.end = end;\n    this.textStart = -1;\n    this.textEnd = -1;\n    this.parent = parent;\n    this._source = undefined;\n    this.content = undefined;\n    this.children = [];\n    this.labels = [];\n    this.attributes = {};\n    this.metadata = {};\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n\n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n  /**\n   * Get a short descriptor to identify node's type and basic information\n   */\n\n\n  (0, _createClass2.default)(Node, [{\n    key: \"getRootNode\",\n\n    /**\n     * Property indicates if the root is root (which has no children)\n     */\n    value: function getRootNode() {\n      var node = this;\n\n      while (node.parent) {\n        node = node.parent;\n      }\n\n      if (node === this) {\n        return undefined;\n      }\n\n      return node;\n    }\n    /**\n     * Check node match the expression\n     * @example\n     * `BLOCK`: tag\n     * `@LOC`: entity\n     * @param expression \n     */\n\n  }, {\n    key: \"is\",\n    value: function is(expression) {\n      if (!_.isString(expression)) {\n        return false;\n      }\n\n      expression = expression.toUpperCase();\n\n      if (/^[A-Z]/.test(expression)) {\n        return this.type === NodeType.TAG && this.name === expression;\n      } else if (/^#/.test(expression)) {\n        return this.type === NodeType.TAG && this.labels.includes(expression.substr(1));\n      } else if (/^@[A-Z]/.test(expression)) {\n        return this.type === NodeType.ENTITY && this.name === expression.substr(1);\n      }\n\n      return false;\n    }\n    /**\n     * whether a node is a descendant of a given node\n     * @param node \n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      Node.validNode(node);\n\n      while (node) {\n        if (node === this) {\n          return true;\n        }\n\n        if (!node.parent) {\n          return false;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Get a list of ancestors\n     */\n\n  }, {\n    key: \"hasChild\",\n\n    /**\n     * Check if this node has any children\n     */\n    value: function hasChild() {\n      return this.children.length > 0;\n    }\n    /**\n     * Check if this node is the only child of its parent\n     */\n\n  }, {\n    key: \"isOnlyDescendantOf\",\n\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n    value: function isOnlyDescendantOf(ancestor) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length !== 1) {\n          return false;\n        }\n\n        node = node.children[0];\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n\n  }, {\n    key: \"isSidedDescendantOf\",\n    value: function isSidedDescendantOf(ancestor, side) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        node = side === 'start' ? node.firstChild : node.lastChild;\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Create a child node\n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n\n  }, {\n    key: \"createChild\",\n    value: function createChild(type, name, props) {\n      var node = new Node(type, name, props);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Insert a node at the beginning of the children\n     * @param node \n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(node) {\n      return this.insertAt(node, 0);\n    }\n    /**\n     * Append a node to children list\n     * @param node \n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.insertAt(node, Infinity);\n    }\n    /**\n     * Append text node child\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = this.content || '';\n        this.content += text;\n        return this;\n      } else {\n        if (this.lastChild && this.lastChild.isText) {\n          this.lastChild.content += text;\n        } else {\n          var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n            content: text\n          }));\n          this.appendChild(child);\n        }\n      }\n    }\n    /**\n     * Add text node child at the beginning\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"prependText\",\n    value: function prependText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = \"\".concat(text).concat(this.content || '');\n        return this;\n      } else {\n        var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n          content: text\n        }));\n        this.prependChild(child);\n      }\n    }\n    /**\n     * Remove one child\n     * @param node\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      _.pull(this.children, child);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Remove one child by index\n     * @param index\n     */\n\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var child = this.children[index];\n\n      _.pullAt(this.children, index);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Insert a node at specified position\n     * @param node \n     * @param index \n     */\n\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(node, index) {\n      var _this = this;\n\n      if (node.type === NodeType.FRAGMENT) {\n        var _this$children;\n\n        (_this$children = this.children).splice.apply(_this$children, [index, 0].concat((0, _toConsumableArray2.default)(node.children)));\n\n        node.children.forEach(function (child) {\n          child.parent = _this;\n        });\n        node.children = [];\n      } else {\n        this.children.splice(index, 0, node);\n\n        if (node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node.parent = this;\n      }\n\n      return node;\n    }\n    /**\n     * Insert a node before another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex);\n      return node;\n    }\n    /**\n     * Insert a node after another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex + 1);\n      return node;\n    }\n    /**\n     * Replace a child with another node, assuming current node is a parent\n     * @param newChild \n     * @param oldChild \n     * @returns The replaced child\n     */\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      Node.validParent(this);\n\n      if (newChild.contains(this)) {\n        throw new TypeError('the new child contains the parent');\n      }\n\n      if (oldChild.parent !== this) {\n        throw new TypeError('the old child is not a child of this node');\n      }\n\n      this.insertBefore(newChild, oldChild);\n      this.removeChild(oldChild);\n      return oldChild;\n    }\n    /**\n     * Replace current child node with another node, assuming current node is child\n     * @param node Node to be replaced with\n     */\n\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(node) {\n      Node.validChild(this);\n\n      if (!this.parent) {\n        throw new Error('can not replace isolated node');\n      }\n\n      this.parent.replaceChild(node, this);\n      return node;\n    }\n    /**\n     * Set single attribute value\n     * @param {string} key Attribute key\n     * @param {any} value Attribute value\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      _.set(this.attributes, key, value);\n    }\n    /**\n     * Set multiple attributes\n     * @param data Key-value pair\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(data) {\n      _.merge(this.attributes, data);\n    }\n    /**\n     * Get attribute value\n     * @param key \n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return _.get(this.attributes, key);\n    }\n    /**\n     * Check if a specified attribute key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return _.has(this.attributes, key);\n    }\n    /**\n     * Remove an attribute\n     * @param {string} key \n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      _.unset(this.attributes, key);\n    }\n    /**\n     * Remove all attributes\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes() {\n      this.attributes = {};\n    }\n    /**\n     * Set single metadata value\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(key, value) {\n      if (_.isObject(key)) {\n        _.merge(this.metadata, key);\n      } else {\n        _.set(this.metadata, key, value);\n      }\n    }\n    /**\n     * Get metadata value\n     * @param key \n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(key) {\n      return _.get(this.metadata, key);\n    }\n    /**\n     * Remove a metadata\n     * @param key \n     */\n\n  }, {\n    key: \"removeMetadata\",\n    value: function removeMetadata(key) {\n      _.unset(this.metadata, key);\n    }\n    /**\n     * Remove all metadata\n     */\n\n  }, {\n    key: \"clearMetadata\",\n    value: function clearMetadata() {\n      this.metadata = {};\n    }\n    /**\n     * Check if a specified metadata key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasMetadata\",\n    value: function hasMetadata(key) {\n      return _.has(this.metadata, key);\n    }\n    /**\n     * Add label to node\n     * @param label \n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(label) {\n      if (!_.isString(label)) {\n        throw new TypeError('label must be string');\n      }\n\n      if (!this.labels.includes(label)) {\n        this.labels.push(label);\n      }\n    }\n    /**\n     * Check if the node has specified label\n     * @param label \n     */\n\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(label) {\n      return this.labels.includes(label);\n    }\n    /**\n     * Remove label\n     * @param label \n     */\n\n  }, {\n    key: \"removeLabel\",\n    value: function removeLabel(label) {\n      _.pull(this.labels, label);\n    }\n    /**\n     * Remove all labels\n     */\n\n  }, {\n    key: \"clearLabels\",\n    value: function clearLabels() {\n      this.labels = [];\n    }\n    /**\n     * Rebuild text and source position, in case modification has been applied to node\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var source = this.toSource();\n\n      if (this.isRoot) {\n        this._source = source;\n      }\n\n      this.toString();\n    }\n    /**\n     * Get node by id\n     * @param id \n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      return _findOne(this, function (node) {\n        return node.id === id;\n      });\n    }\n    /**\n     * Find matched descendants recursively\n     * @param selector Node selector object\n     * @param [one] Find the first matched node or a list of node\n     */\n\n  }, {\n    key: \"findBy\",\n    value: function findBy() {\n      var _this2 = this;\n\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var type = selector.type,\n          name = selector.name,\n          text = selector.text,\n          source = selector.source,\n          label = selector.label;\n      var finder = one ? _findOne : _find;\n      return finder(this, function (node) {\n        var match = true;\n\n        if (type) {\n          match = match && type === node.type;\n        }\n\n        if (name) {\n          match = match && name === node.name;\n        }\n\n        if (text && node.type === NodeType.TEXT && node.content) {\n          if (_.isRegExp(text)) {\n            match = match && !!text.match(node.content);\n          } else if (_.isString(text)) {\n            match = match && node.content.includes(text);\n          } else {\n            throw new TypeError('text filter should be RegExp or string');\n          }\n        }\n\n        if (source && node._source) {\n          if (_.isRegExp(source)) {\n            match = match && !!source.match(node._source);\n          } else if (_.isString(source)) {\n            match = match && node._source.includes(source);\n          } else {\n            throw new TypeError('source filter should be RegExp or string');\n          }\n        }\n\n        if (label) {\n          if (_.isArray(label)) {\n            match = match && _.intersection(_this2.labels, label).length > 0;\n          } else {\n            match = match && _this2.labels.includes(label);\n          }\n        }\n\n        return match;\n      });\n      ;\n    }\n    /**\n     * Find nodes by selector recursively and return the first one\n     * @param selector \n     */\n\n  }, {\n    key: \"findOneBy\",\n    value: function findOneBy() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.findBy(selector, true);\n    }\n    /**\n     * Find matched text node by text source range\n     * @param start \n     * @param end \n     */\n\n  }, {\n    key: \"findTextByRange\",\n    value: function findTextByRange(start, end) {\n      if (this.textStart === undefined || this.textEnd === undefined) {\n        return undefined;\n      }\n\n      if (this.textStart <= start && this.textEnd >= end) {\n        if (this.type === NodeType.TEXT) {\n          return this;\n        } else if (this.hasChild()) {\n          for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            var match = child.findTextByRange(start, end);\n\n            if (match) {\n              return match;\n            }\n          }\n\n          ;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Find matched children recursively by callback\n     * @param callback\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback) {\n      return _find(this, callback);\n    }\n    /**\n     * Find matched children recursively and return the first one\n     * @param callback\n     */\n\n  }, {\n    key: \"findOne\",\n    value: function findOne(callback) {\n      return _findOne(this, callback);\n    }\n    /**\n     * Find all nodes by selector, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return _find(this, selector);\n    }\n    /**\n     * Find nodes by selector and return the first one, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return _findOne(this, selector);\n    }\n    /**\n     * Split node text into tag wrapped sections, e.g. splitting sentences\n     * \n     * @example \n     * node.splitText('!?.');\n     * @param separator RegExp or character list in string, to split\n     * @param tagName Custom tag name, like `'SENTENCE'`\n     */\n\n  }, {\n    key: \"splitText\",\n    value: function splitText(separator) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var pattern = separator instanceof RegExp ? separator : new RegExp(\"[\".concat(_.escapeRegExp(separator), \"]\"), 'g');\n      console.log(pattern);\n      var list = this.find(function (node) {\n        return node.isParagraph || node.isInlineBlock;\n      });\n      list.forEach(function (node) {\n        if (node.firstChild && node.firstChild.isOnlyChild && node.firstChild.isText) {\n          if (node.isParagraph) {\n            var block = Node.createTag(tagName, props);\n            block.appendChild(node.firstChild);\n            node.appendChild(block);\n            return;\n          } else if (node.name === tagName) {\n            return;\n          }\n        }\n\n        var text = node.toString();\n        var pos = 0;\n        var lastPos = 0;\n        pattern.lastIndex = 0;\n\n        while (pattern.exec(text)) {\n          // recreate text offset for each node\n          node.toString();\n          pos = pattern.lastIndex;\n          var textNodes = node.children.filter(function (n) {\n            return n.isText;\n          });\n\n          var _startNode = textNodes.find(function (tn) {\n            return tn.textStart <= lastPos && tn.textEnd > lastPos;\n          });\n\n          var _endNode = textNodes.find(function (tn) {\n            return tn.textStart < pos && tn.textEnd >= pos;\n          });\n\n          if (!_startNode || !_endNode) {\n            break;\n          }\n\n          var range = {\n            startNode: _startNode,\n            startOffset: lastPos - _startNode.textStart,\n            endNode: _endNode,\n            endOffset: pos - _endNode.textStart\n          };\n          Node.createBlockByRange(range, tagName, props);\n          lastPos = pos;\n        }\n      });\n    }\n    /**\n     * Merge neighbor text nodes\n     */\n\n  }, {\n    key: \"mergeText\",\n    value: function mergeText() {\n      var _this3 = this;\n\n      var stack = [];\n      var childLength = this.children.length;\n      this.children.forEach(function (child, i) {\n        if (child.isText) {\n          stack.push(child);\n        }\n\n        if (!child.isText || i === childLength - 1) {\n          if (stack.length > 1) {\n            var merged = stack.map(function (child) {\n              return child.content;\n            }).join('');\n            var textNode = Node.createText(merged);\n\n            _this3.insertBefore(textNode, stack[0]);\n\n            var n;\n\n            while (n = stack.shift()) {\n              _this3.removeChild(n);\n            }\n          }\n\n          stack = [];\n        }\n      });\n    }\n  }, {\n    key: \"extractNodes\",\n    value: function extractNodes(startIndex, endIndex) {\n      var fragment = Node.createFragment();\n\n      if (startIndex < 0 || startIndex >= this.children.length || endIndex < 0 || endIndex > this.children.length) {\n        throw new RangeError('invalid range of children');\n      }\n\n      var nodes = this.children.slice(startIndex, endIndex);\n      nodes.forEach(function (child) {\n        fragment.appendChild(child);\n      });\n      return fragment;\n    }\n    /**\n     * Remove a element and move its children to its parent\n     */\n\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      if (!this.parent) {\n        return;\n      }\n\n      var parent = this.parent;\n      var fragment = this.extractNodes(0, this.children.length);\n      parent.insertBefore(fragment, this);\n      parent.removeChild(this);\n      parent.mergeText();\n      return parent;\n    }\n    /**\n     * Process text node in current node and parse entities\n     */\n\n  }, {\n    key: \"createEntities\",\n    value: function createEntities(items) {\n      var entityNodes = [];\n\n      if (this.type !== NodeType.TEXT) {\n        console.warn('extractEntity() should exec only on text node');\n      }\n\n      if (!this.content || _.isEmpty(items)) {\n        return entityNodes;\n      }\n\n      var text = this.content;\n      items = _.sortBy(items, ['start']);\n      var fragment = Node.createFragment();\n      var lastPos = 0;\n      items.forEach(function (item) {\n        if (item.start >= item.end || item.start < lastPos) {\n          return;\n        }\n\n        if (item.start > lastPos) {\n          fragment.appendText(text.substring(lastPos, item.start));\n        }\n\n        var entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n          attributes: item.data\n        });\n        entityNode.appendText(text.substring(item.start, item.end));\n        entityNodes.push(entityNode);\n        lastPos = item.end;\n      });\n\n      if (lastPos < text.length) {\n        fragment.appendText(text.substr(lastPos));\n      }\n\n      this.replaceWith(fragment);\n      return entityNodes;\n    }\n    /**\n     * Create entity nodes based on text source position\n     * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n     */\n\n  }, {\n    key: \"createEntitiesFromText\",\n    value: function createEntitiesFromText(entities) {\n      var _this4 = this;\n\n      this.toString();\n      var cache = new Map();\n\n      _.each(entities, function (item) {\n        var textNode = _this4.findTextByRange(item.start, item.end);\n\n        if (textNode === undefined) {\n          return;\n        }\n\n        if (cache.has(textNode)) {\n          cache.get(textNode).push(item);\n        } else {\n          cache.set(textNode, [item]);\n        }\n      });\n\n      cache.forEach(function (items, textNode) {\n        textNode.createEntities(items.map(function (item) {\n          return (0, _objectSpread2.default)({}, item, {\n            start: item.start - (textNode.textStart || 0),\n            end: item.end - (textNode.textStart || 0)\n          });\n        }));\n      });\n    }\n    /**\n     * Extract entities from text node\n     */\n\n  }, {\n    key: \"extractEntities\",\n    value: function () {\n      var _extractEntities = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(extractor) {\n        var nodeList, textList, result;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nodeList = this.find(function (node) {\n                  return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n                });\n                textList = nodeList.map(function (node) {\n                  return node.content;\n                });\n\n                if (!_.isFunction(extractor)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                result = textList.map(function (text) {\n                  return extractor(text);\n                });\n                _context.next = 13;\n                break;\n\n              case 6:\n                if (!_.isFunction(extractor.extract)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 9;\n                return extractor.extract(textList);\n\n              case 9:\n                result = _context.sent;\n                _context.next = 13;\n                break;\n\n              case 12:\n                throw new TypeError('invalid extractor');\n\n              case 13:\n                nodeList.forEach(function (node, i) {\n                  var items = result[i];\n\n                  if (!_.isArray(items)) {\n                    throw new Error('invalid extraction result');\n                  }\n\n                  node.createEntities(items);\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function extractEntities(_x) {\n        return _extractEntities.apply(this, arguments);\n      };\n    }()\n    /**\n     * Remove wrapping entity and put text back\n     */\n\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity() {\n      if (this.type !== NodeType.ENTITY || !this.firstChild || this.firstChild.type !== NodeType.TEXT) {\n        throw new Error('invalid entity');\n      }\n\n      ;\n\n      if (!this.parent) {\n        throw new Error('can not remove isolated entity');\n      }\n\n      var text = this.firstChild.content || '';\n      var textNode;\n      var parent = this.parent,\n          previousSibling = this.previousSibling,\n          nextSibling = this.nextSibling;\n\n      if (previousSibling && previousSibling.isText) {\n        textNode = previousSibling;\n      }\n\n      if (textNode) {\n        textNode.appendText(text);\n      } else {\n        textNode = Node.create(NodeType.TEXT, undefined, {\n          content: text\n        });\n        parent.insertBefore(textNode, this);\n      }\n\n      if (nextSibling && nextSibling.isText) {\n        textNode.appendText(nextSibling.content || '');\n        parent.removeChild(nextSibling);\n      }\n\n      parent.removeChild(this);\n      return textNode;\n    }\n    /**\n     * Build plain text of the node (stripping tags & entities)\n     * @param [options]\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      return (0, _util.stringify)(this, options);\n    }\n    /**\n     * Build source code of the node\n     * @param [options]\n     */\n\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _util.stringify)(this, (0, _objectSpread2.default)({}, options, {\n        toSource: true\n      }));\n    }\n    /**\n     * Convert node to JSON serializable object\n     * @param options \n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$position = options.position,\n          position = _options$position === void 0 ? false : _options$position,\n          _options$textPosition = options.textPosition,\n          textPosition = _options$textPosition === void 0 ? false : _options$textPosition,\n          _options$internalId = options.internalId,\n          internalId = _options$internalId === void 0 ? false : _options$internalId;\n      return _.omitBy({\n        id: internalId ? this.id : undefined,\n        type: this.type,\n        name: this.name,\n        content: this.content,\n        attributes: toJsonMap(this.attributes),\n        metadata: toJsonMap(this.metadata),\n        labels: this.labels.length ? this.labels : undefined,\n        position: position ? {\n          start: this.start,\n          end: this.end\n        } : undefined,\n        textPosition: textPosition ? {\n          start: this.textStart,\n          end: this.textEnd\n        } : undefined,\n        children: _.isEmpty(this.children) ? undefined : this.children.map(function (child) {\n          return child.toJSON(options);\n        })\n      }, _.isUndefined);\n    }\n  }, {\n    key: \"descriptor\",\n    get: function get() {\n      if (this.isEntity || this.isTag || this.isText) {\n        return \"\".concat(this.openDescriptorStart).concat(this.openDescriptorEnd);\n      } else {\n        return this.type;\n      }\n    }\n  }, {\n    key: \"openDescriptorStart\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[\".concat(this.name);\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name);\n\n        case NodeType.TEXT:\n          return '(text';\n\n        default:\n          return \"<\".concat(this.type);\n      }\n    }\n  }, {\n    key: \"openDescriptorEnd\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"]\";\n\n        case NodeType.TAG:\n          return \"}\";\n\n        case NodeType.TEXT:\n          return '';\n\n        default:\n          return '>';\n      }\n    }\n  }, {\n    key: \"closingDescriptor\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[/\".concat(this.name, \"]\");\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name, \"}\");\n\n        case NodeType.TEXT:\n          return ')';\n\n        default:\n          return \"</\".concat(this.type, \">\");\n      }\n    }\n  }, {\n    key: \"selector\",\n    get: function get() {\n      var selector = this.descriptor;\n\n      if (this.parent) {\n        selector = \"\".concat(this.descriptor, \"[\").concat(this.childIndex, \"]\");\n      }\n\n      return selector;\n    }\n  }, {\n    key: \"rootSelector\",\n    get: function get() {\n      if (!this.parent) {\n        return this.selector;\n      }\n\n      var selectors = this.path.map(function (node) {\n        return node.selector;\n      });\n      return selectors.join(' > ');\n    }\n    /**\n     * Check if the node is root\n     */\n\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.type === NodeType.ROOT;\n    }\n    /**\n     * Check if the node is paragraph\n     */\n\n  }, {\n    key: \"isParagraph\",\n    get: function get() {\n      return this.type === NodeType.PARAGRAPH;\n    }\n    /**\n     * Check if the node is tag\n     */\n\n  }, {\n    key: \"isTag\",\n    get: function get() {\n      return this.type === NodeType.TAG;\n    }\n    /**\n     * Check if the node is entity\n     */\n\n  }, {\n    key: \"isEntity\",\n    get: function get() {\n      return this.type === NodeType.ENTITY;\n    }\n    /**\n     * Check if the node is text\n     */\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type === NodeType.TEXT;\n    }\n    /**\n     * Check if the node is text and not wrapping by entity\n     */\n\n  }, {\n    key: \"isPlainText\",\n    get: function get() {\n      return this.type === NodeType.TEXT && (!this.parent || this.parent.type !== NodeType.ENTITY);\n    }\n    /**\n     * Check if the node is wrapping tag\n     */\n\n  }, {\n    key: \"isWrappingTag\",\n    get: function get() {\n      return this.isTag && WrappingTags.includes(this.name);\n    }\n    /**\n     * Check if the node is block tag\n     */\n\n  }, {\n    key: \"isBlockTag\",\n    get: function get() {\n      return this.isTag && BlockTags.includes(this.name);\n    }\n    /**\n     * Check if the node is simple block or inline block\n     */\n\n  }, {\n    key: \"isSimpleTag\",\n    get: function get() {\n      return this.isTag && ['BLOCK', 'INLINE'].includes(this.name);\n    }\n    /**\n     * Property indicates if the node is a block (wrapping other nodes)\n     */\n\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      var type = this.type,\n          name = this.name;\n      return BlockNodeTypes.includes(type) || this.isBlockTag;\n    }\n    /**\n     * If node is inline block\n     */\n\n  }, {\n    key: \"isInlineBlock\",\n    get: function get() {\n      return this.isTag && !this.isBlockTag;\n    }\n    /**\n     * Get parent node, alias for node.parent\n     */\n\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    }\n    /**\n     * Get child nodes, alias for node.children\n     */\n\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    }\n    /**\n     * Get source code of the node\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      if (this.type === NodeType.ROOT) {\n        return this._source || '';\n      }\n\n      var rootNode = this.getRootNode();\n\n      if (!rootNode) {\n        throw new Error('ROOT node not found');\n      }\n\n      return rootNode.source.substring(this.start || 0, this.end);\n    }\n    /**\n     * Get node inner text\n     */\n\n  }, {\n    key: \"innerText\",\n    get: function get() {\n      if (this.type === NodeType.TEXT) {\n        return this.content;\n      } else if (this.type === NodeType.ENTITY) {\n        var textNode = this.children[0];\n        return textNode ? textNode.content : '';\n      } else {\n        return this.toString();\n      }\n    }\n    /**\n     * Check if the node is the first child of its parent\n     */\n\n  }, {\n    key: \"isFirstChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.first(parent.children) === this;\n    }\n    /**\n     * Check if the node is the last child of its parent\n     */\n\n  }, {\n    key: \"isLastChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.last(parent.children) === this;\n    }\n    /**\n     * Siblings from same parent\n     */\n\n  }, {\n    key: \"siblings\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return [this];\n      }\n\n      return parent.children;\n    }\n    /**\n     * Get index of parent children\n     */\n\n  }, {\n    key: \"childIndex\",\n    get: function get() {\n      var siblings = this.siblings;\n      return siblings.indexOf(this);\n    }\n    /**\n     * Next sibling node\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex + 1] || undefined;\n    }\n    /**\n     * Previous sibling node\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex - 1] || undefined;\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      var list = [];\n      var node = this;\n\n      while (node) {\n        list.unshift(node);\n        node = node.parent;\n      }\n\n      return list;\n    }\n    /**\n     * Get the first child of current node\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.first(this.children);\n    }\n    /**\n     * Get the last child of current node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.last(this.children);\n    }\n  }, {\n    key: \"isOnlyChild\",\n    get: function get() {\n      if (!this.parent) {\n        return false;\n      }\n\n      return this.parent.children.length === 1;\n    }\n  }]);\n  return Node;\n}();\n\n(0, _defineProperty2.default)(Node, \"Types\", NodeType);\nvar _default = Node;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextLine.default;\n  }\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _TextLine = _interopRequireDefault(require(\"./TextLine\"));\n\nvar _constants = require(\"./constants\"); // improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\n\n\nvar NOT_FOUND = -1;\nvar LINE_BREAKS = /\\r?\\n/g;\n/**\n * Stream like text string\n * @typicalname stream\n */\n\nvar TextStream =\n/*#__PURE__*/\nfunction () {\n  /** Current cursor position */\n\n  /** Original text */\n\n  /** Tab size */\n\n  /** Text lines */\n\n  /** Start position of each line */\n\n  /** Markers */\n\n  /** Cursor stack positions */\n\n  /** Last matched string of methods like eat() match() */\n  function TextStream(text) {\n    var tabSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    (0, _classCallCheck2.default)(this, TextStream);\n    (0, _defineProperty2.default)(this, \"pos\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"tabSize\", void 0);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"lineOffsetIndexes\", []);\n    (0, _defineProperty2.default)(this, \"markers\", void 0);\n    (0, _defineProperty2.default)(this, \"cursorStack\", void 0);\n    (0, _defineProperty2.default)(this, \"lastMatch\", '');\n    this.pos = 0;\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n\n    this.text = text;\n    /**\n     * @description Tab size\n     */\n\n    this.tabSize = tabSize;\n    /**\n     * @description Lines, separated by line breaks\n     */\n\n    this.lines = [];\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n\n    this.markers = [];\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n\n    this.cursorStack = [];\n    this.init();\n  }\n  /**\n   * Prepare line indexes\n   */\n\n\n  (0, _createClass2.default)(TextStream, [{\n    key: \"init\",\n    value: function init() {\n      var lines = [];\n      var matched;\n      var offset = 0;\n      var ln = 1;\n      LINE_BREAKS.lastIndex = 0;\n\n      do {\n        matched = LINE_BREAKS.exec(this.text);\n\n        if (matched) {\n          var length = matched.index - offset;\n\n          var _text = this.text.substr(offset, length);\n\n          lines.push(new _TextLine.default(lines, _text, ln, offset));\n          offset += length + matched[0].length;\n        } else {\n          var _length = this.text.length - offset; // process last line without line break symbol\n\n\n          if (_length > 0) {\n            var _text2 = this.text.substr(offset);\n\n            lines.push(new _TextLine.default(lines, _text2, ln, offset));\n          }\n        }\n\n        ln++;\n      } while (matched);\n\n      this.lines = lines;\n      this.lineOffsetIndexes = _.map(lines, 'offset');\n    }\n    /**\n     * Get line and column position of the cursor\n     * @param pos Cursor position of the text\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      var lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n      var line = this.lines[lineIndex];\n\n      if (!line) {\n        throw new Error('cursor position is invalid');\n      }\n\n      var ln = line.ln,\n          offset = line.offset;\n      var col = pos - offset + 1;\n      return {\n        ln: ln,\n        col: col,\n        pos: pos,\n        line: line\n      };\n    }\n    /**\n     * Check if cursor is at the start of a line\n     * @param [trimSpaces] Whether to trim starting spaces\n     */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition = this.getPosition(),\n          col = _this$getPosition.col,\n          line = _this$getPosition.line;\n\n      if (col - 1 === 0) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimStart = _.trimStart(line.text),\n          length = _$trimStart.length;\n\n      return col - 1 <= line.length - length;\n    }\n    /**\n     * Check if cursor is at the end of a line\n     * @param [trimSpaces] Whether to trim ending spaces\n     */\n\n  }, {\n    key: \"eol\",\n    value: function eol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition2 = this.getPosition(),\n          col = _this$getPosition2.col,\n          line = _this$getPosition2.line;\n\n      if (col - 1 === line.length) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimEnd = _.trimEnd(line.text),\n          length = _$trimEnd.length;\n\n      return col - 1 >= length;\n    }\n    /**\n     * Check if cursor is at the end of whole text\n     * @param {number} [pos] \n     */\n\n  }, {\n    key: \"eof\",\n    value: function eof(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      return pos >= this.text.length;\n    }\n    /**\n     * Get one next char, but keep the cursor position (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.text.charAt(this.pos);\n    }\n    /**\n     * Get one next char, and move cursor forward (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.text.length) {\n        return this.text.charAt(this.pos++);\n      }\n\n      return '';\n    }\n    /**\n     * Consumes one char if the next char fitting the pattern\n     * @param pattern \n     * @returns The char been eaten\n     */\n\n  }, {\n    key: \"eat\",\n    value: function eat(pattern) {\n      var ch = this.text.charAt(this.pos) || '';\n      var ok;\n\n      if (_.isUndefined(ch)) {\n        ok = false;\n      } else if (_.isString(pattern)) {\n        ok = ch === pattern;\n      } else if (_.isRegExp(pattern)) {\n        pattern.lastIndex = 0;\n        ok = pattern.test(ch);\n      } else if (_.isFunction(pattern)) {\n        ok = pattern(ch);\n      }\n\n      if (ok) {\n        this.lastMatch = ch;\n        ++this.pos;\n        return ch;\n      }\n\n      return '';\n    }\n    /**\n     * Consumes chars while fitting the pattern\n     * @param match \n     * @returns Eaten characters\n     */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(pattern) {\n      var start = this.pos;\n      var chr;\n      var string = '';\n\n      do {\n        chr = this.eat(pattern);\n\n        if (chr) {\n          string += chr;\n        }\n      } while (chr && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes chars until the first char not fitting the pattern\n     * @param pattern char or pattern\n     * @returns eaten characters\n     */\n\n  }, {\n    key: \"eatUntil\",\n    value: function eatUntil(pattern) {\n      var start = this.pos;\n      var ch;\n      var string = '';\n\n      do {\n        ch = this.eat(pattern);\n\n        if (!ch) {\n          string += this.peek();\n          this.pos++;\n        } else {\n          this.pos--;\n        }\n      } while (!ch && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes spaces\n     * @returns {boolean} If any space has been consumed\n     */\n\n  }, {\n    key: \"eatSpaces\",\n    value: function eatSpaces() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n        this.pos++;\n      }\n\n      return this.pos > start;\n    }\n    /**\n     * Find position of matched text to the pattern\n     * @param pattern \n     * @param options\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var caseInsensitive = options.caseInsensitive;\n      var index = NOT_FOUND;\n      var length = 0;\n      var matched = '';\n\n      if (typeof pattern === 'string') {\n        if (caseInsensitive) {\n          pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n        } else {\n          index = this.text.indexOf(pattern, this.pos);\n\n          if (index !== NOT_FOUND) {\n            matched = pattern;\n          }\n        }\n      }\n\n      if (pattern instanceof RegExp) {\n        pattern.lastIndex = this.pos;\n        var result = pattern.exec(this.text);\n\n        if (result) {\n          index = result.index;\n          matched = result[0];\n        } else {\n          index = NOT_FOUND;\n        }\n      }\n\n      var _matched = matched;\n      length = _matched.length;\n      return {\n        index: index,\n        length: length,\n        matched: matched\n      };\n    }\n    /**\n     * Read n chars after current cursor\n     * @param [n] Number of chars to read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var left = this.text.length - this.pos;\n\n      if (left <= 0) {\n        return '';\n      } else if (left < n) {\n        n = left;\n      }\n\n      var result = this.text.substr(this.pos, n);\n      this.pos += n;\n      return result;\n    }\n    /**\n     * Read to text or pattern\n     * @param pattern \n     * @param [options]\n     * @returns Sub-text after current cursor and before (or contains) matched text\n     */\n\n  }, {\n    key: \"readTo\",\n    value: function readTo(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$toEOL = options.toEOL,\n          toEOL = _options$toEOL === void 0 ? false : _options$toEOL,\n          _options$toEOF = options.toEOF,\n          toEOF = _options$toEOF === void 0 ? false : _options$toEOF,\n          _options$consume = options.consume,\n          consume = _options$consume === void 0 ? false : _options$consume,\n          _options$skipMatched = options.skipMatched,\n          skipMatched = _options$skipMatched === void 0 ? false : _options$skipMatched;\n      var start = this.pos;\n\n      var _this$search = this.search(pattern),\n          index = _this$search.index,\n          length = _this$search.length;\n\n      var match = '';\n      var end = -1;\n\n      if (toEOL) {\n        var _this$getPosition3 = this.getPosition(),\n            _line = _this$getPosition3.line;\n\n        end = _line.offset + _line.length;\n      } else if (toEOF) {\n        end = this.text.length;\n      }\n\n      if (index !== NOT_FOUND) {\n        if (toEOL || toEOF) {\n          if (index < end) {\n            end = index;\n          } else {\n            length = 0;\n          }\n        } else {\n          end = index;\n        }\n      }\n\n      if (end !== -1) {\n        this.pos = end;\n\n        if (consume) {\n          end += length;\n          this.pos = end;\n        } else if (skipMatched) {\n          this.pos += length;\n        }\n\n        match = this.text.substring(start, end);\n      }\n\n      this.lastMatch = match;\n      return match;\n    }\n    /**\n     * Read to pattern (contains the matched text)\n     * @param {} pattern Text to find or pattern\n     * @param {object} options Match options\n     * @returns {string} Sub-text after current cursor and until the end of matched text\n     */\n\n  }, {\n    key: \"readOver\",\n    value: function readOver(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        consume: true\n      }));\n    }\n    /**\n     * Read one line\n     * @returns {string} Text containing one line (not including line break)\n     */\n\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var _this$getPosition4 = this.getPosition(),\n          line = _this$getPosition4.line;\n\n      var nextLine = line.next();\n\n      if (this.eof()) {\n        return '';\n      }\n\n      if (nextLine) {\n        this.pos = nextLine.offset;\n        return line.text;\n      } else {\n        var length = line.offset + line.length - this.pos;\n        return this.read(length);\n      }\n    }\n    /**\n     * Move cursor to end of text\n     */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.text.length;\n    }\n    /**\n     * Skip to the beginning of matched text\n     * @param pattern\n     * @param options\n     */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, options);\n      return start !== this.pos;\n    }\n    /**\n     * Skip to the end of matched text\n     * @param pattern\n     */\n\n  }, {\n    key: \"skipOver\",\n    value: function skipOver(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        skipMatched: true\n      }));\n      return start !== this.pos;\n    }\n    /**\n     * Move cursor back\n     * @param n Steps\n     */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.pos -= n;\n    }\n    /**\n     * Check if rest text begins with pattern\n     * @param pattern \n     * @param [options] \n     */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$consume2 = options.consume,\n          consume = _options$consume2 === void 0 ? true : _options$consume2,\n          caseInsensitive = options.caseInsensitive;\n\n      var _this$search2 = this.search(pattern, {\n        caseInsensitive: caseInsensitive\n      }),\n          index = _this$search2.index,\n          length = _this$search2.length,\n          matched = _this$search2.matched;\n\n      if (index !== this.pos) {\n        return '';\n      }\n\n      if (consume) {\n        this.pos += length;\n      }\n\n      this.lastMatch = matched;\n      return matched;\n    }\n    /**\n     * Reset the marker stack\n     */\n\n  }, {\n    key: \"resetMarker\",\n    value: function resetMarker() {\n      this.markers = [];\n    }\n    /**\n     * Add a marker to stack\n     * @param data\n     * @param start\n     */\n\n  }, {\n    key: \"pushMarker\",\n    value: function pushMarker(data, start) {\n      if (_.isUndefined(start)) {\n        start = this.pos;\n      }\n\n      this.markers.push({\n        data: data,\n        start: start\n      });\n    }\n    /**\n     * Set data for current marker\n     * @param data\n     */\n\n  }, {\n    key: \"setMarkerData\",\n    value: function setMarkerData(data) {\n      var marker = _.last(this.markers);\n\n      if (!marker) return;\n\n      _.extend(marker.data, data);\n    }\n    /**\n     * Get data of current markder\n     */\n\n  }, {\n    key: \"getMarkerData\",\n    value: function getMarkerData() {\n      var marker = _.last(this.markers);\n\n      if (!marker) return {};\n      return marker.data;\n    }\n    /**\n     * Return a combined structure of text and it's position according to the previously set start\n     * marker\n     * @param [data] Additional data\n     * @param [end] End marker, if not set, previous set value will be used\n     */\n\n  }, {\n    key: \"popMarker\",\n    value: function popMarker() {\n      var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!_.isPlainObject(_data)) {\n        throw new TypeError('invalid data parameter');\n      }\n\n      if (_.isUndefined(end)) {\n        end = this.pos;\n      }\n\n      var marker = this.markers.pop();\n\n      if (!marker) {\n        return undefined;\n      }\n\n      var data = marker.data,\n          start = marker.start;\n      return {\n        text: this.text.substring(marker.start || 0, end),\n        position: {\n          start: start,\n          end: end\n        },\n        data: (0, _objectSpread2.default)({}, data, _data)\n      };\n    }\n  }, {\n    key: \"findLine\",\n    value: function findLine(text) {\n      return _.find(this.lines, function (line) {\n        return _.trim(line.text) === text;\n      });\n    }\n    /**\n     * Push current cursor to cursor stack, if new position provided, set current cursor to it\n     * @param [pos] \n     */\n\n  }, {\n    key: \"pushCursor\",\n    value: function pushCursor(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      this.cursorStack.push(this.pos);\n      this.pos = pos;\n    }\n    /**\n     * Pop last from cursor stack and set it to current cursor\n     */\n\n  }, {\n    key: \"popCursor\",\n    value: function popCursor() {\n      if (this.cursorStack.length === 0) {\n        throw new Error('out of cursor stack!');\n      }\n\n      this.pos = this.cursorStack.pop();\n      return this.pos;\n    }\n    /**\n     * Debug a single line\n     * @param line \n     * @param numWidth \n     * @param col \n     */\n\n  }, {\n    key: \"debugLine\",\n    value: function debugLine(line, numWidth, col) {\n      var ln = line.ln,\n          text = line.text;\n\n      if (_.isUndefined(numWidth)) {\n        numWidth = (ln + '').length;\n      }\n\n      if (col) {\n        text = text.substring(0, col - 1) + _util.chalk.bgBlue(text.charAt(col - 1)) + text.substring(col);\n      }\n\n      console.log(\"\".concat(_util.chalk.blueBright(\"\".concat(col ? '>' : ' ', \" \").concat(_.padStart(ln + '', numWidth), \" |\")), \" \").concat(text));\n    }\n    /**\n     * Debug cursor column position\n     * @param text Text of the line\n     * @param col Cursor position\n     * @param numWidth fixed line number width\n     */\n\n  }, {\n    key: \"debugCursor\",\n    value: function debugCursor(text, col, numWidth) {\n      var pos = text.substr(0, col - 1).replace(_constants.P_FULL_WIDTH_CHARACTER, 'XX').length;\n      console.log(_util.chalk.blueBright(\"  \".concat(_.repeat(' ', numWidth), \" | \").concat(_.repeat(' ', pos), \"^ \").concat(col)));\n    }\n    /**\n     * Debug current position state, with previous and following lines set by range\n     * @param range \n     */\n\n  }, {\n    key: \"debugState\",\n    value: function debugState() {\n      var _this = this;\n\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$getPosition5 = this.getPosition(),\n          ln = _this$getPosition5.ln,\n          col = _this$getPosition5.col;\n\n      var lineIndex = ln - 1;\n\n      var lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n\n      var numWidth = _.max(lines.map(function (l) {\n        return (l.ln + '').length;\n      }));\n\n      lines.forEach(function (line) {\n        var isCurrent = line.ln === ln;\n\n        _this.debugLine(line, numWidth, isCurrent ? col : 0);\n\n        if (isCurrent) {\n          _this.debugCursor(line.text, col, numWidth);\n        }\n      });\n      console.log();\n    }\n  }]);\n  return TextStream;\n}();\n\nvar _default = TextStream;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n\n  function ParseError(message, text, from, to) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"message\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"text\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"from\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"to\", void 0);\n    _this.message = message;\n    _this.text = text;\n    _this.from = from;\n    _this.to = to;\n    return _this;\n  }\n\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.default = ParseError;","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from '../SourceEditor/SourceEditor';\nimport VisualEditor from '../VisualEditor/VisualEditor';\nimport '@blueprintjs/core/lib/css/blueprint.css';\nimport 'normalize.css/normalize.css';\nimport './Editor.scss';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from '../TreeView/TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  defaultSource: string;\n  className: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  source: string\n  root: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source);\n    (global as any).node = node;\n    console.info('Root node exported as global variable \"node\"', node);\n  } catch(err) {\n    if (err instanceof zaml.ParseError) {\n      const message = `\n        [ParseError]{ERROR.TYPE}: {#MESSAGE ${err.message}}\n\n        #SOURCE\n        content\n\n        from {#POS.START ${err.from.ln}:${err.from.col}} to {#POS.END ${err.to.ln}:${err.to.col}}\n      `;\n      node = zaml.parse(message);\n      const sourceBlock = node.querySelector('#SOURCE');\n      const { text } = err.from.line;\n      if (!sourceBlock) return node;\n      const sourceText = sourceBlock.findOneBy({type: NodeType.TEXT});\n      if (!sourceText) return node;\n      sourceText.content = `${text} `;\n      sourceText.createEntitiesFromText([{\n        type: 'ERROR',\n        start: err.from.col - 1,\n        end: err.to.col - 1,\n      }]);\n    } else {\n      node = zaml.parse(`Error: [${err.message}]{MESSAGE}`);\n      console.error(err);\n    }\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    defaultSource: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    defaultSource: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  public preventSourceChange: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      source: props.defaultSource,\n      root: parse(props.defaultSource),\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n    this.preventSourceChange = false;\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n  }\n\n  componentWillUpdate(nextProps: Props, nextState: State) {\n    if (nextState.selectedNode !== this.state.selectedNode) {\n      console.log('selected node:', nextState.selectedNode);\n    }\n    if (nextState.root !== this.state.root) {\n      console.log('new node:', nextState.root);\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  handleSourceChange(source: string) {\n    if (this.preventSourceChange) return;\n    this.setState({\n      root: parse(source),\n      selectedNode: undefined,\n    });\n  }\n\n  handleNodeChange(root?: zaml.Node, selected?: zaml.Node) {\n    if (!root) return;\n    this.preventSourceChange = true;\n    this.setState({\n      source: root.toSource({ simple: true }),\n      selectedNode: selected,\n    }, () => {\n      this.preventSourceChange = false;\n    });\n  }\n\n  render() {\n    const { source } = this.state;\n    const { root, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={source}\n                height={sourcePaneHeight - 40}\n                onChange={(value: string) => this.handleSourceChange(value)}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  root={root}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onChange={(r?: zaml.Node, n?: zaml.Node) => this.handleNodeChange(r, n)}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  root={root}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                  onChange={n => this.handleNodeChange(root, n)}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar _ref =\n/*#__PURE__*/\nReact.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref4 =\n/*#__PURE__*/\nReact.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref5 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref6 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref7 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref8 =\n/*#__PURE__*/\nReact.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgComponent = function SvgComponent(props) {\n  return React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\"\n  }, props), _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n};\n\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { SvgComponent as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.scss';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      const isEntity = node.type === NodeType.ENTITY;\n      const isTag = node.type === NodeType.TAG;\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      let name = (isTag || isEntity) ? node.name : node.type;\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            >▾</span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {node.openDescriptorStart}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {node.openDescriptorEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {node.closingDescriptor}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\nimport { NodePart } from './TreeNode';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {node.descriptor}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreePropEditor.scss';\nimport TabView from '../Common/TabView';\nimport { KeyValueMap } from '@zaml/parser/typings/Node';\n\ninterface Props {\n  node?: zaml.Node;\n  onChange: (node: zaml.Node) => void;\n}\n\ninterface State {\n  selectedTab?: string;\n  editingIndex: number;\n  inlineError: string;\n}\n\nenum Tab {\n  Labels = 'Labels',\n  Attributes = 'Attributes',\n  Metadata = 'Metadata',\n}\n\nconst tabs = _.values(Tab);\nconst defaultTab = tabs[0];\nconst defaultEditingIndex = -1;\n\nexport default class TreePropEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.instanceOf(zaml.Node),\n  };\n\n  static defaultProps: Props = {\n    onChange: () => {},\n  };\n\n  state = {\n    selectedTab: defaultTab,\n    editingIndex: defaultEditingIndex,\n    inlineError: '',\n  };\n\n  editingElement: HTMLInputElement | null = null;\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (nextProps.node !== this.props.node) {\n      this.setState({\n        selectedTab: defaultTab,\n        editingIndex: defaultEditingIndex,\n      });\n    }\n  }\n\n  renderValue(value: any) {\n    if (value instanceof zaml.Node) {\n      return value.toSource();\n    } else {\n      return JSON.stringify(value);\n    }\n  }\n\n  renderEmptyTip() {\n    return (\n      <div className=\"select-tip\">Please select a node</div>\n    )\n  }\n\n  renderTabContent() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    if (!node) {\n      return this.renderEmptyTip();\n    }\n    switch(selectedTab) {\n      case Tab.Labels:\n        return this.renderLabelEditor(node);\n      case Tab.Attributes:\n        return this.renderAttributeEditor(node, node.attributes);\n      case Tab.Metadata:\n        return this.renderAttributeEditor(node, node.metadata);\n    }\n  }\n\n  focusEditingElement() {\n    if (this.editingElement) {\n      this.editingElement.focus();\n      this.editingElement.select();\n    }\n  }\n\n  handleLabelEdit(index: number) {\n    this.setState({ editingIndex: index }, () => {\n      this.focusEditingElement();\n    });\n  }\n\n  handleLabelUpdate(label: string) {\n    const { node, onChange } = this.props;\n    const { editingIndex } = this.state;\n    if (!node) return;\n    const originalLabel = node.labels[editingIndex] || '';\n    if (label !== originalLabel) {\n      try {\n        zaml.parse(`{INLINE #${label}}TESTING{/INLINE}`);\n      } catch (e) {\n        this.setState({ inlineError: 'Invalid label'});\n        return;\n      }\n      if (editingIndex === node.labels.length) {\n        node.addLabel(label);\n      } else {\n        if (label === '' || node.labels.indexOf(label) >= 0) {\n          node.removeLabel(originalLabel);\n        } else {\n          node.labels[editingIndex] = label;\n        }\n      }\n    }\n    this.cancelLabelEditing();\n    onChange(node);\n  }\n\n  cancelLabelEditing() {\n    this.setState({\n      editingIndex: defaultEditingIndex,\n      inlineError: '',\n    });\n  }\n  \n  renderLabelEditor(node: zaml.Node) {\n    const { editingIndex, inlineError } = this.state;\n    const labels = [...node.labels, ''];\n    return (\n      <div className=\"label-editor\">\n        <table>\n          <tbody>\n          {labels.map((label, i) => (\n            <tr\n              key={label}\n              className={classNames({ error: i === editingIndex && inlineError })}\n            >\n              <td className=\"marker\">{label || i === editingIndex ? '#': ''}</td>\n              {i === editingIndex ?\n                <td>\n                  <input\n                    ref={ref => this.editingElement = ref}\n                    defaultValue={label}\n                    onBlur={(event: React.FocusEvent<HTMLInputElement>) => {\n                      this.handleLabelUpdate(event.currentTarget.value);\n                    }}\n                    onKeyDown={(event: React.KeyboardEvent<HTMLInputElement>) => {\n                      if (event.key === 'Enter') {\n                        this.handleLabelUpdate(event.currentTarget.value);\n                      } else if (event.key === 'Escape') {\n                        this.cancelLabelEditing();\n                      }\n                    }}\n                  />\n                </td>\n              :\n                <td\n                  className=\"editable\"\n                  onClick={() => this.handleLabelEdit(i)}\n                >\n                  {label}\n                </td>\n              }\n            </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderAttributeEditor(node: zaml.Node, props: KeyValueMap) {\n    const keys = Object.keys(props);\n    return (\n      <div className=\"attribute-editor\">\n        <table>\n          <tbody>\n            {keys.map(key => (\n              <tr key={key}>\n                <th>{key}</th>\n                <td>{this.renderValue(props[key])}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  render() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    return (\n      <div className=\"zaml-prop-editor\">\n        <TabView\n          tabs={tabs}\n          selectedTab={selectedTab}\n          onTabChange={(tab: string) => this.setState({ selectedTab: tab })}\n        >\n          {this.renderTabContent()}\n        </TabView>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport './TabView.scss';\n\ninterface Props {\n  tabs: string[];\n  selectedTab: string;\n  onTabChange: (tab: string) => void;\n}\n\nexport default class TabView extends React.Component<Props> {\n\n  render() {\n    const { tabs, selectedTab, onTabChange, children } = this.props\n    return (\n      <div className=\"tab-view\">\n        <ul className=\"tabs\">\n          {tabs.map(tab => (\n            <li\n              key={tab}\n              className={classNames('tab', { selected: tab === selectedTab })}\n              onClick={() => onTabChange(tab)}\n            >\n              <span className=\"label\">{tab}</span>\n            </li>\n          ))}\n        </ul>\n        <div className=\"content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePath from './TreePath';\nimport TreeToolbar from './TreeToolbar';\nimport TreePropEditor from './TreePropEditor';\nimport './TreeView.scss';\n\ninterface Props {\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart;\n  expandedNodes: string[];\n}\n\nconst nil = () => {};\n\nexport default class TreeView extends React.Component<Props, State> {\n  static propTypes = {\n    node: PropTypes.shape({}),\n  };\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n    onChange: nil,\n  };\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds)\n      });\n    }\n  }\n\n  render() {\n    const {\n      root,\n      selectedNode,\n      onSelect,\n      onHover,\n      onChange,\n    } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <SplitPane split=\"horizontal\" defaultSize=\"60%\" minSize={200}>\n          <div className=\"tree-container\">\n            <TreeToolbar />\n            <div className=\"tree\">\n              <TreeNode\n                node={root}\n                selectedNode={selectedNode}\n                selectedPart={selectedPart}\n                expandedNodes={expandedNodes}\n                onSelect={onSelect}\n                onSelectPart={p => this.setState({ selectedPart: p })}\n                onMouseEnter={onHover}\n                onMouseOut={() => onHover()}\n                onExpansionChange={(n: zaml.Node, expanded: boolean) =>\n                  this.handleExpansionChange(n, expanded)\n                }\n              />\n            </div>\n            <TreePath selectedNode={selectedNode} onSelect={onSelect} />\n          </div>\n          <TreePropEditor node={selectedNode} onChange={onChange} />\n        </SplitPane>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:：=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[\\{]/, indent: true},\n    {regex: /[\\}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport './SourceEditor.scss';\nimport './codemirror-mode';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.editor) {\n      if (nextProps.height !== this.props.height && this.editor) {\n        this.editor.setSize(null, nextProps.height);\n      }\n      if (nextProps.value !== this.props.value) {\n        this.editor.setValue(nextProps.value);\n      }\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.scss';\n\nconst { NodeType } = zaml;\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            node-id={node.id}\n            href={node.attributes.url}\n          >\n            <VisualNode\n              node-id={node.children[0].id}\n              {...this.props}\n              node={node.children[0]}\n            />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      'node-id': node.id,\n    }, children);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { ContextMenuTarget, Menu, MenuItem, MenuDivider } from \"@blueprintjs/core\"\nimport VisualNode from './VisualNode';\nimport './VisualEditor.scss';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  commonEntityNames?: string[];\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node, selected?: zaml.Node) => void;\n}\n\ninterface State {\n}\n\n@ContextMenuTarget\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    commonEntityNames: PropTypes.arrayOf(PropTypes.string),\n    root: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    commonEntityNames: ['PER', 'ORG', 'LOC', 'DATE'],\n    onSelect: () => {},\n    onChange: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n  }\n\n  handleDoubleClick(event: React.MouseEvent) {\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const domNode = range.startContainer;\n    const text = domNode.textContent;\n    if (!text) return;\n    event.preventDefault();\n    event.stopPropagation();\n    const punctuationPattern = /[!?:;。！？：；]/g;\n    let startPos = 0;\n    let endPos = text.length;\n    let pos = 0;\n    while (punctuationPattern.exec(text)) {\n      startPos = pos;\n      pos = punctuationPattern.lastIndex;\n      punctuationPattern.lastIndex++;\n      if (pos > range.startOffset) {\n        endPos = pos;\n        break;\n      }\n    }\n    range.setStart(domNode, startPos);\n    range.setEnd(domNode, endPos);\n  }\n\n  handleCreateBlock() {\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const commonNode = this.getNodeByElement(range.commonAncestorContainer as HTMLElement);\n    let startNode = this.getNodeByElement(range.startContainer as HTMLElement);\n    let endNode = this.getNodeByElement(range.endContainer as HTMLElement);\n    if (!commonNode || !startNode || !endNode) {\n      return;\n    }\n    const block = zaml.Node.createBlockByRange({\n      startNode,\n      startOffset: range.startOffset,\n      endNode,\n      endOffset: range.endOffset,\n    });\n    selection.removeAllRanges();\n    onChange(root, block);\n  }\n\n  handleRemoveBlock(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const parent = node.flatten();\n    onChange(root, parent);\n  }\n\n  handleCreateEntity(target: zaml.Node, name: string | null) {\n    if (!name) return;\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.anchorNode !== selection.focusNode) {\n      alert('Entity is only allowed in pure text!');\n      return;\n    }\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const entityNodes = target.createEntities([{\n      type: name,\n      start: range.startOffset,\n      end: range.endOffset,\n    }]);\n    onChange(root, entityNodes[0]);\n  }\n\n  handleRemoveEntity(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const textNode = node.removeEntity();\n    onChange(root, textNode);\n  }\n\n  handleInspect(node: zaml.Node) {\n    const { onSelect } = this.props;\n    onSelect(node);\n  }\n\n  handleSplitSentences(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    node.splitText('：。！？', 'SENTENCE');\n    onChange(root);\n  }\n\n  getNodeByElement(element: HTMLElement) {\n    const { root: root } = this.props;\n    if (!root) return undefined;\n    if (element.nodeType === element.TEXT_NODE || element.classList.contains('children')) {\n      if (!element.parentElement) {\n        return undefined;\n      }\n      element = element.parentElement;\n    }\n    const id = element.getAttribute('node-id');\n    if (!id) return undefined;\n    return root.getNodeById(id);\n  }\n\n  render() {\n    const { root: node, selectedNode } = this.props;\n    return (\n      <div\n        className=\"zaml-visual-editor\"\n        onDoubleClick={(event: React.MouseEvent) => this.handleDoubleClick(event)}\n      >\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n        />\n      </div>\n    )\n  }\n\n  renderContextMenu(e: React.MouseEvent<HTMLElement>) {\n    const { commonEntityNames } = this.props;\n    const target = this.getNodeByElement(e.target as HTMLElement);\n    let node = target;\n    if (!target) return;\n    if (target.type === NodeType.TEXT) {\n      node = target.parent;\n    }\n    if (!node) return;\n    const wrapperNode = node;\n    return (\n      <Menu id=\"menu\">\n        <MenuItem disabled text={node.descriptor} />\n        <MenuDivider />\n        <MenuItem\n          text=\"Create Block\"\n          onClick={() => this.handleCreateBlock()}\n        />\n        {node.isWrappingTag &&\n          <MenuItem\n            text=\"Remove Block\"\n            onClick={() => this.handleRemoveBlock(node)}\n          />\n        }\n        {node.isBlock &&\n          <MenuItem\n            text=\"Split Sentences\"\n            onClick={() => this.handleSplitSentences(node)}\n          />\n        }\n        {target.type === NodeType.TEXT && target.parent && target.parent.type !== NodeType.ENTITY &&\n          <MenuItem text=\"Create Entity\">\n            {commonEntityNames && commonEntityNames.map(name => (\n              <MenuItem\n                key={name}\n                text={name}\n                onClick={() => this.handleCreateEntity(target, name)}\n              />\n            ))}\n            <MenuItem\n              text=\"other...\"\n              onClick={() => this.handleCreateEntity(target, prompt('Please input entity type', 'PER'))}\n            />\n          </MenuItem>\n        }\n        {node.type === NodeType.ENTITY &&\n          <MenuItem\n            text=\"Remove Entity\"\n            onClick={() => this.handleRemoveEntity(node)}\n          />\n        }\n        <MenuDivider />\n        <MenuItem\n          text=\"Inspect\"\n          onClick={() => this.handleInspect(wrapperNode)}\n        />\n      </Menu>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _TextStream = _interopRequireDefault(require(\"./TextStream\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _constants = require(\"./constants\");\n\nvar State;\n\n(function (State) {\n  State[State[\"METADATA\"] = 0] = \"METADATA\";\n  State[State[\"NORMAL\"] = 1] = \"NORMAL\";\n  State[State[\"SINGLE_COMMENT\"] = 2] = \"SINGLE_COMMENT\";\n  State[State[\"MULTIPLE_COMMENT\"] = 3] = \"MULTIPLE_COMMENT\";\n  State[State[\"START\"] = 4] = \"START\";\n  State[State[\"TAG_START\"] = 5] = \"TAG_START\";\n  State[State[\"TAG_NAME\"] = 6] = \"TAG_NAME\";\n  State[State[\"ATTRIBUTE_LIST\"] = 7] = \"ATTRIBUTE_LIST\";\n  State[State[\"ATTRIBUTE_NAME\"] = 8] = \"ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_ASSIGN\"] = 9] = \"ATTRIBUTE_ASSIGN\";\n  State[State[\"ATTRIBUTE_VALUE\"] = 10] = \"ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_FINISH\"] = 11] = \"ATTRIBUTE_FINISH\";\n  State[State[\"TAG_END\"] = 12] = \"TAG_END\";\n  State[State[\"LABEL_START\"] = 13] = \"LABEL_START\";\n  State[State[\"ENTITY_START\"] = 14] = \"ENTITY_START\";\n  State[State[\"ENTITY_BODY\"] = 15] = \"ENTITY_BODY\";\n  State[State[\"ENTITY_END\"] = 16] = \"ENTITY_END\";\n  State[State[\"END\"] = 17] = \"END\";\n  State[State[\"FINISH\"] = 18] = \"FINISH\";\n})(State || (State = {}));\n\n;\nvar stateNames = ['METADATA', 'NORMAL', 'SINGLE_COMMENT', 'MULTIPLE_COMMENT', 'START', 'TAG_START', 'TAG_NAME', 'ATTRIBUTE_LIST', 'ATTRIBUTE_NAME', 'ATTRIBUTE_ASSIGN', 'ATTRIBUTE_VALUE', 'ATTRIBUTE_FINISH', 'TAG_END', 'LABEL_START', 'ENTITY_START', 'ENTITY_BODY', 'ENTITY_END', 'END', 'FINISH'];\n\nvar getStateName = function getStateName(state) {\n  return stateNames[state];\n};\n\nvar countLineBreaks = function countLineBreaks(text) {\n  var result = text.match(_constants.P_LINE_BREAK);\n  return result ? result.length : 0;\n};\n\n;\n/**\n * Tokenizer class\n * @class\n */\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Tokenizer, null, [{\n    key: \"from\",\n    value: function from(text, options) {\n      return new Tokenizer(text, options);\n    }\n  }]);\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n\n  function Tokenizer(text, options) {\n    (0, _classCallCheck2.default)(this, Tokenizer);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"stream\", void 0);\n    (0, _defineProperty2.default)(this, \"options\", void 0);\n    (0, _defineProperty2.default)(this, \"parsed\", void 0);\n    this.text = text;\n    this.stream = new _TextStream.default(text);\n    var defaultOptions = {\n      verbose: process && process.env.DEBUG === 'verbose'\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  (0, _createClass2.default)(Tokenizer, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n    /**\n     * Process a text and parse to AST\n     * @returns Root node of parsed AST\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this = this;\n\n      var text = this.text,\n          stream = this.stream;\n      var metadataMarkerRequired = this.options.needMetadataMarker;\n      var timeStart = Date.now();\n      var state = State.METADATA;\n      var start = 0;\n      var lastState = 0;\n      var lastPos = -1;\n      var states = {\n        unwrapped: false,\n        inline: false,\n        embedded: false,\n        isClosing: false,\n        key: undefined,\n        value: undefined\n      };\n\n      var root = _Node.default.create(_Node.NodeType.ROOT, undefined, {\n        source: text\n      });\n\n      var nodeStack = [];\n      var node = root;\n\n      var getNodeString = function getNodeString(node) {\n        return \"\".concat(node.type).concat(node.name ? \":\".concat(node.name) : '');\n      };\n\n      var debugStack = function debugStack(lastNode) {\n        if (!_this.options.verbose) {\n          return;\n        }\n\n        var separator = ' > ';\n        var stack = nodeStack.concat([node]);\n        var list = stack.map(function (n, i) {\n          var text = getNodeString(n);\n\n          if (i === stack.length - 1) {\n            text = _util.chalk.cyanBright(text);\n          } else {\n            text = _util.chalk.green(text);\n          }\n\n          return text;\n        });\n        var result = list.join(_util.chalk.redBright(separator));\n\n        if (lastNode) {\n          result += _util.chalk.grey(\"\".concat(separator).concat(getNodeString(lastNode)));\n        }\n\n        return result;\n      };\n\n      var pushNode = function pushNode(n) {\n        if (node.start === -1) {\n          node.start = stream.pos;\n        }\n\n        nodeStack.push(node);\n        node = n;\n\n        _this.debug(\"push: \".concat(debugStack(), \"\\n\"));\n      };\n\n      var popNode = function popNode(error) {\n        var lastNode = node;\n        node.end = stream.pos;\n\n        if (node.start === node.end || node.type === _Node.NodeType.PARAGRAPH && !node.hasChild() && node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node = nodeStack.pop();\n\n        _this.debug(\"pop : \".concat(debugStack(lastNode), \"\\n\"));\n\n        if (!node) {\n          throw createError(error || 'unexpected closing node');\n        }\n      }; // replace wrapping paragraph with current block tag\n\n\n      var levelUpBlock = function levelUpBlock() {\n        if (node.parent && node.parent.type === _Node.NodeType.PARAGRAPH) {\n          var blockNode = node;\n          popNode();\n          node.removeChild(blockNode);\n          popNode();\n          node.appendChild(blockNode);\n          pushNode(blockNode);\n        }\n      };\n\n      var createError = function createError(message) {\n        var from;\n        var to;\n        from = stream.getPosition(lastPos);\n        to = stream.pos === lastPos ? stream.getPosition(lastPos + 1) : stream.getPosition();\n\n        _this.debug(\"error: '\".concat(message, \"' at \").concat(from.ln, \":\").concat(from.col));\n\n        _this.debug('current node:');\n\n        if (node) {\n          _this.debug(node.toJSON());\n        }\n\n        _this.debug('current parsing state:');\n\n        _this.debug(JSON.stringify(root, null, 2));\n\n        return new _ParseError.default(message, text, from, to);\n      };\n\n      while (state !== State.FINISH) {\n        // parse failure watcher\n        if (Date.now() - timeStart >= _constants.PROCESSING_TIMEOUT) {\n          this.debug('parsing timeout!');\n          state = State.FINISH;\n        }\n\n        if (state === lastState && lastPos === stream.pos) {\n          throw new Error('Parser fall into infinite loop!');\n        }\n\n        lastState = state;\n        lastPos = stream.pos;\n        this.debug(_util.chalk.magenta(\"# \".concat(getStateName(state), \", pos = \").concat(stream.pos)));\n\n        if (this.options.verbose) {\n          stream.debugState();\n        }\n\n        switch (state) {\n          case State.METADATA:\n            {\n              stream.eatWhile(_constants.P_WHITE_SPACES_EXT);\n              var metadataMatched = stream.match(_constants.T_METADATA_MARKER);\n\n              if (metadataMarkerRequired && !metadataMatched) {\n                state = State.NORMAL;\n                break;\n              }\n\n              if (metadataMatched || stream.match(_constants.P_ATTRIBUTE_LIST, {\n                consume: false\n              })) {\n                node.states.metadata = true;\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.NORMAL:\n            {\n              if (stream.sol(true) || stream.eol(true)) {\n                stream.eatWhile(_constants.P_WHITE_SPACE);\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK)) {\n                popNode();\n\n                if (node.states.unwrapped) {\n                  popNode();\n                }\n\n                break;\n              }\n\n              start = stream.pos;\n\n              if (node.type !== _Node.NodeType.PARAGRAPH && !node.isInlineBlock && stream.sol(true)) {\n                var child = node.createChild(_Node.NodeType.PARAGRAPH, undefined, {\n                  start: start\n                });\n                pushNode(child);\n              }\n\n              var originalText = stream.readTo(_constants.P_MARKER, {\n                toEOF: true\n              });\n              var _text = originalText;\n\n              if (_text) {\n                if (node.children.length === 0) {\n                  _text = _.trimStart(_text);\n                }\n\n                _text = _text.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, _constants.T_LINE_BREAK);\n                _text = _.trimEnd(_text, _constants.T_LINE_BREAKS);\n\n                if (_text) {\n                  node.appendText(_text, {\n                    start: start,\n                    end: stream.pos\n                  });\n                }\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK, {\n                consume: false\n              })) {\n                state = State.NORMAL;\n              } else {\n                state = State.START;\n              }\n\n              break;\n            }\n\n          case State.START:\n            {\n              start = stream.pos;\n              var ch = stream.eat(_constants.P_MARKER);\n              _constants.P_LABEL_START.lastIndex = 0;\n\n              if (ch === _constants.T_SINGLE_LINE_COMMENT) {\n                var rest = stream.eatWhile(_constants.T_SINGLE_LINE_COMMENT);\n\n                if (rest.length === 0) {\n                  state = State.SINGLE_COMMENT;\n                } else {\n                  state = State.MULTIPLE_COMMENT;\n                }\n              } else if (ch === _constants.T_TAG_START) {\n                state = State.TAG_START;\n              } else if (_constants.P_LABEL_START.test(ch)) {\n                states.unwrapped = true;\n                state = State.TAG_START;\n              } else if (ch === _constants.T_TAG_END) {\n                states.isClosing = true;\n                state = State.TAG_END;\n              } else if (ch === _constants.T_ENTITY_START) {\n                state = State.ENTITY_START;\n              } else if (stream.eof()) {\n                state = State.END;\n              } else {\n                throw createError('empty start');\n              }\n\n              break;\n            }\n\n          case State.SINGLE_COMMENT:\n          case State.MULTIPLE_COMMENT:\n            {\n              start = stream.pos;\n              var content = void 0;\n\n              if (state === State.SINGLE_COMMENT) {\n                content = stream.readTo(_constants.P_LINE_BREAK);\n              } else {\n                content = stream.readTo(_constants.P_MULTIPLE_LINE_COMMENT, {\n                  skipMatched: true\n                });\n              }\n\n              if (content) {\n                if (state === State.MULTIPLE_COMMENT) {\n                  content = content.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n                }\n\n                content = _.trim(content);\n              }\n\n              if (content) {\n                node.createChild(_Node.NodeType.COMMENT, undefined, {\n                  start: start,\n                  end: stream.pos,\n                  content: content\n                });\n              }\n\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.TAG_START:\n            {\n              if (stream.eat(_constants.T_TAG_CLOSING)) {\n                states.isClosing = true;\n                state = State.TAG_NAME;\n              } else if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (node.type !== _Node.NodeType.ENTITY && (states.unwrapped || stream.eat(_constants.P_LABEL_START))) {\n                state = State.LABEL_START;\n              } else {\n                var _child = _Node.default.create(_Node.NodeType.TAG, '', {\n                  start: start\n                });\n\n                if (states.embedded) {\n                  _child.states.embedded = true;\n                  _child.states.metaKey = states.key;\n                  states.embedded = false;\n                } else {\n                  node.appendChild(_child);\n                }\n\n                pushNode(_child);\n                state = State.TAG_NAME;\n              }\n\n              if (state === State.NORMAL || state === State.LABEL_START) {\n                stream.pushCursor(start);\n                var tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n                stream.popCursor();\n\n                if (node.type === _Node.NodeType.PARAGRAPH && tagName === 'BLOCK') {\n                  popNode();\n                }\n\n                var _child2 = node.createChild(_Node.NodeType.TAG, tagName, {\n                  start: start,\n                  states: {\n                    simpleBlock: true,\n                    unwrapped: states.unwrapped\n                  }\n                });\n\n                states.unwrapped = false;\n                pushNode(_child2);\n              }\n\n              break;\n            }\n\n          case State.TAG_NAME:\n            {\n              var name = stream.match(_constants.P_TAG_NAME);\n\n              if (!name) {\n                throw createError('expected tag name');\n              }\n\n              states.inline = name === 'INLINE';\n\n              if (states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  stream.pushCursor(start);\n                  popNode();\n                  stream.popCursor();\n                }\n\n                if (name !== node.name) {\n                  throw createError('unexpected closing tag');\n                }\n\n                var _ch = stream.eat(_constants.T_TAG_END);\n\n                if (!_ch) {\n                  throw createError('invalid closing tag');\n                }\n\n                if (!(states.inline || node.isInlineBlock) && !stream.eol()) {\n                  throw createError('closing block tag must take the whole line');\n                }\n\n                state = State.TAG_END;\n              } else {\n                node.name = name;\n\n                if (node.isWrappingTag) {\n                  stream.pushCursor(node.start || 0);\n\n                  if (node.name === 'BLOCK' && !stream.sol(true)) {\n                    throw createError('unexpected start of block inline');\n                  }\n\n                  stream.popCursor();\n\n                  if (node.isBlock) {\n                    levelUpBlock();\n                  }\n                }\n\n                state = State.ATTRIBUTE_LIST;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_LIST:\n            {\n              var spacePattern = node.states.simpleBlock || node.states.unwrapped ? _constants.P_WHITE_SPACE : _constants.P_WHITE_SPACES_EXT;\n              var spaces = stream.eatWhile(spacePattern);\n              var isParsingMetadata = node.states.metadata;\n\n              if (isParsingMetadata) {\n                var endOfFrontMatter = false;\n\n                if (stream.match(_constants.T_METADATA_MARKER)) {\n                  if (!stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('expected new line after metadata closed');\n                  }\n\n                  endOfFrontMatter = true;\n                }\n\n                var lineBreaks = countLineBreaks(spaces);\n\n                if (lineBreaks > 1) {\n                  endOfFrontMatter = true;\n                }\n\n                if (endOfFrontMatter) {\n                  state = State.NORMAL;\n                  node.states.metadata = false;\n                  break;\n                } // deal with simple block at the beginning\n\n\n                if (node.type === _Node.NodeType.ROOT && !stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                }) && lineBreaks === 1) {\n                  var _child3 = node.createChild(_Node.NodeType.TAG, 'BLOCK', {\n                    labels: node.labels,\n                    states: {\n                      unwrapped: true\n                    },\n                    metadata: node.metadata\n                  });\n\n                  node.clearLabels();\n                  node.clearMetadata();\n                  pushNode(_child3);\n                  state = State.NORMAL;\n                  break;\n                }\n              }\n\n              if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (stream.eat(_constants.T_TAG_END)) {\n                state = State.TAG_END;\n              } else if (stream.match(_constants.P_LABEL_START)) {\n                state = State.LABEL_START;\n              } else {\n                if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n                  if (_.isEmpty(node.attributes) && _constants.P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                    states.key = node.name;\n                    node.name = 'BLOCK';\n                    node.states.simpleBlock = true;\n                    levelUpBlock();\n                    state = State.ATTRIBUTE_ASSIGN;\n                    break;\n                  } else {\n                    throw createError('expecting end of tag \"}\" or attribute list');\n                  }\n                }\n\n                state = State.ATTRIBUTE_NAME;\n\n                if (stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                })) {\n                  state = State.ATTRIBUTE_NAME;\n                } else {\n                  state = State.NORMAL;\n                }\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_NAME:\n            {\n              var _key = stream.match(_constants.P_ATTRIBUTE_NAME);\n\n              if (!_key) {\n                throw createError('expecting attribute name');\n              }\n\n              states.key = _key;\n              state = State.ATTRIBUTE_ASSIGN;\n              break;\n            }\n\n          case State.ATTRIBUTE_ASSIGN:\n            {\n              var _ch2 = stream.peek();\n\n              if (_ch2 === _constants.T_TAG_END) {\n                state = State.ATTRIBUTE_FINISH;\n              } else {\n                _ch2 = stream.eat(_constants.P_ATTRIBUTE_ASSIGN);\n\n                if (!_ch2) {\n                  throw createError('expecting assignment \"=\" or \":\"');\n                }\n\n                if (_constants.P_ASSIGN_YAML.test(_ch2)) {\n                  stream.eatWhile(_constants.P_WHITE_SPACE);\n\n                  if (stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('unexpected end of line');\n                  }\n                }\n\n                state = State.ATTRIBUTE_VALUE;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_VALUE:\n            {\n              var _ch3 = stream.peek();\n\n              var _value = void 0;\n\n              if (_ch3 === _constants.T_TAG_START || _ch3 === _constants.T_ENTITY_START) {\n                states.embedded = true;\n                state = State.START;\n                break;\n              } else if (_ch3 === _constants.T_STRING_START) {\n                _value = stream.match(_constants.P_STRING_LITERAL_QUOTED);\n\n                try {\n                  _value = JSON.parse(_value);\n                } catch (e) {\n                  throw createError('invalid string literal');\n                }\n              } else if (stream.match(_constants.P_DATE_LITERAL)) {\n                _value = stream.lastMatch;\n                _value = new Date(_value);\n              } else if (_constants.P_NUMBER_START.test(_ch3)) {\n                _value = stream.match(_constants.P_NUMBER_LITERAL);\n                _value = parseFloat(_value);\n              } else if (stream.match(_constants.P_BOOLEAN_TRUE)) {\n                _value = true;\n              } else if (stream.match(_constants.P_BOOLEAN_FALSE)) {\n                _value = false;\n              } else {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n\n                if (_.isNull(_value)) {\n                  throw createError('unrecognized attribute value');\n                }\n              }\n\n              if (_.isNull(_value)) {\n                throw createError('invalid attribute value');\n              }\n\n              states.value = _value;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n\n          case State.ATTRIBUTE_FINISH:\n            {\n              var _key2 = states.key,\n                  _value2 = states.value;\n              states.key = undefined;\n              states.value = undefined;\n\n              if (_.isUndefined(_value2)) {\n                _value2 = true;\n              }\n\n              if (node.states.metadata) {\n                node.setMetadata(_key2, _value2);\n              } else {\n                node.setAttribute(_key2, _value2);\n              }\n\n              this.debug(\"# \".concat(node.states.metadata ? 'metadata' : 'attribute', \" \").concat(_key2, \"=\").concat(JSON.stringify(_value2)));\n              this.debug();\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.TAG_END:\n            {\n              var parseMetadata = node.isBlockTag && !states.isClosing;\n              var tagNode = node;\n              states.inline = tagNode.isInlineBlock;\n\n              if (!node.isWrappingTag || states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  popNode();\n                }\n\n                popNode();\n\n                if (node.type === _Node.NodeType.ENTITY) {\n                  // copy tag properties to entity and remove temporary tag node\n                  node.setAttributes(tagNode.attributes);\n                  node.name = tagNode.name;\n                  node.removeChild(tagNode);\n                  state = State.ENTITY_END;\n                  tagNode = node;\n                  popNode();\n                }\n\n                if (tagNode.states.embedded) {\n                  if (node.states.metadata) {\n                    node.setMetadata(tagNode.states.metaKey, tagNode);\n                  } else {\n                    node.setAttribute(tagNode.states.metaKey, tagNode);\n                  }\n                }\n              }\n\n              if (states.isClosing && !states.inline) {\n                stream.skipOver(_constants.P_LINE_BREAK);\n              }\n\n              states.isClosing = false;\n              states.inline = false;\n\n              if (parseMetadata) {\n                state = State.METADATA;\n              } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.LABEL_START:\n            {\n              var label = stream.match(_constants.P_LABEL_NAME);\n\n              if (!label) {\n                throw createError('expected label name');\n              }\n\n              node.addLabel(label);\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.ENTITY_START:\n            {\n              var _child4 = _Node.default.create(_Node.NodeType.ENTITY, '', {\n                start: start\n              });\n\n              if (states.embedded) {\n                _child4.states.embedded = true;\n                _child4.states.metaKey = states.key;\n                states.embedded = false;\n              } else {\n                node.appendChild(_child4);\n              }\n\n              pushNode(_child4);\n              state = State.ENTITY_BODY;\n              break;\n            }\n\n          case State.ENTITY_BODY:\n            {\n              start = stream.pos;\n\n              var _text2 = stream.readTo(_constants.T_ENTITY_END, {\n                skipMatched: true\n              });\n\n              if (!_text2) {\n                throw createError('empty entity');\n              } else if (_text2.search(_constants.P_LINE_BREAK) !== -1) {\n                throw createError('unexpected line break of entity');\n              }\n\n              node.appendText(_text2, {\n                start: start,\n                end: start + _text2.length\n              });\n\n              var _ch4 = stream.eat(_constants.T_TAG_START);\n\n              if (_ch4) {\n                state = State.TAG_START;\n              } else {\n                state = State.ENTITY_END;\n              }\n\n              break;\n            }\n\n          case State.ENTITY_END:\n            {\n              popNode();\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.END:\n            {\n              if (node.type !== _Node.NodeType.ROOT) {\n                popNode();\n              }\n\n              state = State.FINISH;\n              break;\n            }\n\n          case State.FINISH:\n            {\n              break;\n            }\n        }\n      }\n\n      root.toString();\n      this.parsed = true;\n      this.debug('parsed result:');\n      this.debug(JSON.stringify(root.toJSON(), null, 2));\n      return root;\n    }\n  }]);\n  return Tokenizer;\n}();\n\nvar _default = Tokenizer;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Class holding text line data\n */\n\n\nvar TextLine =\n/*#__PURE__*/\nfunction () {\n  function TextLine(lines, text, ln, offset) {\n    (0, _classCallCheck2.default)(this, TextLine);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"ln\", void 0);\n    (0, _defineProperty2.default)(this, \"offset\", void 0);\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n  /**\n   * Get the previous line\n   */\n\n\n  (0, _createClass2.default)(TextLine, [{\n    key: \"prev\",\n    value: function prev() {\n      return this.lines[this.ln - 2];\n    }\n    /**\n     * Get the next line\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.lines[this.ln];\n    }\n    /**\n     * Get text length of the line\n     */\n\n  }, {\n    key: \"toJSON\",\n\n    /**\n     * Convert to JSON serializable object\n     */\n    value: function toJSON() {\n      return {\n        ln: this.ln,\n        start: this.start,\n        end: this.end,\n        text: this.text\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n    /**\n     * Start position of the line, alias of `offset`\n     */\n\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.offset;\n    }\n    /**\n     * End position of the line\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n  }]);\n  return TextLine;\n}();\n\nvar _default = TextLine;\nexports.default = _default;"],"sourceRoot":""}