{"version":3,"sources":["../../zaml-parser/lib/util.js","../../zaml-parser/lib/index.js","App.tsx","sample/contract.ts","serviceWorker.ts","index.tsx","Editor/Pane.tsx","../../zaml-parser/lib/constants.js","../../zaml-parser/lib/Node.js","../../zaml-parser/lib/TextStream.js","../../zaml-parser/lib/ParseError.js","Editor/Editor.tsx","Editor/logo.svg","TreeView/TreeNode.tsx","TreeView/TreePathItem.tsx","TreeView/TreePath.tsx","TreeView/TreeToolbar.tsx","TreeView/TreePropEditor.tsx","Common/TabView.tsx","TreeView/TreeView.tsx","SourceEditor/codemirror-mode.ts","SourceEditor/SourceEditor.tsx","VisualEditor/VisualNode.tsx","VisualEditor/VisualEditor.tsx","../../zaml-parser/lib/Tokenizer.js","../../zaml-parser/lib/TextLine.js"],"names":["_interopRequireWildcard","__webpack_require__","Object","defineProperty","exports","value","formatValue","parseValue","P_DATE_FORMAT","test","Date","spacer","stringify","node","options","indent","arguments","length","undefined","pos","text","_","isNumber","space","defaults","_constants","DEFAULT_INDENT_SPACES","simple","toSource","simpleTag","isSimpleTag","labels","keys","attributes","start","textStart","type","_Node","NodeType","TEXT","content","isEmpty","metadata","T_METADATA_MARKER","T_LINE_BREAK","each","key","concat","default","ENTITY","child","first","children","Error","T_ENTITY_START","T_ENTITY_END","TAG","isBlock","T_TAG_START","name","listCount","forEach","i","T_SPACE","isBoolean","label","T_TAG_END","PARAGRAPH","isWrappingTag","subText","next","nextSibling","trimEnd","isLastChild","isBlockTag","T_TAG_CLOSING","end","textEnd","replace","isDate","toISOString","isString","P_STRING_LITERAL_UNQUOTED_TESTER","JSON","isNaN","Infinity","repeat","_interopRequireDefault","tokenize","parse","enumerable","get","_Tokenizer","_TextStream","TextLine","_ParseError","process","console","warn","_default","ParseError","Tokenizer","TextStream","Node","App","react_default","a","createElement","className","Editor","defaultSource","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","Pane","props","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","_this$props","title","react__WEBPACK_IMPORTED_MODULE_5___default","classNames","React","defaultProps","PROCESSING_TIMEOUT","P_MARKER","END_MARKERS","START_MARKERS","P_FULL_WIDTH_CHARACTER","P_BOOLEAN_FALSE","P_BOOLEAN_TRUE","P_STRING_LITERAL_UNQUOTED","P_STRING_LITERAL_QUOTED","P_NUMBER_LITERAL","P_NUMBER_START","P_DATE_LITERAL","T_STRING_START","P_TAG_NAME","P_ATTRIBUTE_LIST","P_ATTRIBUTE_NAME","P_ATTRIBUTE_ASSIGN","P_LABEL_NAME","P_LABEL_START","P_LIST_SEPARATOR","P_WHITE_SPACES_EXT","P_WHITE_SPACE","P_PARAGRAPH_BREAK","P_SPACE_WRAPPED_LINE_BREAK","P_LINE_BREAK","P_ASSIGN_YAML","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","T_METADATA_FAVORED_ASSIGN","T_PARAGRAPH_BREAK","T_LINE_BREAKS","T_ASSIGN_YAML","T_ASSIGN_XML","P_MULTIPLE_LINE_COMMENT","T_SINGLE_LINE_COMMENT","T_TAB","createPattern","combinePatterns","list","map","p","isRegExp","source","escapeRegExp","join","flags","RegExp","testNode","find","_find","findOne","_findOne","parseJson","toJsonMap","parseJsonMap","WrappingTags","BlockTags","BlockNodeTypes","NodeTypes","_regenerator","_asyncToGenerator2","_toConsumableArray2","_slicedToArray2","_objectSpread2","_classCallCheck2","_createClass2","_defineProperty2","_util","_2","nanoid","values","ROOT","defaultFinderCallback","pattern","isFunction","is","TypeError","result","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","json","create","id","childData","appendChild","normalize","mapValues","toJSON","isPlainObject","_props$source","_props$start","_props$end","states","_props$attributes","_props$metadata","_props$labels","parent","_props$content","_props$text","includes","_source","appendText","FRAGMENT","COMMENT","tagName","isArray","n1","n2","ancestor","path1","path","path2","shift","paths","range","startNode","startOffset","endNode","endOffset","isText","RangeError","_parent","fragment","createFragment","block","createTag","substring","insertBefore","removeChild","findCommonAncestor","_paths","baseStartNode","baseEndNode","_startIndex","indexOf","_sort","sort","_sort2","startIndex","endIndex","_ref","_fragment","extractNodes","isStartSided","isSidedDescendantOf","isEndSided","foundBlock","n","_block2","createBlock","insertAt","inserting","startText","_block","endText","expression","toUpperCase","substr","validNode","side","firstChild","lastChild","prependChild","pull","index","pullAt","_this$children","_this","splice","apply","ref","validParent","refIndex","newChild","oldChild","contains","validChild","replaceChild","set","data","merge","has","unset","isObject","isRoot","toString","_this2","selector","one","intersection","findBy","hasChild","findTextByRange","callback","separator","log","isParagraph","isInlineBlock","lastPos","lastIndex","exec","textNodes","filter","_startNode","tn","_endNode","createBlockByRange","_this3","stack","childLength","merged","textNode","createText","slice","mergeText","items","entityNodes","sortBy","item","entityNode","createChild","replaceWith","entities","_this4","cache","Map","createEntities","_extractEntities","mark","_callee","extractor","nodeList","textList","wrap","_context","prev","extract","sent","stop","_x","previousSibling","_options$position","position","_options$textPosition","textPosition","_options$internalId","internalId","omitBy","isUndefined","isEntity","isTag","openDescriptorStart","openDescriptorEnd","descriptor","childIndex","rootNode","getRootNode","last","siblings","unshift","_TextLine","_chalk","LINE_BREAKS","tabSize","lines","markers","cursorStack","init","matched","offset","ln","_text","_text2","lineOffsetIndexes","lineIndex","sortedLastIndex","line","col","trimSpaces","_this$getPosition","getPosition","trimStart","_this$getPosition2","charAt","ok","ch","lastMatch","chr","string","eat","eof","peek","caseInsensitive","left","_options$toEOL","toEOL","_options$toEOF","toEOF","_options$consume","consume","_options$skipMatched","skipMatched","_this$search","search","_line","readTo","nextLine","read","_options$consume2","_this$search2","marker","extend","_data","pop","trim","numWidth","bgBlue","blueBright","padStart","_this$getPosition5","max","min","l","isCurrent","debugLine","debugCursor","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_wrapNativeSuper2","_Error","message","from","to","zaml","global","info","sourceBlock","querySelector","sourceText","findOneBy","createEntitiesFromText","error","state","root","sourcePaneHeight","onResize","throttle","bind","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__","preventSourceChange","addEventListener","passive","removeEventListener","nextProps","nextState","selectedNode","height","innerHeight","setState","selected","_this$state","hoveredNode","react__WEBPACK_IMPORTED_MODULE_7___default","href","_svgr_webpack_prettier_svgo_logo_svg__WEBPACK_IMPORTED_MODULE_16__","react_split_pane__WEBPACK_IMPORTED_MODULE_9__","split","defaultSize","minSize","_Pane__WEBPACK_IMPORTED_MODULE_10__","_SourceEditor_SourceEditor__WEBPACK_IMPORTED_MODULE_11__","onChange","handleSourceChange","_VisualEditor_VisualEditor__WEBPACK_IMPORTED_MODULE_12__","onSelect","r","handleNodeChange","_TreeView_TreeView__WEBPACK_IMPORTED_MODULE_17__","onHover","d","__webpack_exports__","SvgComponent","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","_extends","assign","target","prototype","hasOwnProperty","_ref2","fill","_ref3","_ref4","cx","cy","_ref5","_ref6","x","y","width","rx","ry","_ref7","_ref8","points","data-name","viewBox","NodePart","nil","TreeNode","classCallCheck","possibleConstructorReturn","getPrototypeOf","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","Whole","Header","onClick","event","stopPropagation","commonProps","_onMouseEnter","_onMouseOut","_x2","react","onlyText","node-selected","truncate","Footer","closingDescriptor","TreePathItem","TreePath","buildNodeList","TreePathItem_TreePathItem","TreeToolbar","Tab","TabView","tabs","selectedTab","onTabChange","tab","defaultTab","defaultEditingIndex","TreePropEditor","editingIndex","inlineError","editingElement","renderEmptyTip","Labels","renderLabelEditor","Attributes","renderAttributeEditor","Metadata","focus","select","focusEditingElement","originalLabel","e","addLabel","removeLabel","cancelLabelEditing","toConsumableArray","defaultValue","onBlur","handleLabelUpdate","currentTarget","onKeyDown","handleLabelEdit","renderValue","_this5","TabView_TabView","renderTabContent","TreeView","without","nodeIds","union","index_esm","TreeToolbar_TreeToolbar","TreeNode_TreeNode","handleExpansionChange","TreePath_TreePath","TreePropEditor_TreePropEditor","CodeMirror","defineSimpleMode","regex","token","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","editor","setSize","setValue","react_codemirror2","onBeforeChange","_onChange","_x3","editorDidMount","VisualNode","element","node-name","node-id","url","toLowerCase","VisualEditor","ContextMenuTarget","handleContextMenu","currentNode","selection","getSelection","rangeCount","getRangeAt","domNode","startContainer","textContent","preventDefault","punctuationPattern","startPos","endPos","setStart","setEnd","commonNode","getNodeByElement","commonAncestorContainer","endContainer","removeAllRanges","_this$props2","flatten","_this$props3","anchorNode","focusNode","alert","_this$props4","removeEntity","_this$props5","splitText","nodeType","TEXT_NODE","classList","parentElement","getAttribute","getNodeById","_this$props6","onDoubleClick","handleDoubleClick","VisualNode_VisualNode","commonEntityNames","wrapperNode","menu","menuItem","disabled","menuDivider","handleCreateBlock","handleRemoveBlock","handleSplitSentences","handleCreateEntity","prompt","handleRemoveEntity","handleInspect","State","stateNames","getStateName","countLineBreaks","stream","defaultOptions","verbose","NODE_ENV","PUBLIC_URL","DEBUG","parsed","_console","timeStart","now","METADATA","lastState","unwrapped","inline","embedded","isClosing","nodeStack","getNodeString","debugStack","lastNode","cyanBright","green","redBright","grey","pushNode","debug","popNode","createError","levelUpBlock","blockNode","FINISH","magenta","debugState","eatWhile","ATTRIBUTE_LIST","NORMAL","sol","eol","START","SINGLE_COMMENT","MULTIPLE_COMMENT","TAG_START","TAG_END","ENTITY_START","END","TAG_NAME","LABEL_START","_child","metaKey","pushCursor","popCursor","_child2","simpleBlock","spacePattern","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","_child3","clearLabels","clearMetadata","ATTRIBUTE_ASSIGN","ATTRIBUTE_NAME","_key","_ch2","ATTRIBUTE_FINISH","eatSpaces","ATTRIBUTE_VALUE","_ch3","_value","parseFloat","isNull","_key2","_value2","setMetadata","setAttribute","parseMetadata","tagNode","setAttributes","ENTITY_END","skipOver","_child4","ENTITY_BODY"],"mappings":"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","file":"static/js/main.2c6799d1.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatValue = formatValue;\nexports.parseValue = parseValue;\nexports.spacer = spacer;\nexports.stringify = stringify;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n/**\n * Stringify attribute value\n * @param value \n */\n\nfunction formatValue(value) {\n  if (_.isDate(value)) {\n    return value.toISOString().replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString) {\n    return _constants.P_STRING_LITERAL_UNQUOTED_TESTER.test(value) ? value : JSON.stringify(value);\n  } else if (_.isBoolean(value)) {\n    return JSON.stringify(value);\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n/**\n * Parse attribute value\n * @param value \n */\n\n\nfunction parseValue(value) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\n\n\nfunction spacer(space, indent) {\n  if (indent <= 0) return '';\n  return _.repeat(_constants.T_SPACE, space * indent);\n}\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\n\n\nfunction stringify(node, options) {\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var text = '';\n\n  if (_.isNumber(options)) {\n    options = {\n      space: options\n    };\n  }\n\n  options = _.defaults(options, {\n    space: _constants.DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false\n  });\n  var simpleTag = options.simple && node.isSimpleTag && (node.labels.length > 0 || Object.keys(node.attributes).length > 0);\n\n  if (options.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n\n  if (node.type === _Node.NodeType.TEXT) {\n    text += node.content;\n  } else {\n    if (options.toSource && !_.isEmpty(node.metadata)) {\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n\n      _.each(node.metadata, function (value, key) {\n        text += \"\".concat(key, \": \");\n\n        if (value instanceof _Node.default) {\n          text += stringify(value, options, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n\n        text += _constants.T_LINE_BREAK;\n      });\n\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n    }\n\n    if (node.type === _Node.NodeType.ENTITY) {\n      var child = _.first(node.children);\n\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_START;\n      }\n\n      text += stringify(child, options, indent, pos + text.length);\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_END;\n      }\n    }\n\n    if (options.toSource && (node.type === _Node.NodeType.TAG || node.type === _Node.NodeType.ENTITY)) {\n      if (node.isBlock) {\n        text += spacer(options.space, indent);\n      }\n\n      if (!(simpleTag && node.children.length === 1)) {\n        text += _constants.T_TAG_START;\n      }\n\n      if (!simpleTag) {\n        text += node.name;\n      }\n\n      var listCount = 0;\n\n      _.keys(node.attributes).forEach(function (key, i) {\n        var value = node.attributes[key];\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        if (_.isBoolean(value) && value) {\n          text += key;\n        } else if (value instanceof _Node.default) {\n          text += stringify(node, options, 0, pos + text.length);\n        } else {\n          text += \"\".concat(key, \"=\").concat(formatValue(value));\n        }\n      });\n\n      _.each(node.labels, function (label, i) {\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        text += \"#\".concat(label);\n      });\n\n      text += simpleTag ? _constants.T_SPACE : _constants.T_TAG_END;\n\n      if (node.isBlock) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.type === _Node.NodeType.PARAGRAPH) {\n      text += spacer(options.space, indent);\n    }\n\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(function (child) {\n        var subText = stringify(child, options, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n\n    var next = node.nextSibling;\n\n    if (node.isBlock) {\n      if (options.toSource) {\n        text = _.trimEnd(text, _constants.T_LINE_BREAK);\n      }\n\n      text += _constants.T_LINE_BREAK;\n\n      if (node.type === _Node.NodeType.PARAGRAPH && !node.isLastChild) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(options.space, indent);\n      }\n\n      if (simpleTag) {\n        if (node.children.length > 1) {\n          text += _constants.T_TAG_END;\n        }\n      } else {\n        text += _constants.T_TAG_START + _constants.T_TAG_CLOSING + node.name + _constants.T_TAG_END;\n      }\n\n      if (node.isBlockTag) {\n        text += _constants.T_LINE_BREAK;\n\n        if (next && next.isBlock) {\n          text += _constants.T_LINE_BREAK;\n        }\n      }\n    }\n  }\n\n  if (options.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.parse = parse;\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _Tokenizer.default;\n  }\n});\nObject.defineProperty(exports, \"TextStream\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.default;\n  }\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.TextLine;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.default;\n  }\n});\nObject.defineProperty(exports, \"NodeType\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.NodeType;\n  }\n});\nObject.defineProperty(exports, \"ParseError\", {\n  enumerable: true,\n  get: function get() {\n    return _ParseError.default;\n  }\n});\nexports.default = void 0;\n\nvar _Tokenizer = _interopRequireDefault(require(\"./Tokenizer\"));\n\nvar _TextStream = _interopRequireWildcard(require(\"./TextStream\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/**\n * @module @zaml/parser\n * @typicalname parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\n\n\nfunction parse(text, options) {\n  var tokenizer = new _Tokenizer.default(text, options);\n  return tokenizer.process();\n}\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\n\n\nfunction tokenize(text, options) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nvar _default = {\n  ParseError: _ParseError.default,\n  Tokenizer: _Tokenizer.default,\n  TextStream: _TextStream.default,\n  TextLine: _TextStream.TextLine,\n  Node: _Node.default,\n  NodeType: _Node.NodeType,\n  tokenize: tokenize,\n  parse: parse\n};\nexports.default = _default;","import React, { Component } from 'react';\nimport './App.scss';\nimport Editor from './Editor/Editor';\nimport contract from './sample/contract';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Editor defaultSource={contract} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export default \n`#各方基本信息\n甲方：[北京星核软件有限公司]{ORG}\n统一社会信用代码：[345976348]{SOC}\n法定代表人：[张鸿峰]{PER}\n地址：[北京市朝阳区方恒国际D座2806]{LOC}\n乙方：[孙继顺]{PER}\n身份证号：[230101197701018888]{ID}\n手机号：[13945018888]{MOBILE}\n---\n\n甲乙双方经友好协商，达成如下协议。\n\n#标的.租赁 #描述\n一、{#标的.租赁 #描述.地址 #描述.数量 甲方租赁乙方所有的位于[北京市朝阳区南磨房路37号]{LOC}门市房[一间]{QT}}。{#描述.面积 使用面积为[105平方米]{AREA}}。{#标的.租赁.租期 租期为[2019年1月1日]{DATE}至[2019年12月31日]{DATE}}；{#标的.租赁.租金 租金为[十万元人民币]{MONEY value=100000}}。\n\n#标的.租赁.用途\n二、该门市房的用途为新注册公司的经营地。\n\n#标的.付款方式.银行 #标的.租赁.计费方式.按月结算\n三、租金按月结算。{#约定.承租方.支付.租金 甲方每月[一日]{DATE}向乙方指定账户一次汇入当月租金。}\n\n#约定.承租方.支付.定金 #事件.合同生效\n四、甲方应于合同生效起[五日内]{DUE}向乙方支付定金[一万元整]{MONEY}。\n\n#约定.出租方.交付.租赁物 #事件.履约.出租方.交付\n五、乙方应在收到定金给交给乙方钥匙用于提前装修。装修费用由甲方自行承担。\n\n#约定\n六、{#约定.承租方.支付.押金 甲方应于[计租日前]{DUE}向乙方支付押金[一万元整]{MONEY}。}{#约定.出租方.返还押金 #事件.合同期满 #事件.合同解除 租赁期满或合同解除后[两日内]{DUE}，乙方应无息返还。}\n\n{#事件.违约 #违约责任\n  七、违约责任\n\n  #事件.违约 #违约.付款方.付款 #违约责任.补偿.违约金 #违约责任.补偿.违约金.计算方式.每逾期一天\n  1. 付款方未按照约定付款的，每逾期[一天]{PERIOD}，应按逾期金额的[1%]{RATE}向收款方支付违约金。\n\n  #事件.违约 #违约.出租方.交付.租赁物 #违约责任.补偿.违约金.计算方式.每逾期一天 #违约责任.补偿.顺延\n  2. 乙方延迟交房的，每逾期[一天]{PERIOD}，应向甲方支付违约金[100元]{DATE}，并将租期做相应的顺延。\n  \n}\n\n{#事件.不可抗力 #约定.解除合同\n  八、发生如下情形，任何一方有权解除合同，并不承担违约责任：\n\n  #事件.不可抗力.政府行为.拆迁\n  1. 该门市房被政府列入拆迁范围；\n\n  #事件.不可抗力.重大灾害\n  2. 发生地震、火灾等不可抗力。\n\n}\n\n#争议解决 #争议解决.方式.法院起诉 #争议解决.地点.合同一方所在地\n九、双方发生争议协调不成的，应向甲方所在地人民法院起诉。\n`;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROCESSING_TIMEOUT = exports.P_MARKER = exports.END_MARKERS = exports.START_MARKERS = exports.P_FULL_WIDTH_CHARACTER = exports.P_BOOLEAN_FALSE = exports.P_BOOLEAN_TRUE = exports.P_STRING_LITERAL_UNQUOTED_TESTER = exports.P_STRING_LITERAL_UNQUOTED = exports.P_STRING_LITERAL_QUOTED = exports.P_NUMBER_LITERAL = exports.P_NUMBER_START = exports.P_DATE_LITERAL = exports.T_STRING_START = exports.P_TAG_NAME = exports.P_ATTRIBUTE_LIST = exports.P_ATTRIBUTE_NAME = exports.P_ATTRIBUTE_ASSIGN = exports.P_LABEL_NAME = exports.P_LABEL_START = exports.P_LIST_SEPARATOR = exports.P_WHITE_SPACES_EXT = exports.P_WHITE_SPACE = exports.P_PARAGRAPH_BREAK = exports.P_SPACE_WRAPPED_LINE_BREAK = exports.P_LINE_BREAK = exports.P_ASSIGN_YAML = exports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = exports.T_METADATA_FAVORED_ASSIGN = exports.T_PARAGRAPH_BREAK = exports.T_LINE_BREAKS = exports.T_LINE_BREAK = exports.T_ASSIGN_YAML = exports.T_ASSIGN_XML = exports.T_TAG_END = exports.T_TAG_CLOSING = exports.T_TAG_START = exports.T_ENTITY_END = exports.T_ENTITY_START = exports.P_MULTIPLE_LINE_COMMENT = exports.T_SINGLE_LINE_COMMENT = exports.T_METADATA_MARKER = exports.T_TAB = exports.T_SPACE = exports.DEFAULT_INDENT_SPACES = exports.createPattern = exports.combinePatterns = void 0;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar combinePatterns = function combinePatterns(list) {\n  return list.map(function (p) {\n    return _.isRegExp(p) ? p.source : _.escapeRegExp(p);\n  }).join('|');\n};\n\nexports.combinePatterns = combinePatterns;\n\nvar createPattern = function createPattern(source) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'g';\n  return new RegExp(source, flags);\n};\n\nexports.createPattern = createPattern;\nvar DEFAULT_INDENT_SPACES = 2;\nexports.DEFAULT_INDENT_SPACES = DEFAULT_INDENT_SPACES;\nvar T_SPACE = ' ';\nexports.T_SPACE = T_SPACE;\nvar T_TAB = '\\t';\nexports.T_TAB = T_TAB;\nvar T_METADATA_MARKER = \"---\";\nexports.T_METADATA_MARKER = T_METADATA_MARKER;\nvar T_SINGLE_LINE_COMMENT = '~';\nexports.T_SINGLE_LINE_COMMENT = T_SINGLE_LINE_COMMENT;\nvar P_MULTIPLE_LINE_COMMENT = '~{3,}';\nexports.P_MULTIPLE_LINE_COMMENT = P_MULTIPLE_LINE_COMMENT;\nvar T_ENTITY_START = '[';\nexports.T_ENTITY_START = T_ENTITY_START;\nvar T_ENTITY_END = ']';\nexports.T_ENTITY_END = T_ENTITY_END;\nvar T_TAG_START = '{';\nexports.T_TAG_START = T_TAG_START;\nvar T_TAG_CLOSING = '/';\nexports.T_TAG_CLOSING = T_TAG_CLOSING;\nvar T_TAG_END = '}';\nexports.T_TAG_END = T_TAG_END;\nvar T_ASSIGN_XML = '=';\nexports.T_ASSIGN_XML = T_ASSIGN_XML;\nvar T_ASSIGN_YAML = ':：';\nexports.T_ASSIGN_YAML = T_ASSIGN_YAML;\nvar T_LINE_BREAK = '\\n';\nexports.T_LINE_BREAK = T_LINE_BREAK;\nvar T_LINE_BREAKS = '\\r\\n';\nexports.T_LINE_BREAKS = T_LINE_BREAKS;\nvar T_PARAGRAPH_BREAK = '\\n\\n';\nexports.T_PARAGRAPH_BREAK = T_PARAGRAPH_BREAK;\nvar T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexports.T_METADATA_FAVORED_ASSIGN = T_METADATA_FAVORED_ASSIGN;\nvar T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\nexports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_TAG_ATTRIBUTE_FAVORED_ASSIGN;\nvar P_ASSIGN_YAML = /[:：]/;\nexports.P_ASSIGN_YAML = P_ASSIGN_YAML;\nvar P_LINE_BREAK = /\\r?\\n/g;\nexports.P_LINE_BREAK = P_LINE_BREAK;\nvar P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexports.P_SPACE_WRAPPED_LINE_BREAK = P_SPACE_WRAPPED_LINE_BREAK;\nvar P_PARAGRAPH_BREAK = createPattern(\"\".concat(P_LINE_BREAK.source, \"\\\\s*\").concat(P_LINE_BREAK.source));\nexports.P_PARAGRAPH_BREAK = P_PARAGRAPH_BREAK;\nvar P_WHITE_SPACE = /[ \\t]/g;\nexports.P_WHITE_SPACE = P_WHITE_SPACE;\nvar P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexports.P_WHITE_SPACES_EXT = P_WHITE_SPACES_EXT;\nvar P_LIST_SEPARATOR = /[,，]/g;\nexports.P_LIST_SEPARATOR = P_LIST_SEPARATOR;\nvar P_LABEL_START = /[#＃]/g;\nexports.P_LABEL_START = P_LABEL_START;\nvar P_LABEL_NAME = /(?:[A-Za-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\.0-9A-Z_a-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])*/g;\nexports.P_LABEL_NAME = P_LABEL_NAME;\nvar P_ATTRIBUTE_ASSIGN = createPattern(\"[\".concat([T_ASSIGN_XML, T_ASSIGN_YAML].join(''), \"]\"), '');\nexports.P_ATTRIBUTE_ASSIGN = P_ATTRIBUTE_ASSIGN;\nvar P_ATTRIBUTE_NAME = createPattern(\"(?:\".concat(P_LABEL_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"), 'gu');\nexports.P_ATTRIBUTE_NAME = P_ATTRIBUTE_NAME;\nvar P_ATTRIBUTE_LIST = createPattern(\"(\".concat(P_LABEL_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"|\").concat(P_LABEL_START.source).concat(P_LABEL_NAME.source, \")\"));\nexports.P_ATTRIBUTE_LIST = P_ATTRIBUTE_LIST;\nvar P_TAG_NAME = P_ATTRIBUTE_NAME;\nexports.P_TAG_NAME = P_TAG_NAME;\nvar T_STRING_START = '\"';\nexports.T_STRING_START = T_STRING_START;\nvar P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\d(?:T[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?/g;\nexports.P_DATE_LITERAL = P_DATE_LITERAL;\nvar P_NUMBER_START = /[\\d\\.]/;\nexports.P_NUMBER_START = P_NUMBER_START;\nvar P_NUMBER_LITERAL = /(\\d+|\\d*\\.\\d+|\\d+\\.\\d*)(e\\d+)?/g;\nexports.P_NUMBER_LITERAL = P_NUMBER_LITERAL;\nvar P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\\")*\"/g;\nexports.P_STRING_LITERAL_QUOTED = P_STRING_LITERAL_QUOTED;\nvar P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexports.P_STRING_LITERAL_UNQUOTED = P_STRING_LITERAL_UNQUOTED;\nvar P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(\"^\".concat(P_STRING_LITERAL_UNQUOTED.source, \"$\"));\nexports.P_STRING_LITERAL_UNQUOTED_TESTER = P_STRING_LITERAL_UNQUOTED_TESTER;\nvar P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexports.P_BOOLEAN_TRUE = P_BOOLEAN_TRUE;\nvar P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexports.P_BOOLEAN_FALSE = P_BOOLEAN_FALSE;\nvar P_FULL_WIDTH_CHARACTER = /(?:[\\xD7\\u2014\\u2026\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3001\\u3002\\u3005\\u3007\\u300A-\\u300D\\u3010\\u3011\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFF01\\uFF03\\uFF05\\uFF06\\uFF08\\uFF09\\uFF0B-\\uFF0D\\uFF1A\\uFF1B\\uFF1D\\uFF1F\\uFF20\\uFFE5]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])/g;\nexports.P_FULL_WIDTH_CHARACTER = P_FULL_WIDTH_CHARACTER;\nvar START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexports.START_MARKERS = START_MARKERS;\nvar END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexports.END_MARKERS = END_MARKERS;\nvar P_MARKER = createPattern(\"(\".concat(combinePatterns([P_PARAGRAPH_BREAK].concat(START_MARKERS, [T_TAG_END, P_MULTIPLE_LINE_COMMENT, T_SINGLE_LINE_COMMENT])), \")\"));\nexports.P_MARKER = P_MARKER;\nvar PROCESSING_TIMEOUT = Infinity;\nexports.PROCESSING_TIMEOUT = PROCESSING_TIMEOUT;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testNode = testNode;\nexports.find = _find;\nexports.findOne = _findOne;\nexports.parseJson = parseJson;\nexports.toJsonMap = toJsonMap;\nexports.parseJsonMap = parseJsonMap;\nexports.default = exports.WrappingTags = exports.BlockTags = exports.BlockNodeTypes = exports.NodeTypes = exports.NodeType = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _2 = require(\".\");\n\nvar nanoid = require('nanoid');\n\nvar NodeType;\nexports.NodeType = NodeType;\n\n(function (NodeType) {\n  NodeType[\"FRAGMENT\"] = \"fragment\";\n  NodeType[\"ROOT\"] = \"root\";\n  NodeType[\"PARAGRAPH\"] = \"paragraph\";\n  NodeType[\"TAG\"] = \"tag\";\n  NodeType[\"ENTITY\"] = \"entity\";\n  NodeType[\"TEXT\"] = \"text\";\n  NodeType[\"COMMENT\"] = \"comment\";\n})(NodeType || (exports.NodeType = NodeType = {}));\n\nvar NodeTypes = _.values(NodeType);\n\nexports.NodeTypes = NodeTypes;\nvar BlockNodeTypes = [NodeType.ROOT, NodeType.PARAGRAPH];\nexports.BlockNodeTypes = BlockNodeTypes;\nvar BlockTags = ['BLOCK', 'QUOTE', 'SECTION', 'HEADER', 'FOOTER'];\nexports.BlockTags = BlockTags;\nvar WrappingTags = BlockTags.concat(['INLINE', 'SENTENCE', 'NUM', 'HEADING']);\nexports.WrappingTags = WrappingTags;\n\nvar defaultFinderCallback = function defaultFinderCallback(node) {\n  return true;\n};\n\nfunction testNode(pattern, node) {\n  if (_.isFunction(pattern)) {\n    return pattern(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\n\n\nfunction _find(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        _find(childNode, pattern, result);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\n\n\nfunction _findOne(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n\n  if (testNode(pattern, node)) {\n    return node;\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var childNode = _step2.value;\n\n        var result = _findOne(childNode, pattern);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    ;\n  }\n\n  return undefined;\n}\n\nfunction parseJson(json) {\n  var node = Node.create(json.type, json.name, {\n    id: json.id,\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content\n  });\n\n  if (json.children) {\n    _.each(json.children, function (childData) {\n      node.appendChild(parseJson(childData));\n    });\n  }\n\n  node.normalize();\n  return node;\n}\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\n\n\nfunction toJsonMap(map) {\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n\n  return _.mapValues(map, function (value) {\n    if (value instanceof Node) {\n      return value.toJSON();\n    }\n\n    return value;\n  });\n}\n\nfunction parseJsonMap(json) {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n\n  return _.mapValues(json, function (value) {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n\n    return (0, _util.parseValue)(value);\n  });\n}\n/**\n * AST node class\n * @class\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Node, null, [{\n    key: \"create\",\n\n    /**\n     * Create node, shortcut for constructor \n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n    value: function create(type, name, props) {\n      return new Node(type, name, props);\n    }\n    /**\n     * Create paragraph node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createParagraph\",\n    value: function createParagraph(props) {\n      return new Node(NodeType.PARAGRAPH, undefined, props);\n    }\n    /**\n     * Create root node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createRoot\",\n    value: function createRoot(props) {\n      return new Node(NodeType.ROOT, undefined, props);\n    }\n    /**\n     * Create text node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(content, props) {\n      return new Node(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n        content: content\n      }));\n    }\n    /**\n     * Create a common tag\n     * @param tagName Tag name, e.g. `'BLOCK'`, `'INLINE'`, `'SENTENCE'`\n     * @param [props]\n     */\n\n  }, {\n    key: \"createTag\",\n    value: function createTag(tagName, props) {\n      return new Node(NodeType.TAG, tagName, props);\n    }\n    /**\n     * Create block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(props) {\n      return new Node(NodeType.TAG, 'BLOCK', props);\n    }\n    /**\n     * Create inline block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createInlineBlock\",\n    value: function createInlineBlock(props) {\n      return new Node(NodeType.TAG, 'INLINE', props);\n    }\n    /**\n     * Create node instance from ZAML source\n     * @param source \n     */\n\n  }, {\n    key: \"fromSource\",\n    value: function fromSource(source) {\n      return (0, _2.parse)(source);\n    }\n    /**\n     * Create node from json serializable data\n     * @param json \n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return parseJson(json);\n    }\n    /**\n     * Creating fragment node\n     */\n\n  }, {\n    key: \"createFragment\",\n    value: function createFragment() {\n      return Node.create(NodeType.FRAGMENT);\n    }\n    /**\n     * Check if a node is valid\n     * @param node \n     */\n\n  }, {\n    key: \"validNode\",\n    value: function validNode(node) {\n      if (!(node instanceof Node)) {\n        throw new TypeError('invalid node');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validParent\",\n    value: function validParent(node) {\n      if (!_.isArray(node.children)) {\n        throw new Error('node is not a valid parent');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validChild\",\n    value: function validChild(node) {\n      if (!node.parent) {\n        throw new Error('node is not a valid child');\n      }\n    }\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(n1, n2) {\n      var path1 = n1.path;\n      var path2 = n2.path;\n      var ancestor;\n\n      while (path1.length > 0 && path2.length > 0) {\n        if (_.first(path1) !== _.first(path2)) {\n          break;\n        }\n\n        ancestor = path1.shift();\n        path2.shift();\n      }\n\n      if (!ancestor) {\n        return undefined;\n      }\n\n      return {\n        ancestor: ancestor,\n        paths: [path1, path2]\n      };\n    }\n    /**\n     * Find the common ancestor of the range, and creates a wrapping block (or tag) with the nodes\n     * within the range in it.\n     * \n     * If the range is within a block (BLOCK tag or paragraph), a inline tag is created, otherwise\n     * a BLOCK tag is created.\n     * \n     * If a BLOCK tag is used, `startOffset` and `endOffset` will be ignored, to avoid block overlap.\n     * \n     * If either `startNode` or `endNode` is not direct child of common ancestor nor the node is not\n     * sided aligned with the direct child of the ancestor, text offset will be ignored to avoid\n     * split of tags or entity.\n     * \n     * @param range A range object which contains start and end node, alone with their text offset\n     * @param props Custom tag props\n     * @param tagName If inline tag is needed, specify the tag name instead of default `'INLINE'`\n     */\n\n  }, {\n    key: \"createBlockByRange\",\n    value: function createBlockByRange(range) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var startNode = range.startNode,\n          startOffset = range.startOffset,\n          endNode = range.endNode,\n          endOffset = range.endOffset;\n\n      if (!_.isNumber(startOffset) || !_.isNumber(endOffset)) {\n        throw new TypeError('range offset must be number');\n      }\n\n      if (!startNode.isText || !endNode.isText) {\n        throw new TypeError('range node must be text');\n      }\n\n      if (!startNode.content || !endNode.content) {\n        throw new Error('invalid text node');\n      }\n\n      if (startNode === endNode) {\n        if (startOffset < 0 || startOffset > startNode.content.length || endOffset < 0 || endOffset > startNode.content.length) {\n          throw new RangeError('sub text out of range');\n        }\n\n        if (!startNode.parent) {\n          throw new Error('can not create block on isolated text node');\n        }\n\n        var _parent = startNode.parent;\n        var fragment = Node.createFragment();\n        var block = Node.createTag(tagName, (0, _objectSpread2.default)({}, props, {\n          text: startNode.content.substring(startOffset, endOffset)\n        }));\n\n        if (startOffset > 0) {\n          fragment.appendText(startNode.content.substring(0, startOffset));\n        }\n\n        fragment.appendChild(block);\n\n        if (endOffset < startNode.content.length) {\n          fragment.appendText(startNode.content.substring(endOffset));\n        }\n\n        _parent.insertBefore(fragment, startNode);\n\n        _parent.removeChild(startNode);\n\n        return block;\n      } else {\n        var result = Node.findCommonAncestor(startNode, endNode);\n        if (!result || !result.ancestor) return undefined;\n        var ancestor = result.ancestor,\n            _paths = result.paths;\n        var baseStartNode = _paths[0][0];\n        var baseEndNode = _paths[1][0];\n\n        var _startIndex = ancestor.children.indexOf(baseStartNode);\n\n        var _endIndex = ancestor.children.indexOf(baseEndNode);\n\n        var _sort = [_startIndex, _endIndex].sort(),\n            _sort2 = (0, _slicedToArray2.default)(_sort, 2),\n            startIndex = _sort2[0],\n            endIndex = _sort2[1];\n\n        if (_startIndex !== startIndex) {\n          var _ref = [baseEndNode, baseStartNode];\n          baseStartNode = _ref[0];\n          baseEndNode = _ref[1];\n        }\n\n        var _fragment = ancestor.extractNodes(startIndex, endIndex + 1);\n\n        var isStartSided = startNode.isSidedDescendantOf(baseStartNode, 'start') && startOffset === 0;\n        var isEndSided = endNode.isSidedDescendantOf(baseEndNode, 'end') && endOffset === endNode.content.length;\n        var foundBlock = ancestor.findOne(function (n) {\n          return n.isBlock;\n        });\n        var hasBlock = foundBlock && foundBlock !== ancestor;\n\n        if (!hasBlock && (_paths[0].length === 1 || isStartSided || _paths[1].length === 1 || isEndSided)) {\n          var inserting = Node.createFragment();\n          var startText = startNode.content;\n\n          if (startOffset > 0) {\n            baseStartNode.content = startText.substring(startOffset);\n            inserting.appendText(startText.substring(0, startOffset));\n          }\n\n          var _block = Node.createTag(tagName, props);\n\n          _block.appendChild(_fragment);\n\n          inserting.appendChild(_block);\n          var endText = endNode.content;\n\n          if (endOffset < endNode.content.length) {\n            baseEndNode.content = endText.substring(0, endOffset);\n            inserting.appendText(endText.substring(endOffset));\n          }\n\n          ancestor.insertAt(inserting, startIndex);\n          return _block;\n        } else {\n          var _block2 = Node.createBlock(props);\n\n          ancestor.insertAt(_block2, startIndex);\n\n          _block2.appendChild(_fragment);\n\n          return _block2;\n        }\n      }\n    }\n  }]);\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n\n  function Node(type, name) {\n    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Node);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", '');\n    (0, _defineProperty2.default)(this, \"type\", void 0);\n    (0, _defineProperty2.default)(this, \"name\", void 0);\n    (0, _defineProperty2.default)(this, \"start\", -1);\n    (0, _defineProperty2.default)(this, \"end\", -1);\n    (0, _defineProperty2.default)(this, \"textStart\", -1);\n    (0, _defineProperty2.default)(this, \"textEnd\", -1);\n    (0, _defineProperty2.default)(this, \"states\", void 0);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"labels\", void 0);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"content\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", '');\n    (0, _defineProperty2.default)(this, \"children\", void 0);\n    var id = props.id,\n        _props$source = props.source,\n        source = _props$source === void 0 ? '' : _props$source,\n        _props$start = props.start,\n        start = _props$start === void 0 ? -1 : _props$start,\n        _props$end = props.end,\n        end = _props$end === void 0 ? -1 : _props$end,\n        states = props.states,\n        _props$attributes = props.attributes,\n        attributes = _props$attributes === void 0 ? {} : _props$attributes,\n        _props$metadata = props.metadata,\n        metadata = _props$metadata === void 0 ? {} : _props$metadata,\n        _props$labels = props.labels,\n        labels = _props$labels === void 0 ? [] : _props$labels,\n        parent = props.parent,\n        _props$content = props.content,\n        content = _props$content === void 0 ? '' : _props$content,\n        _props$text = props.text,\n        text = _props$text === void 0 ? '' : _props$text;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(\"invalid node type \".concat(type));\n    }\n\n    this.id = id || nanoid();\n    this.states = states || {};\n    this.type = type;\n    this.name = undefined;\n    this.start = start;\n    this.end = end;\n    this.textStart = -1;\n    this.textEnd = -1;\n    this.parent = parent;\n    this._source = undefined;\n    this.content = undefined;\n    this.children = [];\n    this.labels = [];\n    this.attributes = {};\n    this.metadata = {};\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n\n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n  /**\n   * Get a short descriptor to identify node's type and basic information\n   */\n\n\n  (0, _createClass2.default)(Node, [{\n    key: \"getRootNode\",\n\n    /**\n     * Property indicates if the root is root (which has no children)\n     */\n    value: function getRootNode() {\n      var node = this;\n\n      while (node.parent) {\n        node = node.parent;\n      }\n\n      if (node === this) {\n        return undefined;\n      }\n\n      return node;\n    }\n    /**\n     * Check node match the expression\n     * @example\n     * `BLOCK`: tag\n     * `@LOC`: entity\n     * @param expression \n     */\n\n  }, {\n    key: \"is\",\n    value: function is(expression) {\n      if (!_.isString(expression)) {\n        return false;\n      }\n\n      expression = expression.toUpperCase();\n\n      if (/^[A-Z]/.test(expression)) {\n        return this.type === NodeType.TAG && this.name === expression;\n      } else if (/^#/.test(expression)) {\n        return this.type === NodeType.TAG && this.labels.includes(expression.substr(1));\n      } else if (/^@[A-Z]/.test(expression)) {\n        return this.type === NodeType.ENTITY && this.name === expression.substr(1);\n      }\n\n      return false;\n    }\n    /**\n     * whether a node is a descendant of a given node\n     * @param node \n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      Node.validNode(node);\n\n      while (node) {\n        if (node === this) {\n          return true;\n        }\n\n        if (!node.parent) {\n          return false;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Get a list of ancestors\n     */\n\n  }, {\n    key: \"hasChild\",\n\n    /**\n     * Check if this node has any children\n     */\n    value: function hasChild() {\n      return this.children.length > 0;\n    }\n    /**\n     * Check if this node is the only child of its parent\n     */\n\n  }, {\n    key: \"isOnlyDescendantOf\",\n\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n    value: function isOnlyDescendantOf(ancestor) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length !== 1) {\n          return false;\n        }\n\n        node = node.children[0];\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n\n  }, {\n    key: \"isSidedDescendantOf\",\n    value: function isSidedDescendantOf(ancestor, side) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        node = side === 'start' ? node.firstChild : node.lastChild;\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Create a child node\n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n\n  }, {\n    key: \"createChild\",\n    value: function createChild(type, name, props) {\n      var node = new Node(type, name, props);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Insert a node at the beginning of the children\n     * @param node \n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(node) {\n      return this.insertAt(node, 0);\n    }\n    /**\n     * Append a node to children list\n     * @param node \n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.insertAt(node, Infinity);\n    }\n    /**\n     * Append text node child\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = this.content || '';\n        this.content += text;\n        return this;\n      } else {\n        if (this.lastChild && this.lastChild.isText) {\n          this.lastChild.content += text;\n        } else {\n          var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n            content: text\n          }));\n          this.appendChild(child);\n        }\n      }\n    }\n    /**\n     * Add text node child at the beginning\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"prependText\",\n    value: function prependText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = \"\".concat(text).concat(this.content || '');\n        return this;\n      } else {\n        var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n          content: text\n        }));\n        this.prependChild(child);\n      }\n    }\n    /**\n     * Remove one child\n     * @param node\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      _.pull(this.children, child);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Remove one child by index\n     * @param index\n     */\n\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var child = this.children[index];\n\n      _.pullAt(this.children, index);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Insert a node at specified position\n     * @param node \n     * @param index \n     */\n\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(node, index) {\n      var _this = this;\n\n      if (node.type === NodeType.FRAGMENT) {\n        var _this$children;\n\n        (_this$children = this.children).splice.apply(_this$children, [index, 0].concat((0, _toConsumableArray2.default)(node.children)));\n\n        node.children.forEach(function (child) {\n          child.parent = _this;\n        });\n        node.children = [];\n      } else {\n        this.children.splice(index, 0, node);\n\n        if (node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node.parent = this;\n      }\n\n      return node;\n    }\n    /**\n     * Insert a node before another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex);\n      return node;\n    }\n    /**\n     * Insert a node after another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex + 1);\n      return node;\n    }\n    /**\n     * Replace a child with another node, assuming current node is a parent\n     * @param newChild \n     * @param oldChild \n     * @returns The replaced child\n     */\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      Node.validParent(this);\n\n      if (newChild.contains(this)) {\n        throw new TypeError('the new child contains the parent');\n      }\n\n      if (oldChild.parent !== this) {\n        throw new TypeError('the old child is not a child of this node');\n      }\n\n      this.insertBefore(newChild, oldChild);\n      this.removeChild(oldChild);\n      return oldChild;\n    }\n    /**\n     * Replace current child node with another node, assuming current node is child\n     * @param node Node to be replaced with\n     */\n\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(node) {\n      Node.validChild(this);\n\n      if (!this.parent) {\n        throw new Error('can not replace isolated node');\n      }\n\n      this.parent.replaceChild(node, this);\n      return node;\n    }\n    /**\n     * Set single attribute value\n     * @param {string} key Attribute key\n     * @param {any} value Attribute value\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      _.set(this.attributes, key, value);\n    }\n    /**\n     * Set multiple attributes\n     * @param data Key-value pair\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(data) {\n      _.merge(this.attributes, data);\n    }\n    /**\n     * Get attribute value\n     * @param key \n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return _.get(this.attributes, key);\n    }\n    /**\n     * Check if a specified attribute key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return _.has(this.attributes, key);\n    }\n    /**\n     * Remove an attribute\n     * @param {string} key \n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      _.unset(this.attributes, key);\n    }\n    /**\n     * Remove all attributes\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes() {\n      this.attributes = {};\n    }\n    /**\n     * Set single metadata value\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(key, value) {\n      if (_.isObject(key)) {\n        _.merge(this.metadata, key);\n      } else {\n        _.set(this.metadata, key, value);\n      }\n    }\n    /**\n     * Get metadata value\n     * @param key \n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(key) {\n      return _.get(this.metadata, key);\n    }\n    /**\n     * Remove a metadata\n     * @param key \n     */\n\n  }, {\n    key: \"removeMetadata\",\n    value: function removeMetadata(key) {\n      _.unset(this.metadata, key);\n    }\n    /**\n     * Remove all metadata\n     */\n\n  }, {\n    key: \"clearMetadata\",\n    value: function clearMetadata() {\n      this.metadata = {};\n    }\n    /**\n     * Check if a specified metadata key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasMetadata\",\n    value: function hasMetadata(key) {\n      return _.has(this.metadata, key);\n    }\n    /**\n     * Add label to node\n     * @param label \n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(label) {\n      if (!_.isString(label)) {\n        throw new TypeError('label must be string');\n      }\n\n      if (!this.labels.includes(label)) {\n        this.labels.push(label);\n      }\n    }\n    /**\n     * Check if the node has specified label\n     * @param label \n     */\n\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(label) {\n      return this.labels.includes(label);\n    }\n    /**\n     * Remove label\n     * @param label \n     */\n\n  }, {\n    key: \"removeLabel\",\n    value: function removeLabel(label) {\n      _.pull(this.labels, label);\n    }\n    /**\n     * Remove all labels\n     */\n\n  }, {\n    key: \"clearLabels\",\n    value: function clearLabels() {\n      this.labels = [];\n    }\n    /**\n     * Rebuild text and source position, in case modification has been applied to node\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var source = this.toSource();\n\n      if (this.isRoot) {\n        this._source = source;\n      }\n\n      this.toString();\n    }\n    /**\n     * Get node by id\n     * @param id \n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      return _findOne(this, function (node) {\n        return node.id === id;\n      });\n    }\n    /**\n     * Find matched descendants recursively\n     * @param selector Node selector object\n     * @param [one] Find the first matched node or a list of node\n     */\n\n  }, {\n    key: \"findBy\",\n    value: function findBy() {\n      var _this2 = this;\n\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var type = selector.type,\n          name = selector.name,\n          text = selector.text,\n          source = selector.source,\n          label = selector.label;\n      var finder = one ? _findOne : _find;\n      return finder(this, function (node) {\n        var match = true;\n\n        if (type) {\n          match = match && type === node.type;\n        }\n\n        if (name) {\n          match = match && name === node.name;\n        }\n\n        if (text && node.type === NodeType.TEXT && node.content) {\n          if (_.isRegExp(text)) {\n            match = match && !!text.match(node.content);\n          } else if (_.isString(text)) {\n            match = match && node.content.includes(text);\n          } else {\n            throw new TypeError('text filter should be RegExp or string');\n          }\n        }\n\n        if (source && node._source) {\n          if (_.isRegExp(source)) {\n            match = match && !!source.match(node._source);\n          } else if (_.isString(source)) {\n            match = match && node._source.includes(source);\n          } else {\n            throw new TypeError('source filter should be RegExp or string');\n          }\n        }\n\n        if (label) {\n          if (_.isArray(label)) {\n            match = match && _.intersection(_this2.labels, label).length > 0;\n          } else {\n            match = match && _this2.labels.includes(label);\n          }\n        }\n\n        return match;\n      });\n      ;\n    }\n    /**\n     * Find nodes by selector recursively and return the first one\n     * @param selector \n     */\n\n  }, {\n    key: \"findOneBy\",\n    value: function findOneBy() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.findBy(selector, true);\n    }\n    /**\n     * Find matched text node by text source range\n     * @param start \n     * @param end \n     */\n\n  }, {\n    key: \"findTextByRange\",\n    value: function findTextByRange(start, end) {\n      if (this.textStart === undefined || this.textEnd === undefined) {\n        return undefined;\n      }\n\n      if (this.textStart <= start && this.textEnd >= end) {\n        if (this.type === NodeType.TEXT) {\n          return this;\n        } else if (this.hasChild()) {\n          for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            var match = child.findTextByRange(start, end);\n\n            if (match) {\n              return match;\n            }\n          }\n\n          ;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Find matched children recursively by callback\n     * @param callback\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback) {\n      return _find(this, callback);\n    }\n    /**\n     * Find matched children recursively and return the first one\n     * @param callback\n     */\n\n  }, {\n    key: \"findOne\",\n    value: function findOne(callback) {\n      return _findOne(this, callback);\n    }\n    /**\n     * Find all nodes by selector, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return _find(this, selector);\n    }\n    /**\n     * Find nodes by selector and return the first one, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return _findOne(this, selector);\n    }\n    /**\n     * Split node text into tag wrapped sections, e.g. splitting sentences\n     * \n     * @example \n     * node.splitText('!?.');\n     * @param separator RegExp or character list in string, to split\n     * @param tagName Custom tag name, like `'SENTENCE'`\n     */\n\n  }, {\n    key: \"splitText\",\n    value: function splitText(separator) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var pattern = separator instanceof RegExp ? separator : new RegExp(\"[\".concat(_.escapeRegExp(separator), \"]\"), 'g');\n      console.log(pattern);\n      var list = this.find(function (node) {\n        return node.isParagraph || node.isInlineBlock;\n      });\n      list.forEach(function (node) {\n        var text = node.toString();\n        var pos = 0;\n        var lastPos = 0;\n        pattern.lastIndex = 0;\n\n        while (pattern.exec(text)) {\n          // recreate text offset for each node\n          node.toString();\n          pos = pattern.lastIndex;\n          var textNodes = node.children.filter(function (n) {\n            return n.isText;\n          });\n\n          var _startNode = textNodes.find(function (tn) {\n            return tn.textStart <= lastPos && tn.textEnd > lastPos;\n          });\n\n          var _endNode = textNodes.find(function (tn) {\n            return tn.textStart < pos && tn.textEnd >= pos;\n          });\n\n          if (!_startNode || !_endNode) {\n            break;\n          }\n\n          var range = {\n            startNode: _startNode,\n            startOffset: lastPos - _startNode.textStart,\n            endNode: _endNode,\n            endOffset: pos - _endNode.textStart\n          };\n          Node.createBlockByRange(range, tagName, props);\n          lastPos = pos;\n        }\n      });\n    }\n    /**\n     * Merge neighbor text nodes\n     */\n\n  }, {\n    key: \"mergeText\",\n    value: function mergeText() {\n      var _this3 = this;\n\n      var stack = [];\n      var childLength = this.children.length;\n      this.children.forEach(function (child, i) {\n        if (child.isText) {\n          stack.push(child);\n        }\n\n        if (!child.isText || i === childLength - 1) {\n          if (stack.length > 1) {\n            var merged = stack.map(function (child) {\n              return child.content;\n            }).join('');\n            var textNode = Node.createText(merged);\n\n            _this3.insertBefore(textNode, stack[0]);\n\n            var n;\n\n            while (n = stack.shift()) {\n              _this3.removeChild(n);\n            }\n          }\n\n          stack = [];\n        }\n      });\n    }\n  }, {\n    key: \"extractNodes\",\n    value: function extractNodes(startIndex, endIndex) {\n      var fragment = Node.createFragment();\n\n      if (startIndex < 0 || startIndex >= this.children.length || endIndex < 0 || endIndex > this.children.length) {\n        throw new RangeError('invalid range of children');\n      }\n\n      var nodes = this.children.slice(startIndex, endIndex);\n      nodes.forEach(function (child) {\n        fragment.appendChild(child);\n      });\n      return fragment;\n    }\n    /**\n     * Remove a element and move its children to its parent\n     */\n\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      if (!this.parent) {\n        return;\n      }\n\n      var parent = this.parent;\n      var fragment = this.extractNodes(0, this.children.length);\n      parent.insertBefore(fragment, this);\n      parent.removeChild(this);\n      parent.mergeText();\n      return parent;\n    }\n    /**\n     * Process text node in current node and parse entities\n     */\n\n  }, {\n    key: \"createEntities\",\n    value: function createEntities(items) {\n      var entityNodes = [];\n\n      if (this.type !== NodeType.TEXT) {\n        console.warn('extractEntity() should exec only on text node');\n      }\n\n      if (!this.content || _.isEmpty(items)) {\n        return entityNodes;\n      }\n\n      var text = this.content;\n      items = _.sortBy(items, ['start']);\n      var fragment = Node.createFragment();\n      var lastPos = 0;\n      items.forEach(function (item) {\n        if (item.start >= item.end || item.start < lastPos) {\n          return;\n        }\n\n        if (item.start > lastPos) {\n          fragment.appendText(text.substring(lastPos, item.start));\n        }\n\n        var entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n          attributes: item.data\n        });\n        entityNode.appendText(text.substring(item.start, item.end));\n        entityNodes.push(entityNode);\n        lastPos = item.end;\n      });\n\n      if (lastPos < text.length) {\n        fragment.appendText(text.substr(lastPos));\n      }\n\n      this.replaceWith(fragment);\n      return entityNodes;\n    }\n    /**\n     * Create entity nodes based on text source position\n     * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n     */\n\n  }, {\n    key: \"createEntitiesFromText\",\n    value: function createEntitiesFromText(entities) {\n      var _this4 = this;\n\n      this.toString();\n      var cache = new Map();\n\n      _.each(entities, function (item) {\n        var textNode = _this4.findTextByRange(item.start, item.end);\n\n        if (textNode === undefined) {\n          return;\n        }\n\n        if (cache.has(textNode)) {\n          cache.get(textNode).push(item);\n        } else {\n          cache.set(textNode, [item]);\n        }\n      });\n\n      cache.forEach(function (items, textNode) {\n        textNode.createEntities(items.map(function (item) {\n          return (0, _objectSpread2.default)({}, item, {\n            start: item.start - (textNode.textStart || 0),\n            end: item.end - (textNode.textStart || 0)\n          });\n        }));\n      });\n    }\n    /**\n     * Extract entities from text node\n     */\n\n  }, {\n    key: \"extractEntities\",\n    value: function () {\n      var _extractEntities = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(extractor) {\n        var nodeList, textList, result;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nodeList = this.find(function (node) {\n                  return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n                });\n                textList = nodeList.map(function (node) {\n                  return node.content;\n                });\n\n                if (!_.isFunction(extractor)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                result = textList.map(function (text) {\n                  return extractor(text);\n                });\n                _context.next = 13;\n                break;\n\n              case 6:\n                if (!_.isFunction(extractor.extract)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 9;\n                return extractor.extract(textList);\n\n              case 9:\n                result = _context.sent;\n                _context.next = 13;\n                break;\n\n              case 12:\n                throw new TypeError('invalid extractor');\n\n              case 13:\n                nodeList.forEach(function (node, i) {\n                  var items = result[i];\n\n                  if (!_.isArray(items)) {\n                    throw new Error('invalid extraction result');\n                  }\n\n                  node.createEntities(items);\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function extractEntities(_x) {\n        return _extractEntities.apply(this, arguments);\n      };\n    }()\n    /**\n     * Remove wrapping entity and put text back\n     */\n\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity() {\n      if (this.type !== NodeType.ENTITY || !this.firstChild || this.firstChild.type !== NodeType.TEXT) {\n        throw new Error('invalid entity');\n      }\n\n      ;\n\n      if (!this.parent) {\n        throw new Error('can not remove isolated entity');\n      }\n\n      var text = this.firstChild.content || '';\n      var textNode;\n      var parent = this.parent,\n          previousSibling = this.previousSibling,\n          nextSibling = this.nextSibling;\n\n      if (previousSibling && previousSibling.isText) {\n        textNode = previousSibling;\n      }\n\n      if (textNode) {\n        textNode.appendText(text);\n      } else {\n        textNode = Node.create(NodeType.TEXT, undefined, {\n          content: text\n        });\n        parent.insertBefore(textNode, this);\n      }\n\n      if (nextSibling && nextSibling.isText) {\n        textNode.appendText(nextSibling.content || '');\n        parent.removeChild(nextSibling);\n      }\n\n      parent.removeChild(this);\n      return textNode;\n    }\n    /**\n     * Build plain text of the node (stripping tags & entities)\n     * @param [options]\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      return (0, _util.stringify)(this, options);\n    }\n    /**\n     * Build source code of the node\n     * @param [options]\n     */\n\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _util.stringify)(this, (0, _objectSpread2.default)({}, options, {\n        toSource: true\n      }));\n    }\n    /**\n     * Convert node to JSON serializable object\n     * @param options \n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$position = options.position,\n          position = _options$position === void 0 ? false : _options$position,\n          _options$textPosition = options.textPosition,\n          textPosition = _options$textPosition === void 0 ? false : _options$textPosition,\n          _options$internalId = options.internalId,\n          internalId = _options$internalId === void 0 ? false : _options$internalId;\n      return _.omitBy({\n        id: internalId ? this.id : undefined,\n        type: this.type,\n        name: this.name,\n        content: this.content,\n        attributes: toJsonMap(this.attributes),\n        metadata: toJsonMap(this.metadata),\n        labels: this.labels.length ? this.labels : undefined,\n        position: position ? {\n          start: this.start,\n          end: this.end\n        } : undefined,\n        textPosition: textPosition ? {\n          start: this.textStart,\n          end: this.textEnd\n        } : undefined,\n        children: _.isEmpty(this.children) ? undefined : this.children.map(function (child) {\n          return child.toJSON(options);\n        })\n      }, _.isUndefined);\n    }\n  }, {\n    key: \"descriptor\",\n    get: function get() {\n      if (this.isEntity || this.isTag || this.isText) {\n        return \"\".concat(this.openDescriptorStart).concat(this.openDescriptorEnd);\n      } else {\n        return this.type;\n      }\n    }\n  }, {\n    key: \"openDescriptorStart\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[\".concat(this.name);\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name);\n\n        case NodeType.TEXT:\n          return '(text';\n\n        default:\n          return \"<\".concat(this.type);\n      }\n    }\n  }, {\n    key: \"openDescriptorEnd\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"]\";\n\n        case NodeType.TAG:\n          return \"}\";\n\n        case NodeType.TEXT:\n          return '';\n\n        default:\n          return '>';\n      }\n    }\n  }, {\n    key: \"closingDescriptor\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[/\".concat(this.name, \"]\");\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name, \"}\");\n\n        case NodeType.TEXT:\n          return ')';\n\n        default:\n          return \"</\".concat(this.type, \">\");\n      }\n    }\n  }, {\n    key: \"selector\",\n    get: function get() {\n      var selector = this.descriptor;\n\n      if (this.parent) {\n        selector = \"\".concat(this.descriptor, \"[\").concat(this.childIndex, \"]\");\n      }\n\n      return selector;\n    }\n  }, {\n    key: \"rootSelector\",\n    get: function get() {\n      if (!this.parent) {\n        return this.selector;\n      }\n\n      var selectors = this.path.map(function (node) {\n        return node.selector;\n      });\n      return selectors.join(' > ');\n    }\n    /**\n     * Check if the node is root\n     */\n\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.type === NodeType.ROOT;\n    }\n    /**\n     * Check if the node is paragraph\n     */\n\n  }, {\n    key: \"isParagraph\",\n    get: function get() {\n      return this.type === NodeType.PARAGRAPH;\n    }\n    /**\n     * Check if the node is tag\n     */\n\n  }, {\n    key: \"isTag\",\n    get: function get() {\n      return this.type === NodeType.TAG;\n    }\n    /**\n     * Check if the node is entity\n     */\n\n  }, {\n    key: \"isEntity\",\n    get: function get() {\n      return this.type === NodeType.ENTITY;\n    }\n    /**\n     * Check if the node is text\n     */\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type === NodeType.TEXT;\n    }\n    /**\n     * Check if the node is text and not wrapping by entity\n     */\n\n  }, {\n    key: \"isPlainText\",\n    get: function get() {\n      return this.type === NodeType.TEXT && (!this.parent || this.parent.type !== NodeType.ENTITY);\n    }\n    /**\n     * Check if the node is wrapping tag\n     */\n\n  }, {\n    key: \"isWrappingTag\",\n    get: function get() {\n      return this.isTag && WrappingTags.includes(this.name);\n    }\n    /**\n     * Check if the node is block tag\n     */\n\n  }, {\n    key: \"isBlockTag\",\n    get: function get() {\n      return this.isTag && BlockTags.includes(this.name);\n    }\n    /**\n     * Check if the node is simple block or inline block\n     */\n\n  }, {\n    key: \"isSimpleTag\",\n    get: function get() {\n      return this.isTag && ['BLOCK', 'INLINE'].includes(this.name);\n    }\n    /**\n     * Property indicates if the node is a block (wrapping other nodes)\n     */\n\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      var type = this.type,\n          name = this.name;\n      return BlockNodeTypes.includes(type) || this.isBlockTag;\n    }\n    /**\n     * If node is inline block\n     */\n\n  }, {\n    key: \"isInlineBlock\",\n    get: function get() {\n      return this.isTag && !this.isBlockTag;\n    }\n    /**\n     * Get parent node, alias for node.parent\n     */\n\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    }\n    /**\n     * Get child nodes, alias for node.children\n     */\n\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    }\n    /**\n     * Get source code of the node\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      if (this.type === NodeType.ROOT) {\n        return this._source || '';\n      }\n\n      var rootNode = this.getRootNode();\n\n      if (!rootNode) {\n        throw new Error('ROOT node not found');\n      }\n\n      return rootNode.source.substring(this.start || 0, this.end);\n    }\n    /**\n     * Get node inner text\n     */\n\n  }, {\n    key: \"innerText\",\n    get: function get() {\n      if (this.type === NodeType.TEXT) {\n        return this.content;\n      } else if (this.type === NodeType.ENTITY) {\n        var textNode = this.children[0];\n        return textNode ? textNode.content : '';\n      } else {\n        return this.toString();\n      }\n    }\n    /**\n     * Check if the node is the first child of its parent\n     */\n\n  }, {\n    key: \"isFirstChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.first(parent.children) === this;\n    }\n    /**\n     * Check if the node is the last child of its parent\n     */\n\n  }, {\n    key: \"isLastChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.last(parent.children) === this;\n    }\n    /**\n     * Siblings from same parent\n     */\n\n  }, {\n    key: \"siblings\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return [this];\n      }\n\n      return parent.children;\n    }\n    /**\n     * Get index of parent children\n     */\n\n  }, {\n    key: \"childIndex\",\n    get: function get() {\n      var siblings = this.siblings;\n      return siblings.indexOf(this);\n    }\n    /**\n     * Next sibling node\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex + 1] || undefined;\n    }\n    /**\n     * Previous sibling node\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex - 1] || undefined;\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      var list = [];\n      var node = this;\n\n      while (node) {\n        list.unshift(node);\n        node = node.parent;\n      }\n\n      return list;\n    }\n    /**\n     * Get the first child of current node\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.first(this.children);\n    }\n    /**\n     * Get the last child of current node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.last(this.children);\n    }\n  }, {\n    key: \"isOnlyChild\",\n    get: function get() {\n      if (!this.parent) {\n        return false;\n      }\n\n      return this.parent.children.length === 1;\n    }\n  }]);\n  return Node;\n}();\n\n(0, _defineProperty2.default)(Node, \"Types\", NodeType);\nvar _default = Node;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextLine.default;\n  }\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextLine = _interopRequireDefault(require(\"./TextLine\"));\n\nvar _constants = require(\"./constants\"); // improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\n\n\nvar NOT_FOUND = -1;\nvar LINE_BREAKS = /\\r?\\n/g;\n/**\n * Stream like text string\n * @typicalname stream\n */\n\nvar TextStream =\n/*#__PURE__*/\nfunction () {\n  /** Current cursor position */\n\n  /** Original text */\n\n  /** Tab size */\n\n  /** Text lines */\n\n  /** Start position of each line */\n\n  /** Markers */\n\n  /** Cursor stack positions */\n\n  /** Last matched string of methods like eat() match() */\n  function TextStream(text) {\n    var tabSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    (0, _classCallCheck2.default)(this, TextStream);\n    (0, _defineProperty2.default)(this, \"pos\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"tabSize\", void 0);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"lineOffsetIndexes\", []);\n    (0, _defineProperty2.default)(this, \"markers\", void 0);\n    (0, _defineProperty2.default)(this, \"cursorStack\", void 0);\n    (0, _defineProperty2.default)(this, \"lastMatch\", '');\n    this.pos = 0;\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n\n    this.text = text;\n    /**\n     * @description Tab size\n     */\n\n    this.tabSize = tabSize;\n    /**\n     * @description Lines, separated by line breaks\n     */\n\n    this.lines = [];\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n\n    this.markers = [];\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n\n    this.cursorStack = [];\n    this.init();\n  }\n  /**\n   * Prepare line indexes\n   */\n\n\n  (0, _createClass2.default)(TextStream, [{\n    key: \"init\",\n    value: function init() {\n      var lines = [];\n      var matched;\n      var offset = 0;\n      var ln = 1;\n      LINE_BREAKS.lastIndex = 0;\n\n      do {\n        matched = LINE_BREAKS.exec(this.text);\n\n        if (matched) {\n          var length = matched.index - offset;\n\n          var _text = this.text.substr(offset, length);\n\n          lines.push(new _TextLine.default(lines, _text, ln, offset));\n          offset += length + matched[0].length;\n        } else {\n          var _length = this.text.length - offset; // process last line without line break symbol\n\n\n          if (_length > 0) {\n            var _text2 = this.text.substr(offset);\n\n            lines.push(new _TextLine.default(lines, _text2, ln, offset));\n          }\n        }\n\n        ln++;\n      } while (matched);\n\n      this.lines = lines;\n      this.lineOffsetIndexes = _.map(lines, 'offset');\n    }\n    /**\n     * Get line and column position of the cursor\n     * @param pos Cursor position of the text\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      var lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n      var line = this.lines[lineIndex];\n\n      if (!line) {\n        throw new Error('cursor position is invalid');\n      }\n\n      var ln = line.ln,\n          offset = line.offset;\n      var col = pos - offset + 1;\n      return {\n        ln: ln,\n        col: col,\n        pos: pos,\n        line: line\n      };\n    }\n    /**\n     * Check if cursor is at the start of a line\n     * @param [trimSpaces] Whether to trim starting spaces\n     */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition = this.getPosition(),\n          col = _this$getPosition.col,\n          line = _this$getPosition.line;\n\n      if (col - 1 === 0) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimStart = _.trimStart(line.text),\n          length = _$trimStart.length;\n\n      return col - 1 <= line.length - length;\n    }\n    /**\n     * Check if cursor is at the end of a line\n     * @param [trimSpaces] Whether to trim ending spaces\n     */\n\n  }, {\n    key: \"eol\",\n    value: function eol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition2 = this.getPosition(),\n          col = _this$getPosition2.col,\n          line = _this$getPosition2.line;\n\n      if (col - 1 === line.length) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimEnd = _.trimEnd(line.text),\n          length = _$trimEnd.length;\n\n      return col - 1 >= length;\n    }\n    /**\n     * Check if cursor is at the end of whole text\n     * @param {number} [pos] \n     */\n\n  }, {\n    key: \"eof\",\n    value: function eof(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      return pos >= this.text.length;\n    }\n    /**\n     * Get one next char, but keep the cursor position (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.text.charAt(this.pos);\n    }\n    /**\n     * Get one next char, and move cursor forward (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.text.length) {\n        return this.text.charAt(this.pos++);\n      }\n\n      return '';\n    }\n    /**\n     * Consumes one char if the next char fitting the pattern\n     * @param pattern \n     * @returns The char been eaten\n     */\n\n  }, {\n    key: \"eat\",\n    value: function eat(pattern) {\n      var ch = this.text.charAt(this.pos) || '';\n      var ok;\n\n      if (_.isUndefined(ch)) {\n        ok = false;\n      } else if (_.isString(pattern)) {\n        ok = ch === pattern;\n      } else if (_.isRegExp(pattern)) {\n        pattern.lastIndex = 0;\n        ok = pattern.test(ch);\n      } else if (_.isFunction(pattern)) {\n        ok = pattern(ch);\n      }\n\n      if (ok) {\n        this.lastMatch = ch;\n        ++this.pos;\n        return ch;\n      }\n\n      return '';\n    }\n    /**\n     * Consumes chars while fitting the pattern\n     * @param match \n     * @returns Eaten characters\n     */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(pattern) {\n      var start = this.pos;\n      var chr;\n      var string = '';\n\n      do {\n        chr = this.eat(pattern);\n\n        if (chr) {\n          string += chr;\n        }\n      } while (chr && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes chars until the first char not fitting the pattern\n     * @param pattern char or pattern\n     * @returns eaten characters\n     */\n\n  }, {\n    key: \"eatUntil\",\n    value: function eatUntil(pattern) {\n      var start = this.pos;\n      var ch;\n      var string = '';\n\n      do {\n        ch = this.eat(pattern);\n\n        if (!ch) {\n          string += this.peek();\n          this.pos++;\n        } else {\n          this.pos--;\n        }\n      } while (!ch && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes spaces\n     * @returns {boolean} If any space has been consumed\n     */\n\n  }, {\n    key: \"eatSpaces\",\n    value: function eatSpaces() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n        this.pos++;\n      }\n\n      return this.pos > start;\n    }\n    /**\n     * Find position of matched text to the pattern\n     * @param pattern \n     * @param options\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var caseInsensitive = options.caseInsensitive;\n      var index = NOT_FOUND;\n      var length = 0;\n      var matched = '';\n\n      if (typeof pattern === 'string') {\n        if (caseInsensitive) {\n          pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n        } else {\n          index = this.text.indexOf(pattern, this.pos);\n\n          if (index !== NOT_FOUND) {\n            matched = pattern;\n          }\n        }\n      }\n\n      if (pattern instanceof RegExp) {\n        pattern.lastIndex = this.pos;\n        var result = pattern.exec(this.text);\n\n        if (result) {\n          index = result.index;\n          matched = result[0];\n        } else {\n          index = NOT_FOUND;\n        }\n      }\n\n      var _matched = matched;\n      length = _matched.length;\n      return {\n        index: index,\n        length: length,\n        matched: matched\n      };\n    }\n    /**\n     * Read n chars after current cursor\n     * @param [n] Number of chars to read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var left = this.text.length - this.pos;\n\n      if (left <= 0) {\n        return '';\n      } else if (left < n) {\n        n = left;\n      }\n\n      var result = this.text.substr(this.pos, n);\n      this.pos += n;\n      return result;\n    }\n    /**\n     * Read to text or pattern\n     * @param pattern \n     * @param [options]\n     * @returns Sub-text after current cursor and before (or contains) matched text\n     */\n\n  }, {\n    key: \"readTo\",\n    value: function readTo(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$toEOL = options.toEOL,\n          toEOL = _options$toEOL === void 0 ? false : _options$toEOL,\n          _options$toEOF = options.toEOF,\n          toEOF = _options$toEOF === void 0 ? false : _options$toEOF,\n          _options$consume = options.consume,\n          consume = _options$consume === void 0 ? false : _options$consume,\n          _options$skipMatched = options.skipMatched,\n          skipMatched = _options$skipMatched === void 0 ? false : _options$skipMatched;\n      var start = this.pos;\n\n      var _this$search = this.search(pattern),\n          index = _this$search.index,\n          length = _this$search.length;\n\n      var match = '';\n      var end = -1;\n\n      if (toEOL) {\n        var _this$getPosition3 = this.getPosition(),\n            _line = _this$getPosition3.line;\n\n        end = _line.offset + _line.length;\n      } else if (toEOF) {\n        end = this.text.length;\n      }\n\n      if (index !== NOT_FOUND) {\n        if (toEOL || toEOF) {\n          if (index < end) {\n            end = index;\n          } else {\n            length = 0;\n          }\n        } else {\n          end = index;\n        }\n      }\n\n      if (end !== -1) {\n        this.pos = end;\n\n        if (consume) {\n          end += length;\n          this.pos = end;\n        } else if (skipMatched) {\n          this.pos += length;\n        }\n\n        match = this.text.substring(start, end);\n      }\n\n      this.lastMatch = match;\n      return match;\n    }\n    /**\n     * Read to pattern (contains the matched text)\n     * @param {} pattern Text to find or pattern\n     * @param {object} options Match options\n     * @returns {string} Sub-text after current cursor and until the end of matched text\n     */\n\n  }, {\n    key: \"readOver\",\n    value: function readOver(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        consume: true\n      }));\n    }\n    /**\n     * Read one line\n     * @returns {string} Text containing one line (not including line break)\n     */\n\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var _this$getPosition4 = this.getPosition(),\n          line = _this$getPosition4.line;\n\n      var nextLine = line.next();\n\n      if (this.eof()) {\n        return '';\n      }\n\n      if (nextLine) {\n        this.pos = nextLine.offset;\n        return line.text;\n      } else {\n        var length = line.offset + line.length - this.pos;\n        return this.read(length);\n      }\n    }\n    /**\n     * Move cursor to end of text\n     */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.text.length;\n    }\n    /**\n     * Skip to the beginning of matched text\n     * @param pattern\n     * @param options\n     */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, options);\n      return start !== this.pos;\n    }\n    /**\n     * Skip to the end of matched text\n     * @param pattern\n     */\n\n  }, {\n    key: \"skipOver\",\n    value: function skipOver(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        skipMatched: true\n      }));\n      return start !== this.pos;\n    }\n    /**\n     * Move cursor back\n     * @param n Steps\n     */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.pos -= n;\n    }\n    /**\n     * Check if rest text begins with pattern\n     * @param pattern \n     * @param [options] \n     */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$consume2 = options.consume,\n          consume = _options$consume2 === void 0 ? true : _options$consume2,\n          caseInsensitive = options.caseInsensitive;\n\n      var _this$search2 = this.search(pattern, {\n        caseInsensitive: caseInsensitive\n      }),\n          index = _this$search2.index,\n          length = _this$search2.length,\n          matched = _this$search2.matched;\n\n      if (index !== this.pos) {\n        return '';\n      }\n\n      if (consume) {\n        this.pos += length;\n      }\n\n      this.lastMatch = matched;\n      return matched;\n    }\n    /**\n     * Reset the marker stack\n     */\n\n  }, {\n    key: \"resetMarker\",\n    value: function resetMarker() {\n      this.markers = [];\n    }\n    /**\n     * Add a marker to stack\n     * @param data\n     * @param start\n     */\n\n  }, {\n    key: \"pushMarker\",\n    value: function pushMarker(data, start) {\n      if (_.isUndefined(start)) {\n        start = this.pos;\n      }\n\n      this.markers.push({\n        data: data,\n        start: start\n      });\n    }\n    /**\n     * Set data for current marker\n     * @param data\n     */\n\n  }, {\n    key: \"setMarkerData\",\n    value: function setMarkerData(data) {\n      var marker = _.last(this.markers);\n\n      if (!marker) return;\n\n      _.extend(marker.data, data);\n    }\n    /**\n     * Get data of current markder\n     */\n\n  }, {\n    key: \"getMarkerData\",\n    value: function getMarkerData() {\n      var marker = _.last(this.markers);\n\n      if (!marker) return {};\n      return marker.data;\n    }\n    /**\n     * Return a combined structure of text and it's position according to the previously set start\n     * marker\n     * @param [data] Additional data\n     * @param [end] End marker, if not set, previous set value will be used\n     */\n\n  }, {\n    key: \"popMarker\",\n    value: function popMarker() {\n      var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!_.isPlainObject(_data)) {\n        throw new TypeError('invalid data parameter');\n      }\n\n      if (_.isUndefined(end)) {\n        end = this.pos;\n      }\n\n      var marker = this.markers.pop();\n\n      if (!marker) {\n        return undefined;\n      }\n\n      var data = marker.data,\n          start = marker.start;\n      return {\n        text: this.text.substring(marker.start || 0, end),\n        position: {\n          start: start,\n          end: end\n        },\n        data: (0, _objectSpread2.default)({}, data, _data)\n      };\n    }\n  }, {\n    key: \"findLine\",\n    value: function findLine(text) {\n      return _.find(this.lines, function (line) {\n        return _.trim(line.text) === text;\n      });\n    }\n    /**\n     * Push current cursor to cursor stack, if new position provided, set current cursor to it\n     * @param [pos] \n     */\n\n  }, {\n    key: \"pushCursor\",\n    value: function pushCursor(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      this.cursorStack.push(this.pos);\n      this.pos = pos;\n    }\n    /**\n     * Pop last from cursor stack and set it to current cursor\n     */\n\n  }, {\n    key: \"popCursor\",\n    value: function popCursor() {\n      if (this.cursorStack.length === 0) {\n        throw new Error('out of cursor stack!');\n      }\n\n      this.pos = this.cursorStack.pop();\n      return this.pos;\n    }\n    /**\n     * Debug a single line\n     * @param line \n     * @param numWidth \n     * @param col \n     */\n\n  }, {\n    key: \"debugLine\",\n    value: function debugLine(line, numWidth, col) {\n      var ln = line.ln,\n          text = line.text;\n\n      if (_.isUndefined(numWidth)) {\n        numWidth = (ln + '').length;\n      }\n\n      if (col) {\n        text = text.substring(0, col - 1) + _chalk.default.bgBlue(text.charAt(col - 1)) + text.substring(col);\n      }\n\n      console.log(\"\".concat(_chalk.default.blueBright(\"\".concat(col ? '>' : ' ', \" \").concat(_.padStart(ln + '', numWidth), \" |\")), \" \").concat(text));\n    }\n    /**\n     * Debug cursor column position\n     * @param text Text of the line\n     * @param col Cursor position\n     * @param numWidth fixed line number width\n     */\n\n  }, {\n    key: \"debugCursor\",\n    value: function debugCursor(text, col, numWidth) {\n      var pos = text.substr(0, col - 1).replace(_constants.P_FULL_WIDTH_CHARACTER, 'XX').length;\n      console.log(_chalk.default.blueBright(\"  \".concat(_.repeat(' ', numWidth), \" | \").concat(_.repeat(' ', pos), \"^ \").concat(col)));\n    }\n    /**\n     * Debug current position state, with previous and following lines set by range\n     * @param range \n     */\n\n  }, {\n    key: \"debugState\",\n    value: function debugState() {\n      var _this = this;\n\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$getPosition5 = this.getPosition(),\n          ln = _this$getPosition5.ln,\n          col = _this$getPosition5.col;\n\n      var lineIndex = ln - 1;\n\n      var lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n\n      var numWidth = _.max(lines.map(function (l) {\n        return (l.ln + '').length;\n      }));\n\n      lines.forEach(function (line) {\n        var isCurrent = line.ln === ln;\n\n        _this.debugLine(line, numWidth, isCurrent ? col : 0);\n\n        if (isCurrent) {\n          _this.debugCursor(line.text, col, numWidth);\n        }\n      });\n      console.log();\n    }\n  }]);\n  return TextStream;\n}();\n\nvar _default = TextStream;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n\n  function ParseError(message, text, from, to) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"message\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"text\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"from\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"to\", void 0);\n    _this.message = message;\n    _this.text = text;\n    _this.from = from;\n    _this.to = to;\n    return _this;\n  }\n\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.default = ParseError;","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from '../SourceEditor/SourceEditor';\nimport VisualEditor from '../VisualEditor/VisualEditor';\nimport '@blueprintjs/core/lib/css/blueprint.css';\nimport 'normalize.css/normalize.css';\nimport './Editor.scss';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from '../TreeView/TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  defaultSource: string;\n  className: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  source: string\n  root: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source);\n    (global as any).node = node;\n    console.info('Root node exported as global variable \"node\"', node);\n  } catch(err) {\n    if (err instanceof zaml.ParseError) {\n      const message = `\n        [ParseError]{ERROR.TYPE}: {#MESSAGE ${err.message}}\n\n        #SOURCE\n        content\n\n        from {#POS.START ${err.from.ln}:${err.from.col}} to {#POS.END ${err.to.ln}:${err.to.col}}\n      `;\n      node = zaml.parse(message);\n      const sourceBlock = node.querySelector('#SOURCE');\n      const { text } = err.from.line;\n      if (!sourceBlock) return node;\n      const sourceText = sourceBlock.findOneBy({type: NodeType.TEXT});\n      if (!sourceText) return node;\n      sourceText.content = `${text} `;\n      sourceText.createEntitiesFromText([{\n        type: 'ERROR',\n        start: err.from.col - 1,\n        end: err.to.col - 1,\n      }]);\n    } else {\n      node = zaml.parse(`Error: [${err.message}]{MESSAGE}`);\n      console.error(err);\n    }\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    defaultSource: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    defaultSource: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  public preventSourceChange: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      source: props.defaultSource,\n      root: parse(props.defaultSource),\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n    this.preventSourceChange = false;\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n  }\n\n  componentWillUpdate(nextProps: Props, nextState: State) {\n    if (nextState.selectedNode !== this.state.selectedNode) {\n      console.log('selected node:', nextState.selectedNode);\n    }\n    if (nextState.root !== this.state.root) {\n      console.log('new node:', nextState.root);\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  handleSourceChange(source: string) {\n    if (this.preventSourceChange) return;\n    this.setState({\n      root: parse(source),\n      selectedNode: undefined,\n    });\n  }\n\n  handleNodeChange(root?: zaml.Node, selected?: zaml.Node) {\n    if (!root) return;\n    this.preventSourceChange = true;\n    this.setState({\n      source: root.toSource({ simple: true }),\n      selectedNode: selected,\n    }, () => {\n      this.preventSourceChange = false;\n    });\n  }\n\n  render() {\n    const { source } = this.state;\n    const { root, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={source}\n                height={sourcePaneHeight - 40}\n                onChange={(value: string) => this.handleSourceChange(value)}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  root={root}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onChange={(r?: zaml.Node, n?: zaml.Node) => this.handleNodeChange(r, n)}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  root={root}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                  onChange={n => this.handleNodeChange(root, n)}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar _ref =\n/*#__PURE__*/\nReact.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref4 =\n/*#__PURE__*/\nReact.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref5 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref6 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref7 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref8 =\n/*#__PURE__*/\nReact.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgComponent = function SvgComponent(props) {\n  return React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\"\n  }, props), _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n};\n\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { SvgComponent as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.scss';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      const isEntity = node.type === NodeType.ENTITY;\n      const isTag = node.type === NodeType.TAG;\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      let name = (isTag || isEntity) ? node.name : node.type;\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            >▾</span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {node.openDescriptorStart}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {node.openDescriptorEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {node.closingDescriptor}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\nimport { NodePart } from './TreeNode';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {node.descriptor}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreePropEditor.scss';\nimport TabView from '../Common/TabView';\nimport { KeyValueMap } from '@zaml/parser/typings/Node';\n\ninterface Props {\n  node?: zaml.Node;\n  onChange: (node: zaml.Node) => void;\n}\n\ninterface State {\n  selectedTab?: string;\n  editingIndex: number;\n  inlineError: string;\n}\n\nenum Tab {\n  Labels = 'Labels',\n  Attributes = 'Attributes',\n  Metadata = 'Metadata',\n}\n\nconst tabs = _.values(Tab);\nconst defaultTab = tabs[0];\nconst defaultEditingIndex = -1;\n\nexport default class TreePropEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.instanceOf(zaml.Node),\n  };\n\n  static defaultProps: Props = {\n    onChange: () => {},\n  };\n\n  state = {\n    selectedTab: defaultTab,\n    editingIndex: defaultEditingIndex,\n    inlineError: '',\n  };\n\n  editingElement: HTMLInputElement | null = null;\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (nextProps.node !== this.props.node) {\n      this.setState({\n        selectedTab: defaultTab,\n        editingIndex: defaultEditingIndex,\n      });\n    }\n  }\n\n  renderValue(value: any) {\n    if (value instanceof zaml.Node) {\n      return value.toSource();\n    } else {\n      return JSON.stringify(value);\n    }\n  }\n\n  renderEmptyTip() {\n    return (\n      <div className=\"select-tip\">Please select a node</div>\n    )\n  }\n\n  renderTabContent() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    if (!node) {\n      return this.renderEmptyTip();\n    }\n    switch(selectedTab) {\n      case Tab.Labels:\n        return this.renderLabelEditor(node);\n      case Tab.Attributes:\n        return this.renderAttributeEditor(node, node.attributes);\n      case Tab.Metadata:\n        return this.renderAttributeEditor(node, node.metadata);\n    }\n  }\n\n  focusEditingElement() {\n    if (this.editingElement) {\n      this.editingElement.focus();\n      this.editingElement.select();\n    }\n  }\n\n  handleLabelEdit(index: number) {\n    this.setState({ editingIndex: index }, () => {\n      this.focusEditingElement();\n    });\n  }\n\n  handleLabelUpdate(label: string) {\n    const { node, onChange } = this.props;\n    const { editingIndex } = this.state;\n    if (!node) return;\n    const originalLabel = node.labels[editingIndex] || '';\n    if (label !== originalLabel) {\n      try {\n        zaml.parse(`{INLINE #${label}}TESTING{/INLINE}`);\n      } catch (e) {\n        this.setState({ inlineError: 'Invalid label'});\n        return;\n      }\n      if (editingIndex === node.labels.length) {\n        node.addLabel(label);\n      } else {\n        if (label === '' || node.labels.indexOf(label) >= 0) {\n          node.removeLabel(originalLabel);\n        } else {\n          node.labels[editingIndex] = label;\n        }\n      }\n    }\n    this.cancelLabelEditing();\n    onChange(node);\n  }\n\n  cancelLabelEditing() {\n    this.setState({\n      editingIndex: defaultEditingIndex,\n      inlineError: '',\n    });\n  }\n  \n  renderLabelEditor(node: zaml.Node) {\n    const { editingIndex, inlineError } = this.state;\n    const labels = [...node.labels, ''];\n    return (\n      <div className=\"label-editor\">\n        <table>\n          <tbody>\n          {labels.map((label, i) => (\n            <tr\n              key={label}\n              className={classNames({ error: i === editingIndex && inlineError })}\n            >\n              <td className=\"marker\">{label || i === editingIndex ? '#': ''}</td>\n              {i === editingIndex ?\n                <td>\n                  <input\n                    ref={ref => this.editingElement = ref}\n                    defaultValue={label}\n                    onBlur={(event: React.FocusEvent<HTMLInputElement>) => {\n                      this.handleLabelUpdate(event.currentTarget.value);\n                    }}\n                    onKeyDown={(event: React.KeyboardEvent<HTMLInputElement>) => {\n                      if (event.key === 'Enter') {\n                        this.handleLabelUpdate(event.currentTarget.value);\n                      } else if (event.key === 'Escape') {\n                        this.cancelLabelEditing();\n                      }\n                    }}\n                  />\n                </td>\n              :\n                <td\n                  className=\"editable\"\n                  onClick={() => this.handleLabelEdit(i)}\n                >\n                  {label}\n                </td>\n              }\n            </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderAttributeEditor(node: zaml.Node, props: KeyValueMap) {\n    const keys = Object.keys(props);\n    return (\n      <div className=\"attribute-editor\">\n        <table>\n          <tbody>\n            {keys.map(key => (\n              <tr key={key}>\n                <th>{key}</th>\n                <td>{this.renderValue(props[key])}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  render() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    return (\n      <div className=\"zaml-prop-editor\">\n        <TabView\n          tabs={tabs}\n          selectedTab={selectedTab}\n          onTabChange={(tab: string) => this.setState({ selectedTab: tab })}\n        >\n          {this.renderTabContent()}\n        </TabView>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport './TabView.scss';\n\ninterface Props {\n  tabs: string[];\n  selectedTab: string;\n  onTabChange: (tab: string) => void;\n}\n\nexport default class TabView extends React.Component<Props> {\n\n  render() {\n    const { tabs, selectedTab, onTabChange, children } = this.props\n    return (\n      <div className=\"tab-view\">\n        <ul className=\"tabs\">\n          {tabs.map(tab => (\n            <li\n              key={tab}\n              className={classNames('tab', { selected: tab === selectedTab })}\n              onClick={() => onTabChange(tab)}\n            >\n              <span className=\"label\">{tab}</span>\n            </li>\n          ))}\n        </ul>\n        <div className=\"content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePath from './TreePath';\nimport TreeToolbar from './TreeToolbar';\nimport TreePropEditor from './TreePropEditor';\nimport './TreeView.scss';\n\ninterface Props {\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart;\n  expandedNodes: string[];\n}\n\nconst nil = () => {};\n\nexport default class TreeView extends React.Component<Props, State> {\n  static propTypes = {\n    node: PropTypes.shape({}),\n  };\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n    onChange: nil,\n  };\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds)\n      });\n    }\n  }\n\n  render() {\n    const {\n      root,\n      selectedNode,\n      onSelect,\n      onHover,\n      onChange,\n    } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <SplitPane split=\"horizontal\" defaultSize=\"60%\" minSize={200}>\n          <div className=\"tree-container\">\n            <TreeToolbar />\n            <div className=\"tree\">\n              <TreeNode\n                node={root}\n                selectedNode={selectedNode}\n                selectedPart={selectedPart}\n                expandedNodes={expandedNodes}\n                onSelect={onSelect}\n                onSelectPart={p => this.setState({ selectedPart: p })}\n                onMouseEnter={onHover}\n                onMouseOut={() => onHover()}\n                onExpansionChange={(n: zaml.Node, expanded: boolean) =>\n                  this.handleExpansionChange(n, expanded)\n                }\n              />\n            </div>\n            <TreePath selectedNode={selectedNode} onSelect={onSelect} />\n          </div>\n          <TreePropEditor node={selectedNode} onChange={onChange} />\n        </SplitPane>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:：=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[\\{]/, indent: true},\n    {regex: /[\\}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport './SourceEditor.scss';\nimport './codemirror-mode';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.editor) {\n      if (nextProps.height !== this.props.height && this.editor) {\n        this.editor.setSize(null, nextProps.height);\n      }\n      if (nextProps.value !== this.props.value) {\n        this.editor.setValue(nextProps.value);\n      }\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.scss';\n\nconst { NodeType } = zaml;\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            node-id={node.id}\n            href={node.attributes.url}\n          >\n            <VisualNode\n              node-id={node.children[0].id}\n              {...this.props}\n              node={node.children[0]}\n            />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      'node-id': node.id,\n    }, children);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { ContextMenuTarget, Menu, MenuItem, MenuDivider } from \"@blueprintjs/core\"\nimport VisualNode from './VisualNode';\nimport './VisualEditor.scss';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  commonEntityNames?: string[];\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node, selected?: zaml.Node) => void;\n}\n\ninterface State {\n}\n\n@ContextMenuTarget\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    commonEntityNames: PropTypes.arrayOf(PropTypes.string),\n    root: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    commonEntityNames: ['PER', 'ORG', 'LOC', 'DATE'],\n    onSelect: () => {},\n    onChange: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n  }\n\n  handleDoubleClick(event: React.MouseEvent) {\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const domNode = range.startContainer;\n    const text = domNode.textContent;\n    if (!text) return;\n    event.preventDefault();\n    event.stopPropagation();\n    const punctuationPattern = /[!?:;。！？：；]/g;\n    let startPos = 0;\n    let endPos = text.length;\n    let pos = 0;\n    while (punctuationPattern.exec(text)) {\n      startPos = pos;\n      pos = punctuationPattern.lastIndex;\n      punctuationPattern.lastIndex++;\n      if (pos > range.startOffset) {\n        endPos = pos;\n        break;\n      }\n    }\n    range.setStart(domNode, startPos);\n    range.setEnd(domNode, endPos);\n  }\n\n  handleCreateBlock() {\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const commonNode = this.getNodeByElement(range.commonAncestorContainer as HTMLElement);\n    let startNode = this.getNodeByElement(range.startContainer as HTMLElement);\n    let endNode = this.getNodeByElement(range.endContainer as HTMLElement);\n    if (!commonNode || !startNode || !endNode) {\n      return;\n    }\n    const block = zaml.Node.createBlockByRange({\n      startNode,\n      startOffset: range.startOffset,\n      endNode,\n      endOffset: range.endOffset,\n    });\n    selection.removeAllRanges();\n    onChange(root, block);\n  }\n\n  handleRemoveBlock(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const parent = node.flatten();\n    onChange(root, parent);\n  }\n\n  handleCreateEntity(target: zaml.Node, name: string | null) {\n    if (!name) return;\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.anchorNode !== selection.focusNode) {\n      alert('Entity is only allowed in pure text!');\n      return;\n    }\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const entityNodes = target.createEntities([{\n      type: name,\n      start: range.startOffset,\n      end: range.endOffset,\n    }]);\n    onChange(root, entityNodes[0]);\n  }\n\n  handleRemoveEntity(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const textNode = node.removeEntity();\n    onChange(root, textNode);\n  }\n\n  handleInspect(node: zaml.Node) {\n    const { onSelect } = this.props;\n    onSelect(node);\n  }\n\n  handleSplitSentences(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    node.splitText('。！？.!?', 'SENTENCE');\n    onChange(root);\n  }\n\n  getNodeByElement(element: HTMLElement) {\n    const { root: root } = this.props;\n    if (!root) return undefined;\n    if (element.nodeType === element.TEXT_NODE || element.classList.contains('children')) {\n      if (!element.parentElement) {\n        return undefined;\n      }\n      element = element.parentElement;\n    }\n    const id = element.getAttribute('node-id');\n    if (!id) return undefined;\n    return root.getNodeById(id);\n  }\n\n  render() {\n    const { root: node, selectedNode } = this.props;\n    return (\n      <div\n        className=\"zaml-visual-editor\"\n        onDoubleClick={(event: React.MouseEvent) => this.handleDoubleClick(event)}\n      >\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n        />\n      </div>\n    )\n  }\n\n  renderContextMenu(e: React.MouseEvent<HTMLElement>) {\n    const { commonEntityNames } = this.props;\n    const target = this.getNodeByElement(e.target as HTMLElement);\n    let node = target;\n    if (!target) return;\n    if (target.type === NodeType.TEXT) {\n      node = target.parent;\n    }\n    if (!node) return;\n    const wrapperNode = node;\n    return (\n      <Menu id=\"menu\">\n        <MenuItem disabled text={node.descriptor} />\n        <MenuDivider />\n        <MenuItem\n          text=\"Create Block\"\n          onClick={() => this.handleCreateBlock()}\n        />\n        {node.isWrappingTag &&\n          <MenuItem\n            text=\"Remove Block\"\n            onClick={() => this.handleRemoveBlock(node)}\n          />\n        }\n        {node.isBlock &&\n          <MenuItem\n            text=\"Split Sentences\"\n            onClick={() => this.handleSplitSentences(node)}\n          />\n        }\n        {target.type === NodeType.TEXT && target.parent && target.parent.type !== NodeType.ENTITY &&\n          <MenuItem text=\"Create Entity\">\n            {commonEntityNames && commonEntityNames.map(name => (\n              <MenuItem\n                key={name}\n                text={name}\n                onClick={() => this.handleCreateEntity(target, name)}\n              />\n            ))}\n            <MenuItem\n              text=\"other...\"\n              onClick={() => this.handleCreateEntity(target, prompt('Please input entity type', 'PER'))}\n            />\n          </MenuItem>\n        }\n        {node.type === NodeType.ENTITY &&\n          <MenuItem\n            text=\"Remove Entity\"\n            onClick={() => this.handleRemoveEntity(node)}\n          />\n        }\n        <MenuDivider />\n        <MenuItem\n          text=\"Inspect\"\n          onClick={() => this.handleInspect(wrapperNode)}\n        />\n      </Menu>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextStream = _interopRequireDefault(require(\"./TextStream\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _constants = require(\"./constants\");\n\nvar State;\n\n(function (State) {\n  State[State[\"METADATA\"] = 0] = \"METADATA\";\n  State[State[\"NORMAL\"] = 1] = \"NORMAL\";\n  State[State[\"SINGLE_COMMENT\"] = 2] = \"SINGLE_COMMENT\";\n  State[State[\"MULTIPLE_COMMENT\"] = 3] = \"MULTIPLE_COMMENT\";\n  State[State[\"START\"] = 4] = \"START\";\n  State[State[\"TAG_START\"] = 5] = \"TAG_START\";\n  State[State[\"TAG_NAME\"] = 6] = \"TAG_NAME\";\n  State[State[\"ATTRIBUTE_LIST\"] = 7] = \"ATTRIBUTE_LIST\";\n  State[State[\"ATTRIBUTE_NAME\"] = 8] = \"ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_ASSIGN\"] = 9] = \"ATTRIBUTE_ASSIGN\";\n  State[State[\"ATTRIBUTE_VALUE\"] = 10] = \"ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_FINISH\"] = 11] = \"ATTRIBUTE_FINISH\";\n  State[State[\"TAG_END\"] = 12] = \"TAG_END\";\n  State[State[\"LABEL_START\"] = 13] = \"LABEL_START\";\n  State[State[\"ENTITY_START\"] = 14] = \"ENTITY_START\";\n  State[State[\"ENTITY_BODY\"] = 15] = \"ENTITY_BODY\";\n  State[State[\"ENTITY_END\"] = 16] = \"ENTITY_END\";\n  State[State[\"END\"] = 17] = \"END\";\n  State[State[\"FINISH\"] = 18] = \"FINISH\";\n})(State || (State = {}));\n\n;\nvar stateNames = ['METADATA', 'NORMAL', 'SINGLE_COMMENT', 'MULTIPLE_COMMENT', 'START', 'TAG_START', 'TAG_NAME', 'ATTRIBUTE_LIST', 'ATTRIBUTE_NAME', 'ATTRIBUTE_ASSIGN', 'ATTRIBUTE_VALUE', 'ATTRIBUTE_FINISH', 'TAG_END', 'LABEL_START', 'ENTITY_START', 'ENTITY_BODY', 'ENTITY_END', 'END', 'FINISH'];\n\nvar getStateName = function getStateName(state) {\n  return stateNames[state];\n};\n\nvar countLineBreaks = function countLineBreaks(text) {\n  var result = text.match(_constants.P_LINE_BREAK);\n  return result ? result.length : 0;\n};\n\n;\n/**\n * Tokenizer class\n * @class\n */\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Tokenizer, null, [{\n    key: \"from\",\n    value: function from(text, options) {\n      return new Tokenizer(text, options);\n    }\n  }]);\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n\n  function Tokenizer(text, options) {\n    (0, _classCallCheck2.default)(this, Tokenizer);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"stream\", void 0);\n    (0, _defineProperty2.default)(this, \"options\", void 0);\n    (0, _defineProperty2.default)(this, \"parsed\", void 0);\n    this.text = text;\n    this.stream = new _TextStream.default(text);\n    var defaultOptions = {\n      verbose: process && process.env.DEBUG === 'verbose'\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  (0, _createClass2.default)(Tokenizer, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n    /**\n     * Process a text and parse to AST\n     * @returns Root node of parsed AST\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this = this;\n\n      var text = this.text,\n          stream = this.stream;\n      var timeStart = Date.now();\n      var state = State.METADATA;\n      var start = 0;\n      var lastState = 0;\n      var lastPos = -1;\n      var states = {\n        unwrapped: false,\n        inline: false,\n        embedded: false,\n        isClosing: false,\n        key: undefined,\n        value: undefined\n      };\n\n      var root = _Node.default.create(_Node.NodeType.ROOT, undefined, {\n        source: text\n      });\n\n      var nodeStack = [];\n      var node = root;\n\n      var getNodeString = function getNodeString(node) {\n        return \"\".concat(node.type).concat(node.name ? \":\".concat(node.name) : '');\n      };\n\n      var debugStack = function debugStack(lastNode) {\n        if (!_this.options.verbose) {\n          return;\n        }\n\n        var separator = ' > ';\n        var stack = nodeStack.concat([node]);\n        var list = stack.map(function (n, i) {\n          var text = getNodeString(n);\n\n          if (i === stack.length - 1) {\n            text = _chalk.default.cyanBright(text);\n          } else {\n            text = _chalk.default.green(text);\n          }\n\n          return text;\n        });\n        var result = list.join(_chalk.default.redBright(separator));\n\n        if (lastNode) {\n          result += _chalk.default.grey(\"\".concat(separator).concat(getNodeString(lastNode)));\n        }\n\n        return result;\n      };\n\n      var pushNode = function pushNode(n) {\n        if (node.start === -1) {\n          node.start = stream.pos;\n        }\n\n        nodeStack.push(node);\n        node = n;\n\n        _this.debug(\"push: \".concat(debugStack(), \"\\n\"));\n      };\n\n      var popNode = function popNode(error) {\n        var lastNode = node;\n        node.end = stream.pos;\n\n        if (node.start === node.end || node.type === _Node.NodeType.PARAGRAPH && !node.hasChild() && node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node = nodeStack.pop();\n\n        _this.debug(\"pop : \".concat(debugStack(lastNode), \"\\n\"));\n\n        if (!node) {\n          throw createError(error || 'unexpected closing node');\n        }\n      }; // replace wrapping paragraph with current block tag\n\n\n      var levelUpBlock = function levelUpBlock() {\n        if (node.parent && node.parent.type === _Node.NodeType.PARAGRAPH) {\n          var blockNode = node;\n          popNode();\n          node.removeChild(blockNode);\n          popNode();\n          node.appendChild(blockNode);\n          pushNode(blockNode);\n        }\n      };\n\n      var createError = function createError(message) {\n        var from;\n        var to;\n        from = stream.getPosition(lastPos);\n        to = stream.pos === lastPos ? stream.getPosition(lastPos + 1) : stream.getPosition();\n\n        _this.debug(\"error: '\".concat(message, \"' at \").concat(from.ln, \":\").concat(from.col));\n\n        _this.debug('current node:');\n\n        _this.debug(node.toJSON());\n\n        _this.debug('current parsing state:');\n\n        _this.debug(JSON.stringify(root, null, 2));\n\n        return new _ParseError.default(message, text, from, to);\n      };\n\n      while (state !== State.FINISH) {\n        // parse failure watcher\n        if (Date.now() - timeStart >= _constants.PROCESSING_TIMEOUT) {\n          this.debug('parsing timeout!');\n          state = State.FINISH;\n        }\n\n        if (state === lastState && lastPos === stream.pos) {\n          throw new Error('Parser fall into infinite loop!');\n        }\n\n        lastState = state;\n        lastPos = stream.pos;\n        this.debug(_chalk.default.magenta(\"# \".concat(getStateName(state), \", pos = \").concat(stream.pos)));\n\n        if (this.options.verbose) {\n          stream.debugState();\n        }\n\n        switch (state) {\n          case State.METADATA:\n            {\n              stream.eatWhile(_constants.P_WHITE_SPACES_EXT);\n\n              if (stream.match(_constants.T_METADATA_MARKER) || stream.match(_constants.P_ATTRIBUTE_LIST, {\n                consume: false\n              })) {\n                node.states.metadata = true;\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.NORMAL:\n            {\n              if (stream.sol(true) || stream.eol(true)) {\n                stream.eatWhile(_constants.P_WHITE_SPACE);\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK)) {\n                popNode();\n\n                if (node.states.unwrapped) {\n                  popNode();\n                }\n\n                break;\n              }\n\n              start = stream.pos;\n\n              if (node.type !== _Node.NodeType.PARAGRAPH && !node.isInlineBlock && stream.sol(true)) {\n                var child = node.createChild(_Node.NodeType.PARAGRAPH, undefined, {\n                  start: start\n                });\n                pushNode(child);\n              }\n\n              var originalText = stream.readTo(_constants.P_MARKER, {\n                toEOF: true\n              });\n              var _text = originalText;\n\n              if (_text) {\n                if (node.children.length === 0) {\n                  _text = _.trimStart(_text);\n                }\n\n                _text = _text.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, _constants.T_LINE_BREAK);\n                _text = _.trimEnd(_text, _constants.T_LINE_BREAKS);\n\n                if (_text) {\n                  node.appendText(_text, {\n                    start: start,\n                    end: stream.pos\n                  });\n                }\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK, {\n                consume: false\n              })) {\n                state = State.NORMAL;\n              } else {\n                state = State.START;\n              }\n\n              break;\n            }\n\n          case State.START:\n            {\n              start = stream.pos;\n              var ch = stream.eat(_constants.P_MARKER);\n              _constants.P_LABEL_START.lastIndex = 0;\n\n              if (ch === _constants.T_SINGLE_LINE_COMMENT) {\n                var rest = stream.eatWhile(_constants.T_SINGLE_LINE_COMMENT);\n\n                if (rest.length === 0) {\n                  state = State.SINGLE_COMMENT;\n                } else {\n                  state = State.MULTIPLE_COMMENT;\n                }\n              } else if (ch === _constants.T_TAG_START) {\n                state = State.TAG_START;\n              } else if (_constants.P_LABEL_START.test(ch)) {\n                states.unwrapped = true;\n                state = State.TAG_START;\n              } else if (ch === _constants.T_TAG_END) {\n                states.isClosing = true;\n                state = State.TAG_END;\n              } else if (ch === _constants.T_ENTITY_START) {\n                state = State.ENTITY_START;\n              } else if (stream.eof()) {\n                state = State.END;\n              } else {\n                throw createError('empty start');\n              }\n\n              break;\n            }\n\n          case State.SINGLE_COMMENT:\n          case State.MULTIPLE_COMMENT:\n            {\n              start = stream.pos;\n              var content = void 0;\n\n              if (state === State.SINGLE_COMMENT) {\n                content = stream.readTo(_constants.P_LINE_BREAK);\n              } else {\n                content = stream.readTo(_constants.P_MULTIPLE_LINE_COMMENT, {\n                  skipMatched: true\n                });\n              }\n\n              if (content) {\n                if (state === State.MULTIPLE_COMMENT) {\n                  content = content.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n                }\n\n                content = _.trim(content);\n              }\n\n              if (content) {\n                node.createChild(_Node.NodeType.COMMENT, undefined, {\n                  start: start,\n                  end: stream.pos,\n                  content: content\n                });\n              }\n\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.TAG_START:\n            {\n              if (stream.eat(_constants.T_TAG_CLOSING)) {\n                states.isClosing = true;\n                state = State.TAG_NAME;\n              } else if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (node.type !== _Node.NodeType.ENTITY && (states.unwrapped || stream.eat(_constants.P_LABEL_START))) {\n                state = State.LABEL_START;\n              } else {\n                var _child = _Node.default.create(_Node.NodeType.TAG, '', {\n                  start: start\n                });\n\n                if (states.embedded) {\n                  _child.states.embedded = true;\n                  _child.states.metaKey = states.key;\n                  states.embedded = false;\n                } else {\n                  node.appendChild(_child);\n                }\n\n                pushNode(_child);\n                state = State.TAG_NAME;\n              }\n\n              if (state === State.NORMAL || state === State.LABEL_START) {\n                stream.pushCursor(start);\n                var tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n                stream.popCursor();\n\n                if (node.type === _Node.NodeType.PARAGRAPH && tagName === 'BLOCK') {\n                  popNode();\n                }\n\n                var _child2 = node.createChild(_Node.NodeType.TAG, tagName, {\n                  start: start,\n                  states: {\n                    simpleBlock: true,\n                    unwrapped: states.unwrapped\n                  }\n                });\n\n                states.unwrapped = false;\n                pushNode(_child2);\n              }\n\n              break;\n            }\n\n          case State.TAG_NAME:\n            {\n              var name = stream.match(_constants.P_TAG_NAME);\n\n              if (!name) {\n                throw createError('expected tag name');\n              }\n\n              states.inline = name === 'INLINE';\n\n              if (states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  stream.pushCursor(start);\n                  popNode();\n                  stream.popCursor();\n                }\n\n                if (name !== node.name) {\n                  throw createError('unexpected closing tag');\n                }\n\n                var _ch = stream.eat(_constants.T_TAG_END);\n\n                if (!_ch) {\n                  throw createError('invalid closing tag');\n                }\n\n                if (!states.inline && !stream.eol()) {\n                  throw createError('closing block tag must take the whole line');\n                }\n\n                state = State.TAG_END;\n              } else {\n                node.name = name;\n\n                if (node.isWrappingTag) {\n                  stream.pushCursor(node.start || 0);\n\n                  if (node.name === 'BLOCK' && !stream.sol(true)) {\n                    throw createError('unexpected start of block inline');\n                  }\n\n                  stream.popCursor();\n\n                  if (node.isBlock) {\n                    levelUpBlock();\n                  }\n                }\n\n                state = State.ATTRIBUTE_LIST;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_LIST:\n            {\n              var spacePattern = node.states.simpleBlock || node.states.unwrapped ? _constants.P_WHITE_SPACE : _constants.P_WHITE_SPACES_EXT;\n              var spaces = stream.eatWhile(spacePattern);\n              var isParsingMetadata = node.states.metadata;\n\n              if (isParsingMetadata) {\n                var endOfFrontMatter = false;\n\n                if (stream.match(_constants.T_METADATA_MARKER)) {\n                  if (!stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('expected new line after metadata closed');\n                  }\n\n                  endOfFrontMatter = true;\n                }\n\n                var lineBreaks = countLineBreaks(spaces);\n\n                if (lineBreaks > 1) {\n                  endOfFrontMatter = true;\n                }\n\n                if (endOfFrontMatter) {\n                  state = State.NORMAL;\n                  node.states.metadata = false;\n                  break;\n                } // deal with simple block at the beginning\n\n\n                if (node.type === _Node.NodeType.ROOT && !stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                }) && lineBreaks === 1) {\n                  var _child3 = node.createChild(_Node.NodeType.TAG, 'BLOCK', {\n                    labels: node.labels,\n                    states: {\n                      unwrapped: true\n                    },\n                    metadata: node.metadata\n                  });\n\n                  node.clearLabels();\n                  node.clearMetadata();\n                  pushNode(_child3);\n                  state = State.NORMAL;\n                  break;\n                }\n              }\n\n              if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (stream.eat(_constants.T_TAG_END)) {\n                state = State.TAG_END;\n              } else if (stream.match(_constants.P_LABEL_START)) {\n                state = State.LABEL_START;\n              } else {\n                if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n                  if (_.isEmpty(node.attributes) && _constants.P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                    states.key = node.name;\n                    node.name = 'BLOCK';\n                    node.states.simpleBlock = true;\n                    levelUpBlock();\n                    state = State.ATTRIBUTE_ASSIGN;\n                    break;\n                  } else {\n                    throw createError('expecting end of tag \"}\" or attribute list');\n                  }\n                }\n\n                state = State.ATTRIBUTE_NAME;\n\n                if (stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                })) {\n                  state = State.ATTRIBUTE_NAME;\n                } else {\n                  state = State.NORMAL;\n                }\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_NAME:\n            {\n              var _key = stream.match(_constants.P_ATTRIBUTE_NAME);\n\n              if (!_key) {\n                throw createError('expecting attribute name');\n              }\n\n              states.key = _key;\n              state = State.ATTRIBUTE_ASSIGN;\n              break;\n            }\n\n          case State.ATTRIBUTE_ASSIGN:\n            {\n              var _ch2 = stream.peek();\n\n              if (_ch2 === _constants.T_TAG_END) {\n                state = State.ATTRIBUTE_FINISH;\n              } else {\n                _ch2 = stream.eat(_constants.P_ATTRIBUTE_ASSIGN);\n\n                if (!_ch2) {\n                  throw createError('expecting assignment \"=\" or \":\"');\n                }\n\n                if (_constants.P_ASSIGN_YAML.test(_ch2)) {\n                  stream.eatSpaces();\n                }\n\n                state = State.ATTRIBUTE_VALUE;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_VALUE:\n            {\n              var _ch3 = stream.peek();\n\n              var _value = void 0;\n\n              if (_ch3 === _constants.T_TAG_START || _ch3 === _constants.T_ENTITY_START) {\n                states.embedded = true;\n                state = State.START;\n                break;\n              } else if (_ch3 === _constants.T_STRING_START) {\n                _value = stream.match(_constants.P_STRING_LITERAL_QUOTED);\n\n                try {\n                  _value = JSON.parse(_value);\n                } catch (e) {\n                  throw createError('invalid string literal');\n                }\n              } else if (stream.match(_constants.P_DATE_LITERAL)) {\n                _value = stream.lastMatch;\n                _value = new Date(_value);\n              } else if (_constants.P_NUMBER_START.test(_ch3)) {\n                _value = stream.match(_constants.P_NUMBER_LITERAL);\n                _value = parseFloat(_value);\n              } else if (stream.match(_constants.P_BOOLEAN_TRUE)) {\n                _value = true;\n              } else if (stream.match(_constants.P_BOOLEAN_FALSE)) {\n                _value = false;\n              } else {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n\n                if (_.isNull(_value)) {\n                  throw createError('unrecognized attribute value');\n                }\n              }\n\n              if (_.isNull(_value)) {\n                throw createError('invalid attribute value');\n              }\n\n              states.value = _value;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n\n          case State.ATTRIBUTE_FINISH:\n            {\n              var _key2 = states.key,\n                  _value2 = states.value;\n              states.key = undefined;\n              states.value = undefined;\n\n              if (_.isUndefined(_value2)) {\n                _value2 = true;\n              }\n\n              if (node.states.metadata) {\n                node.setMetadata(_key2, _value2);\n              } else {\n                node.setAttribute(_key2, _value2);\n              }\n\n              this.debug(\"# \".concat(node.states.metadata ? 'metadata' : 'attribute', \" \").concat(_key2, \"=\").concat(JSON.stringify(_value2)));\n              this.debug();\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.TAG_END:\n            {\n              var parseMetadata = node.isBlockTag && !states.isClosing;\n              var tagNode = node;\n              states.inline = tagNode.isInlineBlock;\n\n              if (!node.isWrappingTag || states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  popNode();\n                }\n\n                popNode();\n\n                if (node.type === _Node.NodeType.ENTITY) {\n                  // copy tag properties to entity and remove temporary tag node\n                  node.setAttributes(tagNode.attributes);\n                  node.name = tagNode.name;\n                  node.removeChild(tagNode);\n                  state = State.ENTITY_END;\n                  tagNode = node;\n                  popNode();\n                }\n\n                if (tagNode.states.embedded) {\n                  if (node.states.metadata) {\n                    node.setMetadata(tagNode.states.metaKey, tagNode);\n                  } else {\n                    node.setAttribute(tagNode.states.metaKey, tagNode);\n                  }\n                }\n              }\n\n              if (states.isClosing && !states.inline) {\n                stream.skipOver(_constants.P_LINE_BREAK);\n              }\n\n              states.isClosing = false;\n              states.inline = false;\n\n              if (parseMetadata) {\n                state = State.METADATA;\n              } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.LABEL_START:\n            {\n              var label = stream.match(_constants.P_LABEL_NAME);\n\n              if (!label) {\n                throw createError('expected label name');\n              }\n\n              node.addLabel(label);\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.ENTITY_START:\n            {\n              var _child4 = _Node.default.create(_Node.NodeType.ENTITY, '', {\n                start: start\n              });\n\n              if (states.embedded) {\n                _child4.states.embedded = true;\n                _child4.states.metaKey = states.key;\n                states.embedded = false;\n              } else {\n                node.appendChild(_child4);\n              }\n\n              pushNode(_child4);\n              state = State.ENTITY_BODY;\n              break;\n            }\n\n          case State.ENTITY_BODY:\n            {\n              start = stream.pos;\n\n              var _text2 = stream.readTo(_constants.T_ENTITY_END, {\n                skipMatched: true\n              });\n\n              if (!_text2) {\n                throw createError('empty entity');\n              } else if (_text2.search(_constants.P_LINE_BREAK) !== -1) {\n                throw createError('unexpected line break of entity');\n              }\n\n              node.appendText(_text2, {\n                start: start,\n                end: start + _text2.length\n              });\n\n              var _ch4 = stream.eat(_constants.T_TAG_START);\n\n              if (_ch4) {\n                state = State.TAG_START;\n              } else {\n                state = State.ENTITY_END;\n              }\n\n              break;\n            }\n\n          case State.ENTITY_END:\n            {\n              popNode();\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.END:\n            {\n              if (node.type !== _Node.NodeType.ROOT) {\n                popNode();\n              }\n\n              state = State.FINISH;\n              break;\n            }\n\n          case State.FINISH:\n            {\n              break;\n            }\n        }\n      }\n\n      root.toString();\n      this.parsed = true;\n      this.debug('parsed result:');\n      this.debug(JSON.stringify(root.toJSON(), null, 2));\n      return root;\n    }\n  }]);\n  return Tokenizer;\n}();\n\nvar _default = Tokenizer;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Class holding text line data\n */\n\n\nvar TextLine =\n/*#__PURE__*/\nfunction () {\n  function TextLine(lines, text, ln, offset) {\n    (0, _classCallCheck2.default)(this, TextLine);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"ln\", void 0);\n    (0, _defineProperty2.default)(this, \"offset\", void 0);\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n  /**\n   * Get the previous line\n   */\n\n\n  (0, _createClass2.default)(TextLine, [{\n    key: \"prev\",\n    value: function prev() {\n      return this.lines[this.ln - 2];\n    }\n    /**\n     * Get the next line\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.lines[this.ln];\n    }\n    /**\n     * Get text length of the line\n     */\n\n  }, {\n    key: \"toJSON\",\n\n    /**\n     * Convert to JSON serializable object\n     */\n    value: function toJSON() {\n      return {\n        ln: this.ln,\n        start: this.start,\n        end: this.end,\n        text: this.text\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n    /**\n     * Start position of the line, alias of `offset`\n     */\n\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.offset;\n    }\n    /**\n     * End position of the line\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n  }]);\n  return TextLine;\n}();\n\nvar _default = TextLine;\nexports.default = _default;"],"sourceRoot":""}