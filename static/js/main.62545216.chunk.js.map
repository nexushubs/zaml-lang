{"version":3,"sources":["../../src/index.ts","../../src/Tokenizer.ts","../../src/TextLine.ts","App.tsx","sample/default.ts","serviceWorker.ts","index.tsx","../../src/constants.ts","Editor/Pane.tsx","../../src/util.ts","../../src/Node.ts","../../src/TextStream.ts","../../src/ParseError.ts","Editor/Editor.tsx","Editor/logo.svg","TreeView/TreeNode.tsx","TreeView/TreePathItem.tsx","TreeView/TreePath.tsx","TreeView/TreeToolbar.tsx","TreeView/TreePropEditor.tsx","Common/TabView.tsx","TreeView/TreeView.tsx","SourceEditor/codemirror-mode.ts","SourceEditor/SourceEditor.tsx","VisualEditor/VisualNode.tsx","VisualEditor/VisualEditor.tsx"],"names":["parse","text","Tokenizer","tokenize","console","ParseError","TextStream","TextLine","Node","NodeType","State","stateNames","getStateName","state","countLineBreaks","result","P_LINE_BREAK","_","TypeError","test","T_LINE_BREAK","this","defaultOptions","needMetadataMarker","attributeAsString","bigIntAsString","enableComments","verbose","process","options","stream","timeStart","Date","start","lastState","lastPos","states","unwrapped","inline","embedded","isClosing","key","value","undefined","root","source","nodeStack","node","debugStack","lastNode","stack","n","i","chalk","list","pushNode","popNode","error","normalizeParagraph","createError","levelUpBlock","blockNode","p","lastChild","T_LINE_BREAKS","message","from","to","JSON","PROCESSING_TIMEOUT","Error","P_WHITE_SPACES_EXT","metadataMatched","T_METADATA_MARKER","P_ATTRIBUTE_LIST_MULTILINE","consume","P_WHITE_SPACE","P_PARAGRAPH_BREAK","child","markerPattern","P_MARKER_WITH_COMMENTS","P_MARKER","toEOF","P_SPACE_WRAPPED_LINE_BREAK","end","pos","ch","P_LABEL_START","T_SINGLE_LINE_COMMENT","rest","T_TAG_START","T_TAG_END","T_ENTITY_START","content","T_MULTIPLE_LINE_COMMENT","skipMatched","T_TAG_CLOSING","tagName","simpleBlock","name","P_TAG_NAME_MULTILINE","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","P_ATTRIBUTE_LIST","labels","metadata","P_ATTRIBUTE_ASSIGN","P_ATTRIBUTE_NAME","P_ATTRIBUTE_NAME_MULTILINE","P_ASSIGN_YAML","T_STRING_START","P_STRING_LITERAL_QUOTED","err","P_STRING_LITERAL_UNQUOTED","P_DATE_LITERAL","P_NUMBER_VALUE","parseNumber","P_BOOLEAN_TRUE","P_BOOLEAN_FALSE","parseMetadata","tagNode","label","P_VAR_NAME","T_ENTITY_END","length","lines","ln","offset","App","className","Editor","defaultSource","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","combinePatterns","T_ASSIGN_XML","T_ASSIGN_YAML","T_METADATA_FAVORED_ASSIGN","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","RegExp","P_LABEL","join","P_TAG_NAME","P_NUMBER_LITERAL","P_NUMBER_LITERAL_FULL","P_STRING_LITERAL_UNQUOTED_TESTER","START_MARKERS","END_MARKERS","Pane","props","title","children","classNames","React","defaultProps","P_DATE_FORMAT","number","parseFloat","Number","prefix","main","parseInt","stringify","indent","space","DEFAULT_INDENT_SPACES","simple","toSource","metadataMarker","opt","simpleTag","Object","spacer","listCount","T_SPACE","formatValue","subText","next","asString","isNode","isChrome","isAnsiSupported","colorful","reset","bold","dim","italic","underline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","white","blackBright","grey","gray","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","whiteBright","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgBlackBright","bgGrey","bgGray","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhiteBright","nanoid","require","NodeTypes","P_NODE_EXPRESSION","P_TAG_EXPRESSION","P_ENTITY_EXPRESSION","P_LABEL_EXPRESSION","BlockNodeTypes","BlockTags","Descriptor","WrappingTags","TreeRules","defaultFinderCallback","testNode","pattern","childNode","find","findOne","parseJson","json","id","attributes","parseJsonMap","childData","toJsonMap","map","parseValue","parent","type","c","allowed","n1","n2","path1","path2","ancestor","paths","range","startNode","startOffset","endNode","endOffset","RangeError","fragment","block","baseStartNode","baseEndNode","_startIndex","_endIndex","startIndex","endIndex","isStartSided","isEndSided","foundBlock","hasBlock","inserting","startText","endText","expression","includes","side","insertAt","index","ref","refIndex","indexOf","newChild","oldChild","data","selector","one","finder","findBy","textStart","textEnd","callback","separator","textNodes","tn","childLength","merged","textNode","slice","nodes","extractNodes","items","entityNodes","item","entityNode","entities","cache","extractor","nodeList","textList","Promise","firstChild","previousSibling","nextSibling","position","textPosition","internalId","isEntity","path","selectors","isTag","_source","rootNode","siblings","childIndex","LINE_BREAKS","tabSize","matched","substr","lineIndex","line","col","trimSpaces","charAt","ok","string","chr","eat","caseInsensitive","left","toEOL","search","substring","readTo","nextLine","read","marker","_data","markers","cursorStack","numWidth","P_FULL_WIDTH_CHARACTER","l","isCurrent","zaml","create","ROOT","global","info","sourceBlock","querySelector","sourceText","findOneBy","TEXT","createEntitiesFromText","preventSourceChange","sourcePaneHeight","onResize","throttle","bind","addEventListener","passive","removeEventListener","nextProps","nextState","selectedNode","log","height","innerHeight","setState","selected","hoveredNode","href","split","defaultSize","minSize","onChange","handleSourceChange","onSelect","r","handleNodeChange","onHover","_extends","assign","target","arguments","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_ref2","createElement","_ref3","fill","d","_ref4","_ref5","cx","cy","_ref6","_ref7","x","y","width","rx","ry","_ref8","_ref9","points","SvgLogo","_ref","svgRef","viewBox","ForwardRef","forwardRef","NodePart","nil","TreeNode","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","isRoot","Whole","Header","onlyText","onClick","event","stopPropagation","commonProps","isEmpty","ENTITY","isBlock","isWrappingTag","openDescriptorStart","openDescriptorEnd","truncate","Footer","closingDescriptor","TreePathItem","descriptor","TreePath","buildNodeList","unshift","TreeToolbar","Tab","TabView","tabs","selectedTab","onTabChange","tab","values","defaultTab","TreePropEditor","editingIndex","inlineError","editingElement","renderEmptyTip","Labels","renderLabelEditor","Attributes","renderAttributeEditor","Metadata","focus","select","focusEditingElement","originalLabel","e","addLabel","removeLabel","cancelLabelEditing","defaultValue","onBlur","handleLabelUpdate","currentTarget","onKeyDown","handleLabelEdit","renderValue","renderTabContent","TreeView","without","nodeIds","union","handleExpansionChange","CodeMirror","defineSimpleMode","regex","token","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","editor","setSize","setValue","onBeforeChange","editorDidMount","VisualNode","element","PARAGRAPH","node-name","node-id","url","TAG","push","toLowerCase","VisualEditor","ContextMenuTarget","currentNode","handleContextMenu","selection","getSelection","rangeCount","getRangeAt","domNode","startContainer","textContent","preventDefault","punctuationPattern","startPos","endPos","exec","lastIndex","setStart","setEnd","commonNode","getNodeByElement","commonAncestorContainer","endContainer","createBlockByRange","removeAllRanges","flatten","anchorNode","focusNode","createEntities","alert","removeEntity","splitText","nodeType","TEXT_NODE","classList","contains","parentElement","getAttribute","getNodeById","onDoubleClick","handleDoubleClick","commonEntityNames","wrapperNode","disabled","handleCreateBlock","handleRemoveBlock","handleSplitSentences","handleCreateEntity","prompt","handleRemoveEntity","handleInspect"],"mappings":"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","file":"static/js/main.62545216.chunk.js","sourcesContent":["import Tokenizer, { ParsingOptions } from './Tokenizer';\nimport TextStream, { TextLine } from './TextStream';\nimport Node, { NodeType } from './Node';\nimport ParseError from './ParseError';\n\n/**\n * @module @zaml/parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\nfunction parse(text: string, options?: ParsingOptions) {\n  const tokenizer = new Tokenizer(text, options);\n  return tokenizer.process();\n}\n\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\nfunction tokenize(text: string, options: ParsingOptions) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nexport {\n  ParseError,\n  Tokenizer,\n  TextStream,\n  TextLine,\n  Node,\n  NodeType,\n  tokenize,\n  parse,\n};\n\nexport default {\n  ParseError,\n  Tokenizer,\n  TextStream,\n  TextLine,\n  Node,\n  NodeType,\n  tokenize,\n  parse,\n};\n","import * as _ from 'lodash';\nimport { chalk, parseNumber } from './util';\nimport TextStream, { SourcePosition } from './TextStream';\nimport ParseError from './ParseError';\nimport Node, { NodeType } from './Node';\nimport {\n  T_SPACE,\n  T_TAB,\n  T_METADATA_MARKER,\n  T_ENTITY_START,\n  T_ENTITY_END,\n  T_TAG_START,\n  T_TAG_CLOSING,\n  T_TAG_END,\n  T_ASSIGN_XML,\n  P_ASSIGN_YAML,\n  T_METADATA_FAVORED_ASSIGN,\n  T_TAG_ATTRIBUTE_FAVORED_ASSIGN,\n  T_LINE_BREAKS,\n  T_SINGLE_LINE_COMMENT,\n  T_MULTIPLE_LINE_COMMENT,\n  P_SPACE_WRAPPED_LINE_BREAK,\n  P_LINE_BREAK,\n  P_PARAGRAPH_BREAK,\n  P_WHITE_SPACE,\n  P_WHITE_SPACES_EXT,\n  P_TAG_NAME,\n  P_TAG_NAME_MULTILINE,\n  P_LABEL_START,\n  P_VAR_NAME,\n  P_ATTRIBUTE_ASSIGN,\n  P_ATTRIBUTE_NAME,\n  P_ATTRIBUTE_NAME_MULTILINE,\n  P_ATTRIBUTE_LIST,\n  P_ATTRIBUTE_LIST_MULTILINE,\n  T_STRING_START,\n  P_DATE_LITERAL,\n  P_NUMBER_VALUE,\n  P_STRING_LITERAL_QUOTED,\n  P_STRING_LITERAL_UNQUOTED,\n  P_BOOLEAN_TRUE,\n  P_BOOLEAN_FALSE,\n  START_MARKERS,\n  END_MARKERS,\n  P_MARKER,\n  P_MARKER_WITH_COMMENTS,\n  PROCESSING_TIMEOUT,\n  T_LINE_BREAK,\n  P_MULTIPLE_LINE_BREAK,\n} from './constants';\n\nenum State {\n  METADATA = 0,\n  NORMAL,\n  SINGLE_COMMENT,\n  MULTIPLE_COMMENT,\n  START,\n  TAG_START,\n  TAG_NAME,\n  ATTRIBUTE_LIST,\n  ATTRIBUTE_NAME,\n  ATTRIBUTE_ASSIGN,\n  ATTRIBUTE_VALUE,\n  ATTRIBUTE_FINISH,\n  TAG_END,\n  LABEL_START,\n  ENTITY_START,\n  ENTITY_BODY,\n  ENTITY_END,\n  END,\n  FINISH,\n};\n\nconst stateNames = [\n  'METADATA',\n  'NORMAL',\n  'SINGLE_COMMENT',\n  'MULTIPLE_COMMENT',\n  'START',\n  'TAG_START',\n  'TAG_NAME',\n  'ATTRIBUTE_LIST',\n  'ATTRIBUTE_NAME',\n  'ATTRIBUTE_ASSIGN',\n  'ATTRIBUTE_VALUE',\n  'ATTRIBUTE_FINISH',\n  'TAG_END',\n  'LABEL_START',\n  'ENTITY_START',\n  'ENTITY_BODY',\n  'ENTITY_END',\n  'END',\n  'FINISH',\n];\n\nconst getStateName = (state: State) => {\n  return stateNames[state];\n}\n\nconst countLineBreaks = (text: string) => {\n  const result = text.match(P_LINE_BREAK);\n  return result ? result.length : 0;\n}\n\nexport interface ParsingOptions {\n  verbose?: boolean;\n  needMetadataMarker?: boolean;\n  attributeAsString?: boolean;\n  bigIntAsString?: boolean;\n  enableComments?: boolean;\n};\n\n/**\n * Tokenizer class\n * @class\n */\nclass Tokenizer {\n\n  static from(text: string, options: ParsingOptions) {\n    return new Tokenizer(text, options);\n  }\n\n  public text: string;\n  public stream: TextStream;\n  public options: ParsingOptions;\n  public parsed: boolean;\n\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n  constructor(text: string, options?: ParsingOptions) {\n    if (!_.isString(text)) {\n      throw new TypeError('input must be string');\n    }\n    // ensure new line at the end of file\n    if (!/\\n\\s*$/.test(text)) {\n      text += T_LINE_BREAK;\n    }\n    this.text = text;\n    this.stream = new TextStream(text);\n    const defaultOptions: ParsingOptions = {\n      needMetadataMarker: false,\n      attributeAsString: false,\n      bigIntAsString: false,\n      enableComments: false,\n      verbose: process && process.env.DEBUG === 'verbose',\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  debug(...params: any[]) {\n    if (this.options.verbose) {\n      console.log(...params);\n    }\n  }\n\n  /**\n   * Process a text and parse to AST\n   * @returns Root node of parsed AST\n   */\n  process(): Node {\n    const { text, stream } = this;\n    const {\n      needMetadataMarker,\n      attributeAsString,\n      bigIntAsString,\n    } = this.options;\n    const timeStart = Date.now();\n    let state: State = State.METADATA;\n    let start = 0;\n    let lastState: State = 0;\n    let lastPos = -1;\n    const states: {\n      unwrapped: boolean,\n      inline: boolean,\n      embedded: boolean,\n      isClosing: boolean,\n      key?: string,\n      value?: any,\n    } = {\n      unwrapped: false,\n      inline: false,\n      embedded: false,\n      isClosing: false,\n      key: undefined,\n      value: undefined,\n    };\n    const root = Node.create(NodeType.ROOT, undefined, { source: text });\n    const nodeStack: Node[] = [];\n    let node: Node = root;\n\n    const debugStack = (lastNode?: Node) => {\n      if (!this.options.verbose) {\n        return;\n      }\n      const separator = ' > ';\n      const stack = [...nodeStack, node];\n      const list = stack.map((n, i) => {\n        if (n) {\n          let text = n.descriptor;\n          if (i === stack.length - 1) {\n            text = chalk.cyanBright(text);\n          } else {\n            text = chalk.green(text);\n          }\n          return text;\n        }\n        return '';\n      });\n      let result = list.join(chalk.redBright(separator));\n      if (lastNode) {\n        result += chalk.grey(`${separator}${lastNode.descriptor}`);\n      }\n      return result;\n    }\n\n    const pushNode = (n: Node) => {\n      if (node.start === -1) {\n        node.start = stream.pos;\n      }\n      nodeStack.push(node);\n      node = n;\n      this.debug(`push: ${debugStack()}\\n`);\n    }\n\n    const popNode = (error?: string) => {\n      const lastNode = node;\n      node.end = stream.pos;\n      if (node.isParagraph) {\n        normalizeParagraph(node);\n      }\n      if (node.start === node.end || (node.isParagraph && !node.hasChild()) && node.parent) {\n        node.remove();\n      }\n      node = <Node> nodeStack.pop();\n      this.debug(`pop : ${debugStack(lastNode)}\\n`);\n      if (!node) {\n        throw createError(error || 'unexpected closing node');\n      }\n    };\n\n    // replace wrapping paragraph with current block tag\n    const levelUpBlock = () => {\n      if (node.parent && node.parent.type === NodeType.PARAGRAPH) {\n        const blockNode = node;\n        popNode();\n        node.removeChild(blockNode);\n        popNode();\n        node.appendChild(blockNode);\n        pushNode(blockNode);\n      }\n    }\n\n    const normalizeParagraph = (p: Node) => {\n      const lastChild = p.lastChild;\n      if (lastChild && lastChild.isText) {\n        lastChild.content = _.trimEnd(lastChild.content, T_LINE_BREAKS);\n        if (!lastChild.content) {\n          lastChild.remove()\n        }\n      }\n    }\n\n    const createError = (message: string) => {\n      let from: SourcePosition;\n      let to: SourcePosition;\n      from = stream.getPosition(lastPos);\n      to = stream.pos === lastPos ? stream.getPosition(lastPos + 1) : stream.getPosition();\n      this.debug(`error: '${message}' at ${from.ln}:${from.col}`);\n      this.debug('current node:');\n      if (node) {\n        this.debug(node.toJSON());\n      }\n      this.debug('current parsing state:');\n      this.debug(JSON.stringify(root, null, 2));\n      return new ParseError(message, text, from, to);\n    };\n\n    while (state !== State.FINISH) {\n      // parse failure watcher\n      if (Date.now() - timeStart >= PROCESSING_TIMEOUT) {\n        this.debug('parsing timeout!');\n        state = State.FINISH;\n      }\n      if (state === lastState && lastPos === stream.pos) {\n        throw new Error('Parser fall into infinite loop!');\n      }\n      lastState = state;\n      lastPos = stream.pos;\n      this.debug(chalk.magenta(`# ${getStateName(state)}, pos = ${stream.pos}`));\n      if (this.options.verbose) {\n        stream.debugState();\n      }\n      \n      switch (state) {\n\n        case State.METADATA: {\n          stream.eatWhile(P_WHITE_SPACES_EXT);\n          const metadataMatched = stream.match(T_METADATA_MARKER);\n          if (needMetadataMarker && !metadataMatched) {\n            state = State.NORMAL;\n            break;\n          }\n          if (metadataMatched || stream.match(P_ATTRIBUTE_LIST_MULTILINE, { consume: false })) {\n            node.states.metadata = true;\n            state = State.ATTRIBUTE_LIST;\n          } else {\n            state = State.NORMAL;\n          }\n          break;\n        }\n\n        case State.NORMAL: {\n          if (stream.sol(true) || stream.eol(true)) {\n            stream.eatWhile(P_WHITE_SPACE);\n          }\n          if (stream.match(P_PARAGRAPH_BREAK)) {\n            popNode();\n            if (node.states.unwrapped) {\n              popNode();\n            }\n            break;\n          }\n          start = stream.pos;\n          if (!node.isParagraph && !node.isInlineBlock && stream.sol(true)) {\n            const child = node.createChild(NodeType.PARAGRAPH, undefined, { start });\n            pushNode(child);\n          }\n          const markerPattern = this.options.enableComments ? P_MARKER_WITH_COMMENTS : P_MARKER;\n          const originalText = stream.readTo(markerPattern, { toEOF: true });\n          let text = originalText;\n          if (text) {\n            if (node.children.length === 0) {\n              text = _.trimStart(text);\n            }\n            text = text.replace(P_SPACE_WRAPPED_LINE_BREAK, T_LINE_BREAK);\n            // text = _.trimEnd(text, T_LINE_BREAKS);\n            if (text) {\n              node.appendText(text, { start, end: stream.pos });\n            }\n          }\n          if (stream.match(P_PARAGRAPH_BREAK, { consume: false })) {\n            state = State.NORMAL;\n          } else {\n            state = State.START;\n          }\n          break;\n        }\n        \n        case State.START: {\n          start = stream.pos;\n          const markerPattern = this.options.enableComments ? P_MARKER_WITH_COMMENTS : P_MARKER;\n          const ch: string = stream.eat(markerPattern);\n          P_LABEL_START.lastIndex = 0;\n          if (ch === T_SINGLE_LINE_COMMENT) {\n            const rest = stream.eatWhile(T_SINGLE_LINE_COMMENT);\n            if (rest.length === 0) {\n              state = State.SINGLE_COMMENT;\n            } else {\n              state = State.MULTIPLE_COMMENT;\n            }\n          } else if (ch === T_TAG_START) {\n            state = State.TAG_START;\n          } else if (P_LABEL_START.test(ch)) {\n            states.unwrapped = true;\n            state = State.TAG_START;\n          } else if (ch === T_TAG_END) {\n            states.isClosing = true;\n            state = State.TAG_END;\n          } else if (ch === T_ENTITY_START) {\n            state = State.ENTITY_START;\n          } else if (stream.eof()) {\n            state = State.END;\n          } else {\n            throw createError('empty start')\n          }\n          break;\n        }\n\n        case State.SINGLE_COMMENT:\n        case State.MULTIPLE_COMMENT: {\n          start = stream.pos;\n          let content: string;\n          if (state === State.SINGLE_COMMENT) {\n            content = stream.readTo(P_LINE_BREAK);\n          } else {\n            content = stream.readTo(T_MULTIPLE_LINE_COMMENT, { skipMatched: true });\n          }\n          if (content) {\n            if (state === State.MULTIPLE_COMMENT) {\n              content = content.replace(P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n            }\n            content = _.trim(content);\n          }\n          if (content) {\n            node.createChild(NodeType.COMMENT, undefined, {\n              start,\n              end: stream.pos,\n              content,\n            });\n          }\n          state = State.NORMAL;\n          break;\n        }\n        \n        case State.TAG_START: {\n          if (stream.eat(T_TAG_CLOSING)) {\n            states.isClosing = true;\n            state = State.TAG_NAME;\n          } else if (stream.match(P_LINE_BREAK)) {\n            state = State.NORMAL;\n          } else if (!node.isEntity && (states.unwrapped || stream.eat(P_LABEL_START))) {\n            state = State.LABEL_START;\n          } else {\n            const child = Node.create(NodeType.TAG, '', { start });\n            if (states.embedded) {\n              child.states.embedded = true;\n              child.states.metaKey = states.key;\n              states.embedded = false;\n            } else {\n              node.appendChild(child);\n            }\n            pushNode(child);\n            state = State.TAG_NAME;\n          }\n          if (state === State.NORMAL || state === State.LABEL_START) {\n            stream.pushCursor(start);\n            const tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n            stream.popCursor();\n            if (node.isParagraph && tagName === 'BLOCK') {\n              popNode();\n            }\n            const child = node.createChild(NodeType.TAG, tagName, {\n              start,\n              states: {\n                simpleBlock: true,\n                unwrapped: states.unwrapped,\n              },\n            });\n            states.unwrapped = false;\n            pushNode(child)\n          }\n          break;\n        }\n        \n        case State.TAG_NAME: {\n          const name = stream.match(P_TAG_NAME_MULTILINE);\n          if (!name) {\n            throw createError('expected tag name');\n          }\n          states.inline = name === 'INLINE';\n          if (states.isClosing) {\n            if (node.isParagraph) {\n              stream.pushCursor(start);\n              popNode();\n              stream.popCursor();\n            }\n            if (name !== node.name) {\n              throw createError('unexpected closing tag');\n            }\n            const ch = stream.eat(T_TAG_END);\n            if (!ch) {\n              throw createError('invalid closing tag');\n            }\n            if (!(states.inline || node.isInlineBlock) && !stream.eol()) {\n              throw createError('closing block tag must take the whole line');\n            }\n            state = State.TAG_END;\n          } else {\n            node.name = name;\n            if (node.isWrappingTag) {\n              stream.pushCursor(node.start || 0);\n              if (node.name === 'BLOCK' && !stream.sol(true)) {\n                throw createError('unexpected start of block inline');\n              }\n              stream.popCursor();\n              if (node.isBlock) {\n                levelUpBlock();\n              }\n            }\n            state = State.ATTRIBUTE_LIST;\n          }\n          break;\n        }\n        \n        case State.ATTRIBUTE_LIST: {\n          const spaces = stream.eatWhile(\n            (node.isInlineBlock || (node.states.simpleBlock && !node.states.metadata))\n            ? P_WHITE_SPACE\n            : P_WHITE_SPACES_EXT\n          );\n          const isParsingMetadata: boolean = node.states.metadata;\n          if (isParsingMetadata) {\n            let endOfFrontMatter = false;\n            if (stream.match(T_METADATA_MARKER)) {\n              if (!stream.match(P_LINE_BREAK)) {\n                throw createError('expected new line after metadata closed');\n              }\n              endOfFrontMatter = true;\n            }\n            const lineBreaks = countLineBreaks(spaces);\n            if (lineBreaks > 1) {\n              endOfFrontMatter = true;\n            }\n            if (endOfFrontMatter) {\n              state = State.NORMAL;\n              node.states.metadata = false;\n              break;\n            }\n            // deal with simple block at the beginning\n            if (node.isRoot && !stream.match(P_ATTRIBUTE_LIST, { consume: false }) && lineBreaks === 1) {\n              const child = node.createChild(NodeType.TAG, 'BLOCK', {\n                labels: node.labels,\n                states: {\n                  unwrapped: true,\n                },\n                metadata: node.metadata,\n              });\n              node.clearLabels();\n              node.clearMetadata();\n              pushNode(child);\n              state = State.NORMAL;\n              break;\n            }\n          }\n          if (stream.match(P_LINE_BREAK)) {\n            state = State.NORMAL;\n          } else if (stream.eat(T_TAG_END)) {\n            state = State.TAG_END;\n          } else if (stream.match(P_LABEL_START)) {\n            state = State.LABEL_START;\n          } else {\n            if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n              if (_.isEmpty(node.attributes) && P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                states.key = node.name;\n                node.name = 'BLOCK';\n                node.states.simpleBlock = true;\n                levelUpBlock();\n                state = State.ATTRIBUTE_ASSIGN;\n                break;\n              } else {\n                throw createError('expecting end of tag \"}\" or attribute list');\n              }\n            }\n            if (stream.match(\n              (node.isInlineBlock || node.states.simpleBlock || node.states.metadata)\n              ? P_ATTRIBUTE_LIST\n              : P_ATTRIBUTE_LIST_MULTILINE,\n              { consume: false },\n            )) {\n              state = State.ATTRIBUTE_NAME;\n            } else {\n              state = State.NORMAL;\n            }\n          }\n          break;\n        }\n        \n        case State.ATTRIBUTE_NAME: {\n          const key = stream.match(\n            (node.isInlineBlock || node.states.simpleBlock)\n            ? P_ATTRIBUTE_NAME\n            : P_ATTRIBUTE_NAME_MULTILINE\n          );\n          if (!key) {\n            throw createError('expecting attribute name');\n          }\n          states.key = key;\n          state = State.ATTRIBUTE_ASSIGN;\n          break;\n        }\n        \n        case State.ATTRIBUTE_ASSIGN: {\n          let ch = stream.peek();\n          if (ch === T_TAG_END) {\n            state = State.ATTRIBUTE_FINISH;\n          } else {\n            ch = stream.eat(P_ATTRIBUTE_ASSIGN);\n            if (!ch) {\n              if (node.states.simpleBlock) {\n                throw createError('expecting assignment \"=\" or \":\"');\n              }\n              states.value = true;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n            if (P_ASSIGN_YAML.test(ch)) {\n              stream.eatWhile(P_WHITE_SPACE);\n              if (stream.match(P_LINE_BREAK)) {\n                throw createError('unexpected end of line');\n              }\n            }\n            state = State.ATTRIBUTE_VALUE;\n          }\n          break;\n        }\n\n        case State.ATTRIBUTE_VALUE: {\n          const ch = stream.peek();\n          let value: any = undefined;\n          if (ch === T_TAG_START || ch === T_ENTITY_START) {\n            states.embedded = true;\n            state = State.START;\n            break;\n          } else if (ch === T_STRING_START) {\n            value = stream.match(P_STRING_LITERAL_QUOTED);\n            try {\n              value = JSON.parse(value);\n            } catch (err) {\n              throw createError('invalid string literal');\n            }\n          } else if (attributeAsString) {\n            value = stream.match(P_STRING_LITERAL_UNQUOTED);\n          } else if (value = stream.match(P_DATE_LITERAL)) {\n            value = new Date(value);\n          } else if (value = stream.match(P_NUMBER_VALUE)) {\n            value = parseNumber(value, bigIntAsString);\n          } else if (stream.match(P_BOOLEAN_TRUE)) {\n            value = true;\n          } else if (stream.match(P_BOOLEAN_FALSE)) {\n            value = false;\n          } else {\n            value = stream.match(P_STRING_LITERAL_UNQUOTED);\n          }\n          if (_.isNull(value)) {\n            throw createError('invalid attribute value');\n          }\n          states.value = value;\n          state = State.ATTRIBUTE_FINISH;\n          break;\n        }\n\n        case State.ATTRIBUTE_FINISH: {\n          let { key, value } = states;\n          states.key = undefined;\n          states.value = undefined;\n          if (_.isUndefined(value)) {\n            value = true;\n          }\n          if (node.states.metadata) {\n            node.setMetadata(<string>key, value);\n          } else {\n            node.setAttribute(<string>key, value);\n          }\n          this.debug(`# ${node.states.metadata ? 'metadata' : 'attribute'} ${key}=${JSON.stringify(value)}`);\n          this.debug();\n          state = State.ATTRIBUTE_LIST;\n          break;\n        }\n\n        case State.TAG_END: {\n          const parseMetadata = node.isBlockTag && !states.isClosing;\n          let tagNode = node;\n          states.inline = tagNode.isInlineBlock;\n          if (!node.isWrappingTag || states.isClosing) {\n            if (node.isParagraph) {\n              popNode();\n            }\n            popNode();\n            if (node.isEntity) {\n              // copy tag properties to entity and remove temporary tag node\n              node.setAttributes(tagNode.attributes);\n              node.name = tagNode.name;\n              node.removeChild(tagNode);\n              state = State.ENTITY_END;\n              tagNode = node;\n              popNode();\n            }\n            if (tagNode.states.embedded) {\n              if (node.states.metadata) {\n                node.setMetadata(tagNode.states.metaKey, tagNode);\n              } else {\n                node.setAttribute(tagNode.states.metaKey, tagNode);\n              }\n            }\n          }\n          if (states.isClosing && !states.inline) {\n            stream.skipOver(P_LINE_BREAK);\n          }\n          states.isClosing = false;\n          states.inline = false;\n          if (parseMetadata) {\n            state = State.METADATA;\n          } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n            state = State.ATTRIBUTE_LIST;\n          } else {\n            state = State.NORMAL;\n          }\n          break;\n        }\n        \n        case State.LABEL_START: {\n          const label = stream.match(P_VAR_NAME);\n          if (!label) {\n            throw createError('expected label name');\n          }\n          node.addLabel(label);\n          state = State.ATTRIBUTE_LIST;\n          break;\n        }\n\n        case State.ENTITY_START: {\n          const child = Node.create(NodeType.ENTITY, '', { start });\n          if (states.embedded) {\n            child.states.embedded = true;\n            child.states.metaKey = states.key;\n            states.embedded = false;\n          } else {\n            node.appendChild(child);\n          }\n          pushNode(child);\n          state = State.ENTITY_BODY;\n          break;\n        }\n        \n        case State.ENTITY_BODY: {\n          start = stream.pos;\n          const text = stream.readTo(T_ENTITY_END, { skipMatched: true });\n          if (!text) {\n            throw createError('empty entity');\n          } else if (text.search(P_LINE_BREAK) !== -1) {\n            throw createError('unexpected line break of entity');\n          }\n          node.appendText(text, { start, end: start + text.length });\n          const ch = stream.eat(T_TAG_START);\n          if (ch) {\n            state = State.TAG_START;\n          } else {\n            state = State.ENTITY_END;\n          }\n          break;\n        }\n        \n        case State.ENTITY_END: {\n          popNode();\n          state = State.NORMAL;\n          break;\n        }\n        \n        case State.END: {\n          if (!node.isRoot) {\n            popNode();\n          }\n          state = State.FINISH;\n          break;\n        }\n\n        case State.FINISH: {\n          break;\n        }\n      }\n    }\n    root.toString();\n    this.parsed = true;\n    this.debug('parsed result:');\n    this.debug(JSON.stringify(root.toJSON(), null, 2));\n    return root;\n  }\n\n}\n\nexport default Tokenizer;\n","export interface TextLineData {\n  ln: number;\n  start: number;\n  end: number;\n  text: string;\n}\n\n/**\n * Class holding text line data\n */\nclass TextLine {\n\n  public lines: TextLine[];\n  public text: string;\n  public ln: number;\n  public offset: number;\n\n  constructor(lines: TextLine[], text: string, ln: number, offset: number) {\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n\n  /**\n   * Get the previous line\n   */\n  prev(): TextLine {\n    return this.lines[this.ln - 2];\n  }\n\n  /**\n   * Get the next line\n   */\n  next(): TextLine {\n    return this.lines[this.ln];\n  }\n\n  /**\n   * Get text length of the line\n   */\n  get length(): number {\n    return this.text.length;\n  }\n\n  /**\n   * Start position of the line, alias of `offset`\n   */\n  get start(): number {\n    return this.offset;\n  }\n\n  /**\n   * End position of the line\n   */\n  get end(): number {\n    return this.offset + this.text.length;\n  }\n\n  /**\n   * Convert to JSON serializable object\n   */\n  toJSON(): TextLineData {\n    return {\n      ln: this.ln,\n      start: this.start,\n      end: this.end,\n      text: this.text,\n    };\n  }\n}\n\nexport default TextLine\n","import React, { Component } from 'react';\nimport './App.scss';\nimport Editor from './Editor/Editor';\nimport contract from './sample/default';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Editor defaultSource={contract} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export default `---\nfoo: bar\n---\n#Question #Q #Q1 \n  What is your name?\n\n#Answer #A \n  My name is [Jack]{PER}\n`\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import * as _ from 'lodash';\n\nexport const combinePatterns = (list: (RegExp | string)[]) => {\n  return list.map(p => _.isRegExp(p) ? p.source : _.escapeRegExp(p)).join('|');\n};\n\nexport const DEFAULT_INDENT_SPACES = 2;\n\nexport const T_SPACE = ' ';\nexport const T_TAB = '\\t';\nexport const T_METADATA_MARKER = `---`;\nexport const T_SINGLE_LINE_COMMENT = '~';\nexport const T_MULTIPLE_LINE_COMMENT = '~~~';\nexport const T_ENTITY_START = '[';\nexport const T_ENTITY_END = ']';\nexport const T_TAG_START = '{';\nexport const T_TAG_CLOSING = '/';\nexport const T_TAG_END = '}';\nexport const T_ASSIGN_XML = '=';\nexport const T_ASSIGN_YAML = ':';\nexport const T_LINE_BREAK = '\\n';\nexport const T_LINE_BREAKS = '\\r\\n';\nexport const T_PARAGRAPH_BREAK = '\\n\\n';\nexport const T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexport const T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\n\nexport const P_ASSIGN_YAML = /[:]/;\nexport const P_LINE_BREAK = /\\r?\\n/g;\nexport const P_MULTIPLE_LINE_BREAK = /(\\r?\\n)+/g;\nexport const P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexport const P_PARAGRAPH_BREAK = new RegExp(`${P_LINE_BREAK.source}\\\\s*${P_LINE_BREAK.source}`, 'g');\nexport const P_WHITE_SPACE = /[ \\t]/g;\nexport const P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexport const P_LIST_SEPARATOR = /[,]/g;\nexport const P_LABEL_START = /[#]/g;\nexport const P_VAR_NAME = /[\\p{Script=Hani}A-Za-z][\\p{Script=Hani}\\w.]*/gu;\nexport const P_LABEL = new RegExp(`${P_LABEL_START.source}${P_VAR_NAME.source}`, 'g');\nexport const P_ATTRIBUTE_ASSIGN = new RegExp(`[${[T_ASSIGN_XML, T_ASSIGN_YAML].join('')}]`);\nexport const P_ATTRIBUTE_NAME = new RegExp(`(?:${P_VAR_NAME.source})(?=${combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END])})`, 'g');\nexport const P_ATTRIBUTE_NAME_MULTILINE = new RegExp(`(?:${P_VAR_NAME.source})(?=${combinePatterns([P_WHITE_SPACES_EXT, P_ATTRIBUTE_ASSIGN, T_TAG_END])})`, 'g');\nexport const P_ATTRIBUTE_LIST = new RegExp(`(${P_VAR_NAME.source}${P_ATTRIBUTE_ASSIGN.source}|${P_LABEL})`, 'g');\nexport const P_ATTRIBUTE_LIST_MULTILINE = new RegExp(`(${P_VAR_NAME.source}${P_ATTRIBUTE_ASSIGN.source}?|${P_LABEL})`, 'g');\nexport const P_TAG_NAME = P_ATTRIBUTE_NAME;\nexport const P_TAG_NAME_MULTILINE = P_ATTRIBUTE_NAME_MULTILINE;\nexport const T_STRING_START = '\"';\nexport const P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?|\\d{4}-[01]\\d-[0-3]\\d/g;\nexport const P_NUMBER_START = /[\\d\\.\\-]/;\nexport const P_NUMBER_LITERAL = /(?:\\-?(\\d*\\.\\d*|\\d+)(e\\-?\\d+)?|0x[0-9a-f]+|0o[0-7]+|0b[01]+)/g;\nexport const P_NUMBER_LITERAL_FULL = new RegExp(`^${P_NUMBER_LITERAL.source}$`);\nexport const P_NUMBER_VALUE = new RegExp(`${P_NUMBER_LITERAL.source}(?=${combinePatterns([P_WHITE_SPACES_EXT, T_TAG_END])})`, 'g');\nexport const P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\.)*\"/g;\nexport const P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexport const P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(`^${P_STRING_LITERAL_UNQUOTED.source}$`);\nexport const P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexport const P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexport const P_FULL_WIDTH_CHARACTER = /[\\p{Script=Hani}]/gu;\n\nexport const START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexport const END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexport const P_MARKER = new RegExp(`(${combinePatterns([P_PARAGRAPH_BREAK, ...START_MARKERS, T_TAG_END])})`, 'g');\nexport const P_MARKER_WITH_COMMENTS = new RegExp(`(${combinePatterns([P_PARAGRAPH_BREAK, ...START_MARKERS, T_TAG_END, T_SINGLE_LINE_COMMENT])})`, 'g');\n\nexport const PROCESSING_TIMEOUT = Infinity;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import * as _ from 'lodash';\n\nimport {\n  DEFAULT_INDENT_SPACES,\n  T_METADATA_MARKER,\n  T_SPACE,\n  T_LINE_BREAK,\n  T_TAG_START,\n  T_TAG_END,\n  T_TAG_CLOSING,\n  T_ENTITY_START,\n  T_ENTITY_END,\n  T_PARAGRAPH_BREAK,\n  P_STRING_LITERAL_UNQUOTED_TESTER,\n  P_PARAGRAPH_BREAK,\n  P_NUMBER_LITERAL_FULL,\n} from './constants';\n\nimport Node, { NodeType } from './Node';\n\nconst P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n\n/**\n * Stringify attribute value\n * @param value \n */\nexport function formatValue(value: any, asString: boolean = false) {\n  if (_.isDate(value)) {\n    value = value.toISOString();\n    if (asString) {\n      return JSON.stringify(value);\n    }\n    return value.replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString(value)) {\n    if (\n      [T_TAG_START, T_ENTITY_START].includes(value.charAt(0)) ||\n      P_NUMBER_LITERAL_FULL.test(value) ||\n      !P_STRING_LITERAL_UNQUOTED_TESTER.test(value)\n    ) {\n      value = JSON.stringify(value);\n    }\n    return value;\n  } else if (_.isBoolean(value)) {\n    value = value.toString();\n    if (asString) {\n      value = JSON.stringify(value);\n    }\n    return value;\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    if (asString) {\n      value = value.toString();\n    }\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Parse attribute value\n * @param value \n */\nexport function parseValue(value: any) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n  return value;\n}\n\n/**\n * Parse number\n * @param value \n */\nexport function parseNumber(value: string, bigIntAsString = false) {\n  let number = parseFloat(value);\n  if (/^\\d+$/.test(value) && bigIntAsString\n    && (number > Number.MAX_SAFE_INTEGER || number < Number.MIN_SAFE_INTEGER)\n  ) {\n    return value;\n  }\n  const prefix = value.substr(0, 2);\n  const main = value.substr(2);\n  switch (prefix) {\n    case '0x':\n      number = parseInt(main, 16);\n      break;\n    case '0o':\n      number = parseInt(main, 8);\n      break;\n    case '0b':\n      number = parseInt(main, 2);\n      break;\n  }\n  return number;\n}\n\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\nexport function spacer(space: number, indent: number) {\n  if (indent <= 0) return '';\n  return _.repeat(T_SPACE, space * indent);\n}\n\nexport interface StringifyOptions {\n  space?: number;\n  simple?: boolean;\n  toSource?: boolean;\n  metadataMarker?: boolean;\n  attributeAsString?: boolean;\n}\n\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\nexport function stringify(node: Node, options?: StringifyOptions, indent = -1, pos = 0) {\n  const defaultOptions = {\n    space: DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false,\n    metadataMarker: true,\n    attributeAsString: false,\n  };\n  let opt: StringifyOptions = _.defaults(options, defaultOptions);\n  let text = '';\n  const simpleTag = opt.simple && node.isSimpleTag &&\n    (node.labels.length > 0 || Object.keys(node.attributes).length > 0);\n  const unwrapped = simpleTag && node.isBlockTag && node.children.length === 1;\n  if (opt.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n  if (node.isText) {\n    if (opt.toSource) {\n      text += (node.content || '').replace(/\\n/g, `\\n${spacer(<number> opt.space, indent - 1)}`);\n    } else {\n      text += node.content;\n    }\n  } else {\n    if (node.isEntity) {\n      const child = _.first(node.children);\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n      if (opt.toSource) {\n        text += T_ENTITY_START;\n      }\n      text += stringify(child, opt, indent, pos + text.length);\n      if (opt.toSource) {\n        text += T_ENTITY_END;\n      }\n    }\n    if (opt.toSource && (node.isTag || node.isEntity)) {\n      if (node.isBlock) {\n        text += spacer(<number> opt.space, indent);\n      }\n      if (!unwrapped) {\n        text += T_TAG_START;\n      }\n      if (!simpleTag) {\n        text += node.name;\n      }\n      let listCount = 0;\n      _.keys(node.attributes).forEach((key, i) => {\n        const value = node.attributes[key];\n        listCount++;\n        if (!simpleTag || listCount > 1) {\n          text += T_SPACE;\n        }\n        if (!simpleTag && _.isBoolean(value) && value && !opt.attributeAsString) {\n          text += key;\n        } else if (value instanceof Node) {\n          text += stringify(node, opt, 0, pos + text.length);\n        } else {\n          text += `${key}=${formatValue(value, opt.attributeAsString)}`;\n        }\n      });\n      _.each(node.labels, (label, i) => {\n        listCount++;\n        if (!simpleTag || listCount > 1) {\n          text += T_SPACE;\n        }\n        text += `#${label}`;\n      });\n      if (!unwrapped) {\n        text += simpleTag ? T_SPACE : T_TAG_END;\n      }\n      if (node.isBlock) {\n        text += T_LINE_BREAK;\n      }\n    }\n    if (opt.toSource && node.isParagraph) {\n      text += spacer(<number> opt.space, indent);\n    }\n    if (opt.toSource && !_.isEmpty(node.metadata)) {\n      if (opt.metadataMarker) {\n        text += spacer(<number> opt.space, indent + 1) + T_METADATA_MARKER + T_LINE_BREAK;\n      }\n      _.each(node.metadata, (value, key) => {\n        text += spacer(<number> opt.space, indent + 1);\n        text += `${key}: `;\n        if (value instanceof Node) {\n          text += stringify(value, opt, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n        text += T_LINE_BREAK;\n      });\n      text += spacer(<number> opt.space, indent + 1);\n      if (opt.metadataMarker) {\n        text += T_METADATA_MARKER;\n      }\n      text += T_LINE_BREAK;\n    }\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(child => {\n        const subText = stringify(child, opt, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n    const next = node.nextSibling;\n    if (node.isBlock) {\n      if (opt.toSource) {\n        text = _.trimEnd(text, T_LINE_BREAK);\n      }\n      text += T_LINE_BREAK;\n      if (node.isParagraph && !node.isLastChild) {\n        text += T_LINE_BREAK;\n      }\n    }\n    if (opt.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(<number> opt.space, indent);\n      }\n      if (simpleTag) {\n        if (!unwrapped) {\n          text += T_TAG_END;\n        }\n      } else {\n        text += T_TAG_START + T_TAG_CLOSING + node.name + T_TAG_END;\n      }\n      if (node.isBlockTag) {\n        text += T_LINE_BREAK;\n        if (next && next.isBlock) {\n          text += T_LINE_BREAK;\n        }\n      }\n    }\n  }\n  if (opt.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}\n\nexport const isNode = (typeof process !== 'undefined') &&\n  (typeof process.release !== 'undefined') &&\n  (process.release.name === 'node');\n\nexport const isChrome = !isNode && /Chrome/.test(window.navigator.userAgent);\n\nexport const isAnsiSupported = isNode || isChrome;\n// lite version of https://github.com/chalk/chalk\n\nconst colorful = isAnsiSupported ?\n  (start: number, end: number) => (text: string) => `\\x1b[${start}m${text}\\x1b[${end}m`\n  :\n  (start: number, end: number) => (text: string) => text;\n\nconst chalkStyles = {\n  // modifier\n  reset: [0, 0],\n  // 21 isn't widely supported and 22 does the same thing\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  // color\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  // Bright color\n  blackBright: [90, 39],\n  grey: [90, 39],\n  gray: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  // bgColor\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  // Bright color\n  bgBlackBright: [100, 49],\n  bgGrey: [90, 39],\n  bgGray: [90, 39],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n}\n\nexport const chalk = _.mapValues(chalkStyles, ([start, end]) => colorful(start, end));\n","import * as _ from 'lodash';\nimport { stringify, parseValue, StringifyOptions } from './util';\nimport { parse } from '.';\nimport { P_LABEL_START, P_VAR_NAME } from './constants';\n\nconst nanoid = require('nanoid');\n\nexport enum NodeType {\n  FRAGMENT = 'fragment',\n  ROOT = 'root',\n  PARAGRAPH = 'paragraph',\n  TAG=  'tag',\n  ENTITY = 'entity',\n  TEXT = 'text',\n  COMMENT = 'comment',\n}\n\nexport const NodeTypes = _.values(NodeType);\n\nexport const P_NODE_EXPRESSION = /^<([A-Z]+)>$/;\nexport const P_TAG_EXPRESSION = /^{([A-Z]+)}$/;\nexport const P_ENTITY_EXPRESSION = /^\\[([A-Z]+)\\]$/;\nexport const P_LABEL_EXPRESSION = new RegExp(`^${P_LABEL_START}(${P_VAR_NAME})$`);\n\nexport const BlockNodeTypes = [\n  NodeType.ROOT,\n  NodeType.PARAGRAPH,\n];\n\nexport const BlockTags = [\n  'BLOCK',\n  'QUOTE',\n  'SECTION',\n  'HEADER',\n  'FOOTER',\n];\n\nexport const WrappingTags = [\n  ...BlockTags,\n  'INLINE',\n  'SENTENCE',\n  'NUM',\n  'HEADING',\n];\n\nenum Descriptor {\n  ROOT = '<root>',\n  PARAGRAPH = '<paragraph>',\n  BLOCK = '{BLOCK}',\n  INLINE = '{INLINE}',\n  ENTITY = '[ENTITY]',\n  TEXT = '(text)',\n  FRAGMENT = '<fragment>',\n  ANY = '*',\n}\n\nexport const TreeRules: {[key: string]: Descriptor[]} = {\n  [Descriptor.ROOT]: [Descriptor.PARAGRAPH, Descriptor.BLOCK],\n  [Descriptor.PARAGRAPH]: [Descriptor.INLINE, Descriptor.ENTITY, Descriptor.TEXT],\n  [Descriptor.BLOCK]: [Descriptor.PARAGRAPH, Descriptor.BLOCK],\n  [Descriptor.INLINE]: [Descriptor.INLINE, Descriptor.ENTITY, Descriptor.TEXT],\n  [Descriptor.ENTITY]: [Descriptor.TEXT],\n  [Descriptor.TEXT]: [],\n  [Descriptor.FRAGMENT]: [Descriptor.ANY],\n}\n\nexport type SingleExtractor = (text: string) => EntityInfo[];\n\nexport type AsyncSingleExtractor = (text: string) => Promise<EntityInfo[]>;\n\nexport type ArrayExtractor = (textArr: string[]) => EntityInfo[][];\n\nexport type AsyncArrayExtractor = (textArr: string[]) => Promise<EntityInfo[][]>;\n\nexport interface ExtractorInterface {\n  extract: AsyncSingleExtractor;\n  extractArray?: AsyncArrayExtractor;\n}\n\nexport type ExtractorType = SingleExtractor | ExtractorInterface;\n\nexport type FinderCallback = (node: Node) => boolean;\n\nexport type FinderPattern = FinderCallback | string;\n\nconst defaultFinderCallback: FinderCallback = (node: Node) => true;\n\nexport function testNode(pattern: FinderPattern, node: Node): boolean {\n  if (_.isFunction(pattern)) {\n    return (<FinderCallback> pattern)(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\nexport function find(node: Node, pattern: FinderPattern = defaultFinderCallback, result: Node[] = []): Node[] {\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n  if (!_.isEmpty(node.children)) {\n    for (const childNode of node.children) {\n      find(childNode, pattern, result);\n    }\n  }\n  return result;\n}\n\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\nexport function findOne(node: Node, pattern: FinderPattern = defaultFinderCallback): Node | undefined {\n  if (testNode(pattern, node)) {\n    return node;\n  }\n  if (!_.isEmpty(node.children)) {\n    for (const childNode of node.children) {\n      const result = findOne(childNode, pattern);\n      if (result) {\n        return result;\n      }\n    };\n  }\n  return undefined;\n}\n\nexport function parseJson(json: JsonNode) {\n  const node = Node.create(json.type, json.name, {\n    id: json.id,\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content,\n  });\n  if (json.children) {\n    _.each(json.children, childData => {\n      node.appendChild(parseJson(childData));\n    });\n  }\n  node.normalize();\n  return node;\n}\n\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\nexport function toJsonMap(map?: KeyValueMap, options: JsonOptions = {}): KeyValueMap | undefined{\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n  return _.mapValues(map, (value) => {\n    if (value instanceof Node) {\n      return value.toJSON(options);\n    }\n    return value;\n  })\n}\n\nexport function parseJsonMap(json?: KeyValueMap): KeyValueMap | undefined {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n  return _.mapValues(json, (value) => {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n    return parseValue(value);\n  });\n}\n\nexport type KeyValueMap = {[key: string]: any};\n\nexport interface NodeProps {\n  id?: string;\n  source?: string;\n  start?: number;\n  end?: number;\n  states?: KeyValueMap;\n  attributes?: KeyValueMap;\n  metadata?: KeyValueMap;\n  labels?: string[];\n  parent?: Node;\n  content?: string;\n  text?: string;\n}\n\nexport interface NodeSelector {\n  type?: NodeType;\n  name?: string;\n  text?: string;\n  source?: string;\n  label?: string;\n}\n\nexport interface EntityInfo {\n  type: string;\n  start: number;\n  end: number;\n  text?: string;\n  data?: any;\n}\n\nexport interface JsonOptions {\n  position?: boolean;\n  textPosition?: boolean;\n  internalId?: boolean;\n}\n\nexport interface SourceMapRange {\n  start: string;\n  end: string;\n}\n\nexport interface JsonNode {\n  id?: string;\n  type: NodeType;\n  name?: string;\n  content?: string;\n  attributes?: KeyValueMap;\n  metadata?: KeyValueMap;\n  labels?: string[];\n  position?: SourceMapRange;\n  textPosition?: SourceMapRange;\n  children?: JsonNode[];\n}\n\nexport interface NodeRange {\n  startNode: Node,\n  startOffset: number,\n  endNode: Node,\n  endOffset: number,\n}\n\n/**\n * AST node class\n * @class\n */\nclass Node {\n\n  static Types = NodeType;\n\n  /**\n   * Create node, shortcut for constructor \n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n  static create(type: NodeType, name?: string, props?: NodeProps) {\n    return new Node(type, name, props);\n  }\n\n  /**\n   * Create paragraph node\n   * @param [props]\n   */\n  static createParagraph(props?: NodeProps) {\n    return new Node(NodeType.PARAGRAPH, undefined, props);\n  }\n\n  /**\n   * Create root node\n   * @param [props]\n   */\n  static createRoot(props?: NodeProps) {\n    return new Node(NodeType.ROOT, undefined, props);\n  }\n\n  /**\n   * Create text node\n   * @param [props]\n   */\n  static createText(content: string, props?: NodeProps) {\n    return new Node(NodeType.TEXT, undefined, { ...props, content });\n  }\n  \n  /**\n   * Create a common tag\n   * @param tagName Tag name, e.g. `'BLOCK'`, `'INLINE'`, `'SENTENCE'`\n   * @param [props]\n   */\n  static createTag(tagName: string, props?: NodeProps) {\n    return new Node(NodeType.TAG, tagName, props);\n  }\n  \n  /**\n   * Create block tag\n   * @param [props]\n   */\n  static createBlock(props?: NodeProps) {\n    return new Node(NodeType.TAG, 'BLOCK', props);\n  }\n\n  /**\n   * Create inline block tag\n   * @param [props]\n   */\n  static createInlineBlock(props?: NodeProps) {\n    return new Node(NodeType.TAG, 'INLINE', props);\n  }\n\n  /**\n   * Create node instance from ZAML source\n   * @param source \n   */\n  static fromSource(source: string): Node {\n    return parse(source);\n  }\n\n  /**\n   * Create node from json serializable data\n   * @param json \n   */\n  static fromJSON(json: JsonNode) {\n    return parseJson(json)\n  }\n\n  /**\n   * Creating fragment node\n   */\n  static createFragment() {\n    return Node.create(NodeType.FRAGMENT);\n  }\n\n  /**\n   * Check if a node is valid\n   * @param node \n   */\n  static validNode(node: any) {\n    if (!(node instanceof Node)) {\n      throw new TypeError('invalid node');\n    }\n  }\n\n  /**\n   * Check if a node could be parent\n   * @param node \n   */\n  static validParent(node: any) {\n    if (!_.isArray(node.children)) {\n      throw new Error('node is not a valid parent');\n    }\n  }\n\n  /**\n   * Check if a node could be parent\n   * @param node \n   */\n  static validChild(node: any) {\n    if (!node.parent) {\n      throw new Error('node is not a valid child');\n    }\n  }\n\n  static validTreeRule(parent: Node, child: Node) {\n    const p = parent.commonDescriptor;\n    const c = child.commonDescriptor;\n    const allowed = TreeRules[p];\n    if (allowed[0] !== Descriptor.ANY || !allowed.includes(c)) {\n      throw new Error(`can not add ${c} as child of ${p}`);\n    }\n  }\n\n  static findCommonAncestor(n1: Node, n2: Node): { ancestor?: Node, paths: [Node[], Node[]]} | undefined {\n    const path1 = n1.path;\n    const path2 = n2.path;\n    let ancestor: Node | undefined;\n    while (path1.length > 0 && path2.length > 0) {\n      if (_.first(path1) !== _.first(path2)) {\n        break;\n      }\n      ancestor = path1.shift();\n      path2.shift();\n    }\n    if (!ancestor) {\n      return undefined;\n    }\n    return {\n      ancestor,\n      paths: [path1, path2],\n    };\n  }\n\n  /**\n   * Find the common ancestor of the range, and creates a wrapping block (or tag) with the nodes\n   * within the range in it.\n   * \n   * If the range is within a block (BLOCK tag or paragraph), a inline tag is created, otherwise\n   * a BLOCK tag is created.\n   * \n   * If a BLOCK tag is used, `startOffset` and `endOffset` will be ignored, to avoid block overlap.\n   * \n   * If either `startNode` or `endNode` is not direct child of common ancestor nor the node is not\n   * sided aligned with the direct child of the ancestor, text offset will be ignored to avoid\n   * split of tags or entity.\n   * \n   * @param range A range object which contains start and end node, alone with their text offset\n   * @param props Custom tag props\n   * @param tagName If inline tag is needed, specify the tag name instead of default `'INLINE'`\n   */\n  static createBlockByRange(range: NodeRange, tagName: string = 'INLINE', props?: NodeProps) {\n    const { startNode, startOffset, endNode, endOffset } = range;\n    if (!_.isNumber(startOffset) || !_.isNumber(endOffset)) {\n      throw new TypeError('range offset must be number');\n    }\n    if (!startNode.isText || !endNode.isText) {\n      throw new TypeError('range node must be text');\n    }\n    if (!startNode.content || !endNode.content) {\n      throw new Error('invalid text node');\n    }\n    if (startNode === endNode) {\n      if (startOffset < 0 || startOffset > startNode.content.length ||\n        endOffset < 0 || endOffset > startNode.content.length) {\n        throw new RangeError('sub text out of range');\n      }\n      if (!startNode.parent) {\n        throw new Error('can not create block on isolated text node');\n      }\n      const { parent } = startNode;\n      const fragment = Node.createFragment();\n      const block = Node.createTag(tagName, {\n        ...props,\n        text: startNode.content.substring(startOffset, endOffset),\n      });\n      if (startOffset > 0) {\n        fragment.appendText(startNode.content.substring(0, startOffset));\n      }\n      fragment.appendChild(block)\n      if (endOffset < startNode.content.length) {\n        fragment.appendText(startNode.content.substring(endOffset));\n      }\n      parent.insertBefore(fragment, startNode);\n      parent.removeChild(startNode);\n      return block;\n    } else {\n      const result = Node.findCommonAncestor(startNode, endNode);\n      if (!result || !result.ancestor) return undefined;\n      const { ancestor, paths } = result;\n      let baseStartNode = paths[0][0];\n      let baseEndNode = paths[1][0];\n      const _startIndex = ancestor.children.indexOf(baseStartNode);\n      const _endIndex = ancestor.children.indexOf(baseEndNode);\n      const [startIndex, endIndex] = [_startIndex, _endIndex].sort();\n      if (_startIndex !== startIndex) {\n        [baseStartNode, baseEndNode] = [baseEndNode, baseStartNode];\n      }\n      const fragment = ancestor.extractNodes(startIndex, endIndex + 1);\n      const isStartSided = startNode.isSidedDescendantOf(baseStartNode, 'start') && startOffset === 0;\n      const isEndSided = endNode.isSidedDescendantOf(baseEndNode, 'end') && endOffset === endNode.content.length;\n      const foundBlock = ancestor.findOne(n => n.isBlock);\n      const hasBlock = foundBlock && foundBlock !== ancestor;\n      if (!hasBlock && (\n        (paths[0].length === 1 || isStartSided) ||\n        (paths[1].length === 1 || isEndSided)\n      )) {\n        const inserting = Node.createFragment();\n        const startText = startNode.content;\n        if (startOffset > 0) {\n          baseStartNode.content = startText.substring(startOffset);\n          inserting.appendText(startText.substring(0, startOffset));\n        }\n        const block = Node.createTag(tagName, props);\n        block.appendChild(fragment);\n        inserting.appendChild(block);\n        const endText = endNode.content;\n        if (endOffset < endNode.content.length) {\n          baseEndNode.content = endText.substring(0, endOffset);\n          inserting.appendText(endText.substring(endOffset));\n        }\n        ancestor.insertAt(inserting, startIndex);\n        return block;\n      } else {\n        const block = Node.createBlock(props);\n        ancestor.insertAt(block, startIndex);\n        block.appendChild(fragment);\n        return block;\n      }\n    }\n  }\n\n  private _source?: string;\n  public id: string = '';\n  public type: NodeType;\n  public name?: string;\n  public start: number = -1;\n  public end: number = -1;\n  public textStart: number = -1;\n  public textEnd: number = -1;\n  public states: KeyValueMap;\n  public attributes: KeyValueMap;\n  public metadata: KeyValueMap;\n  public labels: string[];\n  public parent?: Node;\n  public content?: string;\n  public text?: string = '';\n  public children: Node[];\n\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n  constructor(type: NodeType, name?: string, props: NodeProps = {}) {\n    let {\n      id,\n      source = '',\n      start = -1,\n      end = -1,\n      states,\n      attributes = {},\n      metadata = {},\n      labels = [],\n      parent,\n      content = '',\n      text = '',\n    } = props;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(`invalid node type ${type}`);\n    }\n\n    this.id = id || nanoid();\n    this.states = states || {};\n    this.type = type;\n    this.name = undefined;\n    this.start = start;\n    this.end = end;\n    this.textStart = -1;\n    this.textEnd = -1;\n    this.parent = parent;\n    this._source = undefined;\n    this.content = undefined;\n    this.children = [];\n    this.labels = [];\n    this.attributes = {};\n    this.metadata = {};\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n    \n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n\n  /**\n   * Get a short descriptor to identify node's type and basic information\n   */\n  get descriptor() {\n    if (this.isEntity || this.isTag || this.isText) {\n      return `${this.openDescriptorStart}${this.openDescriptorEnd}`;\n    } else {\n      return this.type;\n    }\n  }\n\n  /**\n   * Get descriptor ignoring name difference\n   */\n  get commonDescriptor(): Descriptor {\n    if (this.isRoot) {\n      return Descriptor.ROOT\n    } else if (this.isBlockTag) {\n      return Descriptor.BLOCK;\n    } else if (this.isParagraph) {\n      return Descriptor.PARAGRAPH;\n    } else if (this.isInlineBlock) {\n      return Descriptor.INLINE;\n    } else if (this.isEntity) {\n      return Descriptor.ENTITY;\n    } else if (this.isText) {\n      return Descriptor.TEXT;\n    } else {\n      return Descriptor.ANY;\n    }\n  }\n\n  get openDescriptorStart() {\n    switch (this.type) {\n      case NodeType.ENTITY:\n        return `[${this.name}`;\n      case NodeType.TAG:\n        return `{${this.name}`;\n      case NodeType.TEXT:\n        return '(text';\n      default:\n        return `<${this.type}`;\n    }\n  }\n\n  get openDescriptorEnd() {\n    switch (this.type) {\n      case NodeType.ENTITY:\n        return `]`;\n      case NodeType.TAG:\n        return `}`;\n      case NodeType.TEXT:\n        return '';\n      default:\n        return '>';\n    }\n  }\n\n  get closingDescriptor() {\n    switch (this.type) {\n      case NodeType.ENTITY:\n        return `[/${this.name}]`;\n      case NodeType.TAG:\n        return `{/${this.name}}`;\n      case NodeType.TEXT:\n        return ')';\n      default:\n        return `</${this.type}>`;\n    }\n  }\n\n  get selector() {\n    let selector = this.descriptor;\n    if (this.parent) {\n      selector = `${this.descriptor}[${this.childIndex}]`;\n    }\n    return selector;\n  }\n\n  get rootSelector() {\n    if (!this.parent) {\n      return this.selector;\n    }\n    const selectors = this.path.map(node => node.selector);\n    return selectors.join(' > ');\n  }\n\n  /**\n   * Check if the node is root\n   */\n  get isRoot(): boolean {\n    return this.type === NodeType.ROOT;\n  }\n\n  /**\n   * Check if the node is paragraph\n   */\n  get isParagraph() : boolean {\n    return this.type === NodeType.PARAGRAPH;\n  }\n\n  /**\n   * Check if the node is tag\n   */\n  get isTag() {\n    return this.type === NodeType.TAG;\n  }\n\n  /**\n   * Check if the node is entity\n   */\n  get isEntity() {\n    return this.type === NodeType.ENTITY;\n  }\n\n  /**\n   * Check if the node is text\n   */\n  get isText() {\n    return this.type === NodeType.TEXT;\n  }\n\n  /**\n   * Check if the node is text and not wrapping by entity\n   */\n  get isPlainText() {\n    return this.type === NodeType.TEXT && (!this.parent || this.parent.type !== NodeType.ENTITY);\n  }\n\n  /**\n   * Check if the node is wrapping tag\n   */\n  get isWrappingTag() {\n    return this.isTag && WrappingTags.includes(<string> this.name);\n  }\n\n  /**\n   * Check if the node is block tag\n   */\n  get isBlockTag() {\n    return this.isTag && BlockTags.includes(<string> this.name);\n  }\n\n  /**\n   * Check if the node is simple block or inline block\n   */\n  get isSimpleTag() {\n    return this.isTag && ['BLOCK', 'INLINE'].includes(<string> this.name);\n  }\n\n  /**\n   * Property indicates if the node is a block (wrapping other nodes)\n   */\n  get isBlock() {\n    const { type, name } = this;\n    return BlockNodeTypes.includes(type) || this.isBlockTag;\n  }\n\n  /**\n   * If node is inline block\n   */\n  get isInlineBlock() {\n    return this.isTag && !this.isBlockTag;\n  }\n\n  /**\n   * Get parent node, alias for node.parent\n   */\n  get parentNode() {\n    return this.parent;\n  }\n\n  /**\n   * Get child nodes, alias for node.children\n   */\n  get childNodes() {\n    return this.children;\n  }\n\n  /**\n   * Get source code of the node\n   */\n  get source(): string {\n    if (this.type === NodeType.ROOT) {\n      return this._source || '';\n    }\n    const rootNode = this.getRootNode();\n    if (!rootNode) {\n      throw new Error('ROOT node not found');\n    }\n    return rootNode.source.substring(this.start || 0, this.end);\n  }\n\n  /**\n   * Get node inner text\n   */\n  get innerText() {\n    if (this.type === NodeType.TEXT) {\n      return this.content;\n    } else if (this.type === NodeType.ENTITY) {\n      const textNode = this.children[0];\n      return textNode ? textNode.content : '';\n    } else {\n      return this.toString();\n    }\n  }\n\n  /**\n   * Check if the node is the first child of its parent\n   */\n  get isFirstChild() {\n    const { parent } = this;\n    if (!parent) {\n      return false;\n    }\n    return _.first(parent.children) === this;\n  }\n\n  /**\n   * Check if the node is the last child of its parent\n   */\n  get isLastChild() {\n    const { parent } = this;\n    if (!parent) {\n      return false;\n    }\n    return _.last(parent.children) === this;\n  }\n\n  /**\n   * Siblings from same parent\n   */\n  get siblings() {\n    const { parent } = this;\n    if (!parent) {\n      return [this];\n    }\n    return parent.children;\n  }\n\n  /**\n   * Get index of parent children\n   */\n  get childIndex() {\n    const { siblings } = this;\n    return siblings.indexOf(this);\n  }\n\n  /**\n   * Next sibling node\n   */\n  get nextSibling() {\n    if (!this.parent) return undefined;\n    const { childIndex, siblings } = this;\n    return siblings[childIndex + 1] || undefined;\n  }\n\n  /**\n   * Previous sibling node\n   */\n  get previousSibling() {\n    if (!this.parent) return undefined;\n    const { childIndex, siblings } = this;\n    return siblings[childIndex - 1] || undefined;\n  }\n\n  /**\n   * Property indicates if the root is root (which has no children)\n   */\n  getRootNode() {\n    let node: Node = this;\n    while (node.parent) {\n      node = node.parent;\n    }\n    if (node === this) {\n      return undefined;\n    }\n    return node;\n  }\n\n  /**\n   * Check node match the expression\n   * @example\n   * <root>: Root node\n   * <paragraph>: Paragraph node\n   * {BLOCK}: BLOCK tag\n   * {INLINE}: INLINE tag\n   * [PER]: entity\n   * @param expression \n   */\n  is(expression: string) {\n    if (!_.isString(expression)) {\n      throw new TypeError('invalid node descriptor');\n    }\n    let match: RegExpExecArray | null = null;\n    if (match = P_NODE_EXPRESSION.exec(expression)) {\n      return this.type === match[1];\n    } else if (match = P_TAG_EXPRESSION.exec(expression)) {\n      return this.type === NodeType.TAG && this.name === match[1];\n    } else if (match = P_ENTITY_EXPRESSION.exec(expression)) {\n      return this.type === NodeType.ENTITY && this.name === match[1];\n    } else if (match = P_LABEL_EXPRESSION.exec(expression)) {\n      return this.type === NodeType.TAG && this.labels.includes(match[1]);\n    }\n    return false;\n  }\n\n  /**\n   * whether a node is a descendant of a given node\n   * @param node \n   */\n  contains(node: Node) {\n    Node.validNode(node);\n    while (node) {\n      if (node === this) {\n        return true;\n      }\n      if (!node.parent) {\n        return false;\n      }\n      node = node.parent;\n    }\n    return false;\n  }\n\n  /**\n   * Get a list of ancestors\n   */\n  get path() {\n    const list: Node[] = [];\n    let node: Node | undefined = this;\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  /**\n   * Get the first child of current node\n   */\n  get firstChild() {\n    Node.validParent(this);\n    return _.first(this.children);\n  }\n\n  /**\n   * Get the last child of current node\n   */\n  get lastChild() {\n    Node.validParent(this);\n    return _.last(this.children);\n  }\n\n  /**\n   * Check if this node has any children\n   */\n  hasChild() {\n    return this.children.length > 0;\n  }\n\n  /**\n   * Check if this node is the only child of its parent\n   */\n  get isOnlyChild(): boolean {\n    if (!this.parent) {\n      return false;\n    }\n    return this.parent.children.length === 1;\n  }\n\n  /**\n   * Check if the node is only descendant of another node;\n   * @param ancestor \n   */\n  isOnlyDescendantOf(ancestor: Node): boolean {\n    let node: Node = ancestor;\n    while (node) {\n      if (node.children.length !== 1) {\n        return false;\n      }\n      node = node.children[0];\n      if (node === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the node is only descendant of another node;\n   * @param ancestor \n   */\n  isSidedDescendantOf(ancestor: Node, side: 'start' | 'end'): boolean {\n    let node: Node | undefined = ancestor;\n    while (node) {\n      if (node.children.length === 0) {\n        return false;\n      }\n      node = side === 'start' ? node.firstChild : node.lastChild;\n      if (node === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create a child node\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n  createChild(type: NodeType, name?: string, props?: NodeProps) {\n    const node = new Node(type, name, props);\n    this.appendChild(node);\n    return node;\n  }\n\n  /**\n   * Insert a node at the beginning of the children\n   * @param node \n   */\n  prependChild(node: Node) {\n    return this.insertAt(node, 0);\n  }\n\n  /**\n   * Append a node to children list\n   * @param node \n   */\n  appendChild(node: Node) {\n    return this.insertAt(node, Infinity);\n  }\n\n  /**\n   * Append text node child\n   * @param text \n   * @param [props] \n   */\n  appendText(text: string, props?: NodeProps) {\n    if (this.type === NodeType.TEXT) {\n      this.content = this.content || '';\n      this.content += text;\n      return this;\n    } else {\n      if (this.lastChild && this.lastChild.isText) {\n        this.lastChild.content += text;\n      } else {\n        const child = Node.create(NodeType.TEXT, undefined, { ...props, content: text });\n        this.appendChild(child);\n      }\n    }\n  }\n\n  /**\n   * Add text node child at the beginning\n   * @param text \n   * @param [props] \n   */\n  prependText(text: string, props?: NodeProps) {\n    if (this.type === NodeType.TEXT) {\n      this.content = `${text}${this.content || ''}`;\n      return this;\n    } else {\n      const child = Node.create(NodeType.TEXT, undefined, { ...props, content: text });\n      this.prependChild(child);\n    }\n  }\n\n  /**\n   * Remove node from tree\n   */\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n  }\n\n  /**\n   * Remove one child\n   * @param node\n   */\n  removeChild(child: Node) {\n    _.pull(this.children, child);\n    child.parent = undefined;\n    return child;\n  }\n\n  /**\n   * Remove one child by index\n   * @param index\n   */\n  removeChildAt(index: number) {\n    const child = this.children[index];\n    _.pullAt(this.children, index);\n    child.parent = undefined;\n    return child;\n  }\n\n  /**\n   * Insert a node at specified position\n   * @param node \n   * @param index \n   */\n  insertAt(node: Node, index: number) {\n    if (node.type === NodeType.FRAGMENT) {\n      this.children.splice(index, 0, ...node.children);\n      node.children.forEach(child => {\n        child.parent = this;\n      });\n      node.children = [];\n    } else {\n      this.children.splice(index, 0, node);\n      if (node.parent) {\n        node.parent.removeChild(node);\n      }\n      node.parent = this;\n    }\n    return node;\n  }\n\n  /**\n   * Insert a node before another\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n   * @param node Node to be inserted\n   * @param ref A child node to be referenced\n   */\n  insertBefore(node: Node, ref: Node) {\n    Node.validParent(this);\n    const refIndex = this.children.indexOf(ref);\n    this.insertAt(node, refIndex);\n    return node;\n  }\n\n  /**\n   * Insert a node after another\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n   * @param node Node to be inserted\n   * @param ref A child node to be referenced\n   */\n  insertAfter(node: Node, ref: Node) {\n    Node.validParent(this);\n    const refIndex = this.children.indexOf(ref);\n    this.insertAt(node, refIndex + 1);\n    return node;\n  }\n\n  /**\n   * Replace a child with another node, assuming current node is a parent\n   * @param newChild \n   * @param oldChild \n   * @returns The replaced child\n   */\n  replaceChild(newChild: Node, oldChild: Node) {\n    Node.validParent(this);\n    if (newChild.contains(this)) {\n      throw new TypeError('the new child contains the parent');\n    }\n    if (oldChild.parent !== this) {\n      throw new TypeError('the old child is not a child of this node');\n    }\n    this.insertBefore(newChild, oldChild);\n    this.removeChild(oldChild);\n    return oldChild;\n  }\n\n  /**\n   * Replace current child node with another node, assuming current node is child\n   * @param node Node to be replaced with\n   */\n  replaceWith(node: Node) {\n    Node.validChild(this);\n    if (!this.parent) {\n      throw new Error('can not replace isolated node');\n    }\n    this.parent.replaceChild(node, this);\n    return node;\n  }\n\n  /**\n   * Set single attribute value\n   * @param {string} key Attribute key\n   * @param {any} value Attribute value\n   */\n  setAttribute(key: string, value: any) {\n    _.set(this.attributes, key, value);\n  }\n\n  /**\n   * Set multiple attributes\n   * @param data Key-value pair\n   */\n  setAttributes(data: KeyValueMap) {\n    _.merge(this.attributes, data);\n  }\n\n  /**\n   * Get attribute value\n   * @param key \n   */\n  getAttribute(key: string) {\n    return _.get(this.attributes, key);\n  }\n\n  /**\n   * Check if a specified attribute key exists\n   * @param key \n   */\n  hasAttribute(key: string) {\n    return _.has(this.attributes, key)\n  }\n\n  /**\n   * Remove an attribute\n   * @param {string} key \n   */\n  removeAttribute(key: string) {\n    _.unset(this.attributes, key);\n  }\n\n  /**\n   * Remove all attributes\n   */\n  clearAttributes() {\n    this.attributes = {};\n  }\n\n  /**\n   * Set single metadata value\n   * @param key Key or key-value pair\n   * @param value Metadata value (only when key is string)\n   */\n  setMetadata(key: KeyValueMap): void;\n  setMetadata(key: string, value: any): void;\n  setMetadata(key: string | KeyValueMap, value?: any) {\n    if (_.isString(key)) {\n      _.set(this.metadata, key, value);\n    } else {\n      _.merge(this.metadata, key);\n    }\n  }\n\n  /**\n   * Get metadata value\n   * @param key \n   */\n  getMetadata(key: string) {\n    return _.get(this.metadata, key);\n  }\n\n  /**\n   * Remove a metadata\n   * @param key \n   */\n  removeMetadata(key: string) {\n    _.unset(this.metadata, key);\n  }\n\n  /**\n   * Remove all metadata\n   */\n  clearMetadata() {\n    this.metadata = {};\n  }\n\n  /**\n   * Check if a specified metadata key exists\n   * @param key \n   */\n  hasMetadata(key: string) {\n    return _.has(this.metadata, key)\n  }\n\n  /**\n   * Add label to node\n   * @param label \n   */\n  addLabel(label: string) {\n    if (!_.isString(label)) {\n      throw new TypeError('label must be string');\n    }\n    if (!this.labels.includes(label)) {\n      this.labels.push(label);\n    }\n  }\n\n  /**\n   * Check if the node has specified label\n   * @param label \n   */\n  hasLabel(label: string) {\n    return this.labels.includes(label);\n  }\n\n  /**\n   * Remove label\n   * @param label \n   */\n  removeLabel(label: string) {\n    _.pull(this.labels, label);\n  }\n\n  /**\n   * Remove all labels\n   */\n  clearLabels() {\n    this.labels = [];\n  }\n\n  /**\n   * Rebuild text and source position, in case modification has been applied to node\n   */\n  normalize() {\n    const source = this.toSource();\n    if (this.isRoot) {\n      this._source = source;\n    }\n    this.toString();\n  }\n\n  /**\n   * Get node by id\n   * @param id \n   */\n  getNodeById(id: string) {\n    return findOne(this, node => node.id === id);\n  }\n\n  /**\n   * Find matched descendants recursively\n   * @param selector Node selector object\n   * @param [one] Find the first matched node or a list of node\n   */\n  findBy(selector: NodeSelector = {}, one = false): Node | Node[] | undefined {\n    const { type, name, text, source, label } = selector;\n    const finder = one ? findOne : find;\n    return finder(this, (node: Node) => {\n      let match = true;\n      if (type) {\n        match = match && type === node.type;\n      }\n      if (name) {\n        match = match && name === node.name;\n      }\n      if (text && node.type === NodeType.TEXT && node.content) {\n        if (_.isRegExp(text)) {\n          match = match && !!text.match(node.content);\n        } else if (_.isString(text)) {\n          match = match && node.content.includes(text);\n        } else {\n          throw new TypeError('text filter should be RegExp or string');\n        }\n      }\n      if (source && node._source) {\n        if (_.isRegExp(source)) {\n          match = match && !!source.match(node._source);\n        } else if (_.isString(source)) {\n          match = match && node._source.includes(source);\n        } else {\n          throw new TypeError('source filter should be RegExp or string');\n        }\n      }\n      if (label) {\n        if (_.isArray(label)) {\n          match = match && (_.intersection(this.labels, label).length > 0); \n        } else {\n          match = match && this.labels.includes(label);\n        }\n      }\n      return match;\n    });;\n  }\n\n  /**\n   * Find nodes by selector recursively and return the first one\n   * @param selector \n   */\n  findOneBy(selector: NodeSelector = {}): Node {\n    return <Node> this.findBy(selector, true);\n  }\n\n  /**\n   * Find matched text node by text source range\n   * @param start \n   * @param end \n   */\n  findTextByRange(start: number, end: number): Node | undefined {\n    if (this.textStart === undefined || this.textEnd === undefined) {\n      return undefined;\n    }\n    if (this.textStart <= start && this.textEnd >= end) {\n      if (this.type === NodeType.TEXT) {\n        return this;\n      } else if (this.hasChild()) {\n        for (let i = 0; i < this.children.length; i++) {\n          const child = this.children[i];\n          const match = child.findTextByRange(start, end);\n          if (match) {\n            return match;\n          }\n        };\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Find matched children recursively by callback\n   * @param callback\n   */\n  find(callback: FinderCallback) {\n    return find(this, callback);\n  }\n\n  /**\n   * Find matched children recursively and return the first one\n   * @param callback\n   */\n  findOne(callback: FinderCallback) {\n    return findOne(this, callback);\n  }\n\n  /**\n   * Find all nodes by selector, compared by is()\n   * @param selector \n   */\n  querySelectorAll(selector: string): Node[] {\n    return find(this, selector);\n  }\n  \n  /**\n   * Find nodes by selector and return the first one, compared by is()\n   * @param selector \n   */\n  querySelector(selector: string): Node | undefined {\n    return findOne(this, selector);\n  }\n\n  /**\n   * Split node text into tag wrapped sections, e.g. splitting sentences\n   * \n   * @example \n   * node.splitText('!?.');\n   * @param separator RegExp or character list in string, to split\n   * @param tagName Custom tag name, like `'SENTENCE'`\n   */\n  splitText(separator: RegExp | string, tagName = 'INLINE', props?: NodeProps) {\n    const pattern = separator instanceof RegExp ? separator : new RegExp(`[${_.escapeRegExp(separator)}]`, 'g');\n    const list = this.find(node => node.isParagraph || node.isInlineBlock);\n    list.forEach(node => {\n      const text = node.toString();\n      let pos = 0;\n      let lastPos = 0;\n      pattern.lastIndex = 0;\n      while (pattern.exec(text)) {\n        // recreate text offset for each node\n        node.toString();\n        pos = pattern.lastIndex;\n        const textNodes = node.children.filter(n => n.isText);\n        const startNode = textNodes.find(tn => tn.textStart <= lastPos && tn.textEnd > lastPos);\n        const endNode = textNodes.find(tn => tn.textStart < pos && tn.textEnd >= pos);\n        if (!startNode || !endNode) {\n          break;\n        }\n        const range = {\n          startNode,\n          startOffset: lastPos - startNode.textStart,\n          endNode,\n          endOffset: pos - endNode.textStart,\n        }\n        Node.createBlockByRange(range, tagName, props);\n        lastPos = pos;\n      }\n    });\n  }\n\n  /**\n   * Merge neighbor text nodes\n   */\n  mergeText() {\n    let stack: Node[] = [];\n    const childLength = this.children.length;\n    this.children.forEach((child, i) => {\n      if (child.isText) {\n        stack.push(child);\n      }\n      if (!child.isText || i === childLength - 1) {\n        if (stack.length > 1) {\n          const merged = stack.map(child => child.content).join('');\n          const textNode = Node.createText(merged);\n          this.insertBefore(textNode, stack[0]);\n          let n: Node | undefined;\n          while (n = stack.shift()) {\n            this.removeChild(n);\n          }\n        }\n        stack = [];\n      }\n    });\n  }\n\n  extractNodes(startIndex: number, endIndex: number) {\n    const fragment = Node.createFragment();\n    if (\n      startIndex < 0 || startIndex >= this.children.length ||\n      endIndex < 0 || endIndex > this.children.length\n    ) {\n      throw new RangeError('invalid range of children');\n    }\n    const nodes = this.children.slice(startIndex, endIndex);\n    nodes.forEach(child => {\n      fragment.appendChild(child);\n    })\n    return fragment;\n  }\n\n  /**\n   * Remove a element and move its children to its parent\n   */\n  flatten() {\n    if (!this.parent) {\n      return;\n    }\n    const { parent } = this;\n    const fragment = this.extractNodes(0, this.children.length);\n    parent.insertBefore(fragment, this);\n    parent.removeChild(this);\n    parent.mergeText();\n    return parent;\n  }\n\n  /**\n   * Process text node in current node and parse entities\n   */\n  createEntities(items: EntityInfo[]) {\n    const entityNodes: Node[] = [];\n    if (this.type !== NodeType.TEXT) {\n      console.warn('createEntities() should exec only on text node');\n    }\n    if (!this.content || _.isEmpty(items)) {\n      return entityNodes;\n    }\n    const text = this.content;\n    items = _.sortBy(items, ['start']);\n    const fragment = Node.createFragment();\n    let lastPos = 0;\n    items.forEach(item => {\n      if (item.start >= item.end || item.start < lastPos) {\n        return;\n      }\n      if (item.start > lastPos) {\n        fragment.appendText(text.substring(lastPos, item.start));\n      }\n      const entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n        attributes: item.data,\n      });\n      entityNode.appendText(text.substring(item.start, item.end));\n      entityNodes.push(entityNode);\n      lastPos = item.end;\n    });\n    if (lastPos < text.length) {\n      fragment.appendText(text.substr(lastPos));\n    }\n    this.replaceWith(fragment);\n    return entityNodes;\n  }\n\n  /**\n   * Create entity nodes based on text source position\n   * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n   */\n  createEntitiesFromText(entities: EntityInfo[]) {\n    this.toString();\n    const cache: Map<Node, EntityInfo[]> = new Map();\n    _.each(entities, (item: EntityInfo) => {\n      const textNode = this.findTextByRange(item.start, item.end);\n      if (textNode === undefined) {\n        return;\n      }\n      if (cache.has(textNode)) {\n        (<EntityInfo[]> cache.get(textNode)).push(item);\n      } else {\n        cache.set(textNode, [item]);\n      }\n    });\n    cache.forEach((items, textNode) => {\n      textNode.createEntities(items.map(item => ({\n        ...item,\n        start: item.start - (textNode.textStart || 0),\n        end: item.end - (textNode.textStart || 0),\n      })));\n    });\n  }\n\n  /**\n   * Extract entities from text node\n   */\n  extractEntities(extractor: SingleExtractor): Promise<void>;\n  extractEntities(extractor: ExtractorInterface): Promise<void>;\n  async extractEntities(extractor: ExtractorType) {\n    const nodeList = this.find((node: Node) => {\n      return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n    });\n    const textList: string[] = nodeList.map(node => node.content as string);\n    let result: EntityInfo[][];\n    if (_.isFunction(extractor)) {\n      result = await Promise.all(textList.map(text => extractor(text)));\n    } else if (_.isFunction((extractor as ExtractorInterface).extractArray)) {\n      result = await ((extractor as ExtractorInterface).extractArray as AsyncArrayExtractor)(textList);\n    } else if (_.isFunction((extractor as ExtractorInterface).extract)) {\n      result = await Promise.all(textList.map(text => (extractor as ExtractorInterface).extract(text)));\n    } else {\n      throw new TypeError('invalid extractor');\n    }\n    nodeList.forEach((node, i) => {\n      const items = result[i];\n      if (!_.isArray(items)) {\n        throw new Error('invalid extraction result');\n      }\n      node.createEntities(items);\n    });\n  }\n\n  /**\n   * Remove wrapping entity and put text back\n   */\n  removeEntity() {\n    if (this.type !== NodeType.ENTITY || !this.firstChild || this.firstChild.type !== NodeType.TEXT) {\n      throw new Error('invalid entity');\n    };\n    if (!this.parent) {\n      throw new Error('can not remove isolated entity');\n    }\n    let text = this.firstChild.content || '';\n    let textNode: Node | undefined;\n    const { parent, previousSibling, nextSibling } = this;\n    if (previousSibling && previousSibling.isText) {\n      textNode = previousSibling;\n    }\n    if (textNode) {\n      textNode.appendText(text);\n    } else {\n      textNode = Node.create(NodeType.TEXT, undefined, { content: text });\n      parent.insertBefore(textNode, this);\n    }\n    if (nextSibling && nextSibling.isText) {\n      textNode.appendText(nextSibling.content || '');\n      parent.removeChild(nextSibling);\n    }\n    parent.removeChild(this);\n    return textNode;\n  }\n\n  /**\n   * Build plain text of the node (stripping tags & entities)\n   * @param [options]\n   */\n  toString(options?: StringifyOptions) {\n    return stringify(this, options);\n  }\n\n  /**\n   * Build source code of the node\n   * @param [options]\n   */\n  toSource(options: StringifyOptions = {}) {\n    return stringify(this, { ...options, toSource: true });\n  }\n\n  /**\n   * Convert node to JSON serializable object\n   * @param options \n   */\n  toJSON(options: JsonOptions = {}): JsonNode {\n    const {\n      position = false,\n      textPosition = false,\n      internalId = false,\n    } = options;\n    return <any> _.omitBy({\n      id: internalId ? this.id : undefined,\n      type: this.type,\n      name: this.name,\n      content: this.content,\n      attributes: toJsonMap(this.attributes),\n      metadata: toJsonMap(this.metadata, options),\n      labels: this.labels.length ? this.labels : undefined,\n      position: position ? {\n        start: this.start,\n        end: this.end,\n      } : undefined,\n      textPosition: textPosition ? {\n        start: this.textStart,\n        end: this.textEnd,\n      } : undefined,\n      children: _.isEmpty(this.children) ? undefined : this.children.map(child => child.toJSON(options)),\n    }, _.isUndefined);\n  }\n\n}\n\nexport default Node;\n","import * as _ from 'lodash';\nimport { chalk } from './util';\nimport TextLine from './TextLine';\nimport {\n  P_FULL_WIDTH_CHARACTER\n} from './constants';\n\n// improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\nconst NOT_FOUND = -1;\nconst LINE_BREAKS = /\\r?\\n/g;\n\nexport type TextTester = (text: string) => boolean;\nexport type TextPattern = string | RegExp | TextTester;\n\nexport interface SearchOptions {\n  /** Case insensitive for string pattern */\n  caseInsensitive?: boolean;\n}\n\nexport interface ReadOptions {\n  /** If no matched text is found, read to the end */\n  toEOL?: boolean;\n  /** If read to matched text or to the end of line */\n  toEOF?: boolean;\n  /** Read to end of the matched text */\n  consume?: boolean;\n  /** Read to the matched text, move cursor to the end */\n  skipMatched?: boolean;\n}\n\nexport interface MatchOptions {\n  /** Read to end of the matched text */\n  consume?: boolean;\n  /** Read to the matched text, move cursor to the end */\n  skipMatched?: boolean;\n  /** Case insensitive for string pattern */\n  caseInsensitive?: boolean;\n}\n\nexport interface SourcePosition {\n  ln: number,\n  col: number,\n  pos: number,\n  line: TextLine,\n}\n\nexport type MarkerData = {[key: string]: any};\n\nexport interface MarkerInfo {\n  text: string;\n  position: {\n    start?: number;\n    end?: number;\n  };\n  data: MarkerData;\n}\n\nexport interface Marker {\n  start?: number;\n  end?: number;\n  data?: any;\n}\n\n/**\n * Stream like text string\n * @typicalname stream\n */\nclass TextStream {\n\n  /** Current cursor position */\n  public pos: number;\n\n  /** Original text */\n  public text: string;\n\n  /** Tab size */\n  public tabSize: number;\n\n  /** Text lines */\n  public lines: TextLine[];\n\n  /** Start position of each line */\n  public lineOffsetIndexes: number[] = [];\n\n  /** Markers */\n  public markers: Marker[];\n\n  /** Cursor stack positions */\n  public cursorStack: number[];\n\n  /** Last matched string of methods like eat() match() */\n  public lastMatch: string = '';\n\n  constructor(text: string, tabSize: number = 2) {\n    this.pos = 0;\n\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n    this.text = text;\n\n    /**\n     * @description Tab size\n     */\n    this.tabSize = tabSize;\n\n    /**\n     * @description Lines, separated by line breaks\n     */\n    this.lines = [];\n\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n    this.markers = [];\n\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n    this.cursorStack = [];\n\n    this.init();\n  }\n\n  /**\n   * Prepare line indexes\n   */\n  init() {\n    const lines: TextLine[] = [];\n    let matched;\n    let offset = 0;\n    let ln = 1;\n    LINE_BREAKS.lastIndex = 0;\n    do {\n      matched = LINE_BREAKS.exec(this.text);\n      if (matched) {\n        const length = matched.index - offset;\n        const text = this.text.substr(offset, length);\n        lines.push(new TextLine(lines, text, ln, offset));\n        offset += length + matched[0].length;\n      } else {\n        const length = this.text.length - offset;\n        // process last line without line break symbol\n        if (length > 0) {\n          const text = this.text.substr(offset);\n          lines.push(new TextLine(lines, text, ln, offset));\n        }\n      }\n      ln++;\n    } while (matched);\n    this.lines = lines;\n    this.lineOffsetIndexes = _.map(lines, 'offset');\n  }\n\n  /**\n   * Get line and column position of the cursor\n   * @param pos Cursor position of the text\n   */\n  getPosition(pos?: number): SourcePosition {\n    if (_.isUndefined(pos)) {\n      pos = this.pos;\n    }\n    const lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n    const line = this.lines[lineIndex];\n    if (!line) {\n      throw new Error('cursor position is invalid');\n    }\n    const { ln, offset } = line;\n    const col = pos - offset + 1;\n    return {\n      ln,\n      col,\n      pos,\n      line,\n    };\n  }\n\n  /**\n   * Check if cursor is at the start of a line\n   * @param [trimSpaces] Whether to trim starting spaces\n   */\n  sol(trimSpaces = false) {\n    const { col, line } = this.getPosition();\n    if (col - 1 === 0) {\n      return true;\n    }\n    if (!trimSpaces) {\n      return false;\n    }\n    const { length } = _.trimStart(line.text);\n    return col - 1 <= line.length - length;\n  }\n\n  /**\n   * Check if cursor is at the end of a line\n   * @param [trimSpaces] Whether to trim ending spaces\n   */\n  eol(trimSpaces = false): boolean {\n    const { col, line } = this.getPosition();\n    if (col - 1 === line.length) {\n      return true;\n    }\n    if (!trimSpaces) {\n      return false;\n    }\n    const { length } = _.trimEnd(line.text);\n    return col - 1 >= length;\n  }\n\n  /**\n   * Check if cursor is at the end of whole text\n   * @param {number} [pos] \n   */\n  eof(pos?: number): boolean {\n    if (_.isUndefined(pos)) {\n      pos = this.pos;\n    }\n    return pos >= this.text.length;\n  }\n\n  /**\n   * Get one next char, but keep the cursor position (if available)\n   * @returns The next char\n   */\n  peek(): string {\n    return this.text.charAt(this.pos);\n  }\n\n  /**\n   * Get one next char, and move cursor forward (if available)\n   * @returns The next char\n   */\n  next(): string {\n    if (this.pos < this.text.length) {\n      return this.text.charAt(this.pos++);\n    }\n    return '';\n  }\n\n  /**\n   * Consumes one char if the next char fitting the pattern\n   * @param pattern \n   * @returns The char been eaten\n   */\n  eat(pattern: TextPattern): string {\n    const ch = this.text.charAt(this.pos) || '';\n    let ok;\n    if (_.isUndefined(ch)) {\n      ok = false;\n    } else if (_.isString(pattern)) {\n      ok = ch === pattern;\n    } else if (_.isRegExp(pattern)) {\n      pattern.lastIndex = 0;\n      ok = pattern.test(ch);\n    } else if (_.isFunction(pattern)) {\n      ok = pattern(ch);\n    }\n    if (ok) {\n      this.lastMatch = ch;\n      ++this.pos;\n      return ch;\n    }\n    return '';\n  }\n\n  /**\n   * Consumes chars while fitting the pattern\n   * @param match \n   * @returns Eaten characters\n   */\n  eatWhile(pattern: TextPattern): string {\n    const start = this.pos;\n    let chr;\n    let string = '';\n    do {\n      chr = this.eat(pattern);\n      if (chr) {\n        string += chr;\n      }\n    } while (chr && !this.eof());\n    return string;\n  }\n\n  /**\n   * Consumes chars until the first char not fitting the pattern\n   * @param pattern char or pattern\n   * @returns eaten characters\n   */\n  eatUntil(pattern: TextPattern): string {\n    const start = this.pos;\n    let ch;\n    let string = '';\n    do {\n      ch = this.eat(pattern);\n      if (!ch) {\n        string += this.peek();\n        this.pos++;\n      } else {\n        this.pos--;\n      }\n    } while (!ch && !this.eof());\n    return string;\n  }\n\n  /**\n   * Consumes spaces\n   * @returns {boolean} If any space has been consumed\n   */\n  eatSpaces() {\n    let start = this.pos\n    while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n      this.pos++;\n    }\n    return this.pos > start;\n  }\n\n  /**\n   * Find position of matched text to the pattern\n   * @param pattern \n   * @param options\n   */\n  search(pattern: TextPattern, options: SearchOptions = {}) {\n    const { caseInsensitive } = options;\n    let index = NOT_FOUND;\n    let length = 0;\n    let matched = '';\n    if (typeof pattern === 'string') {\n      if (caseInsensitive) {\n        pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n      } else {\n        index = this.text.indexOf(pattern, this.pos);\n        if (index !== NOT_FOUND) {\n          matched = pattern;\n        }\n      }\n    }\n    if (pattern instanceof RegExp) {\n      pattern.lastIndex = this.pos;\n      const result = pattern.exec(this.text);\n      if (result) {\n        index = result.index;\n        matched = result[0];\n      } else {\n        index = NOT_FOUND;\n      }\n    }\n    ({ length } = matched);\n    return {\n      index,\n      length,\n      matched,\n    };\n  }\n\n  /**\n   * Read n chars after current cursor\n   * @param [n] Number of chars to read\n   */\n  read(n = 1): string {\n    const left = this.text.length - this.pos;\n    if (left <= 0) {\n      return '';\n    } else if (left < n) {\n      n = left;\n    }\n    const result = this.text.substr(this.pos, n);\n    this.pos += n;\n    return result;\n  }\n\n  /**\n   * Read to text or pattern\n   * @param pattern \n   * @param [options]\n   * @returns Sub-text after current cursor and before (or contains) matched text\n   */\n  readTo(pattern: TextPattern, options: ReadOptions = {}): string {\n    const {\n      toEOL = false,\n      toEOF = false,\n      consume = false,\n      skipMatched = false,\n    } = options;\n    const start = this.pos;\n    let { index, length } = this.search(pattern);\n    let match = '';\n    let end = -1;\n    if (toEOL) {\n      const { line } = this.getPosition();\n      end = line.offset + line.length;\n    } else if (toEOF) {\n      end = this.text.length;\n    }\n    if (index !== NOT_FOUND) {\n      if (toEOL || toEOF) {\n        if (index < end) {\n          end = index;\n        } else {\n          length = 0;\n        }\n      } else {\n        end = index;\n      }\n    }\n    if (end !== -1) {\n      this.pos = end;\n      if (consume) {\n        end += length;\n        this.pos = end;\n      } else if (skipMatched) {\n        this.pos += length;\n      }\n      match = this.text.substring(start, end);\n    }\n    this.lastMatch = match;\n    return match;\n  }\n\n  /**\n   * Read to pattern (contains the matched text)\n   * @param {} pattern Text to find or pattern\n   * @param {object} options Match options\n   * @returns {string} Sub-text after current cursor and until the end of matched text\n   */\n  readOver(pattern: TextPattern, options: ReadOptions = {}) {\n    return this.readTo(pattern, {...options, consume: true });\n  }\n\n  /**\n   * Read one line\n   * @returns {string} Text containing one line (not including line break)\n   */\n  readLine(): string {\n    const { line } = this.getPosition();\n    const nextLine = line.next();\n    if (this.eof()) {\n      return '';\n    }\n    if (nextLine) {\n      this.pos = nextLine.offset;\n      return line.text;\n    } else {\n      const length = line.offset + line.length - this.pos;\n      return this.read(length);\n    }\n  }\n\n  /**\n   * Move cursor to end of text\n   */\n  skipToEnd() {\n    this.pos = this.text.length;\n  }\n\n  /**\n   * Skip to the beginning of matched text\n   * @param pattern\n   * @param options\n   */\n  skipTo(pattern: TextPattern, options?: ReadOptions): boolean {\n    const start = this.pos;\n    this.readTo(pattern, options);\n    return start !== this.pos;\n  }\n\n  /**\n   * Skip to the end of matched text\n   * @param pattern\n   */\n  skipOver(pattern: TextPattern, options?: ReadOptions) {\n    const start = this.pos;\n    this.readTo(pattern, { ...options, skipMatched: true });\n    return start !== this.pos;\n  }\n\n  /**\n   * Move cursor back\n   * @param n Steps\n   */\n  backUp(n: number = 1) {\n    this.pos -= n;\n  }\n\n  /**\n   * Check if rest text begins with pattern\n   * @param pattern \n   * @param [options] \n   */\n  match(pattern: TextPattern, options: MatchOptions = {}): string {\n    const { consume = true, caseInsensitive } = options;\n    const { index, length, matched } = this.search(pattern, { caseInsensitive });\n    if (index !== this.pos) {\n      return '';\n    }\n    if (consume) {\n      this.pos += length;\n    }\n    this.lastMatch = matched;\n    return matched;\n  }\n\n  /**\n   * Reset the marker stack\n   */\n  resetMarker() {\n    this.markers = [];\n  }\n\n  /**\n   * Add a marker to stack\n   * @param data\n   * @param start\n   */\n  pushMarker(data: MarkerData, start: number) {\n    if (_.isUndefined(start)) {\n      start = this.pos;\n    }\n    this.markers.push({ data, start });\n  }\n\n  /**\n   * Set data for current marker\n   * @param data\n   */\n  setMarkerData(data: MarkerData) {\n    const marker = _.last(this.markers);\n    if (!marker) return;\n    _.extend(marker.data, data);\n  }\n\n  /**\n   * Get data of current markder\n   */\n  getMarkerData(): MarkerData {\n    const marker = _.last(this.markers);\n    if (!marker) return {};\n    return marker.data;\n  }\n\n  /**\n   * Return a combined structure of text and it's position according to the previously set start\n   * marker\n   * @param [data] Additional data\n   * @param [end] End marker, if not set, previous set value will be used\n   */\n  popMarker(_data: MarkerData = {}, end: number): MarkerInfo | undefined {\n    if (!_.isPlainObject(_data)) {\n      throw new TypeError('invalid data parameter');\n    }\n    if (_.isUndefined(end)) {\n      end = this.pos;\n    }\n    const marker = this.markers.pop();\n    if (!marker) {\n      return undefined;\n    }\n    const { data, start } = marker;\n    return {\n      text: this.text.substring(marker.start || 0, end),\n      position: {\n        start,\n        end,\n      },\n      data: {\n        ...data,\n        ..._data,\n      },\n    };\n  }\n\n  findLine(text: string) {\n    return _.find(this.lines, line => _.trim(line.text) === text);\n  }\n\n  /**\n   * Push current cursor to cursor stack, if new position provided, set current cursor to it\n   * @param [pos] \n   */\n  pushCursor(pos: number) {\n    if (_.isUndefined(pos)) {\n      pos = this.pos;\n    }\n    this.cursorStack.push(this.pos);\n    this.pos = pos;\n  }\n\n  /**\n   * Pop last from cursor stack and set it to current cursor\n   */\n  popCursor() {\n    if (this.cursorStack.length === 0) {\n      throw new Error('out of cursor stack!');\n    }\n    this.pos = <number>this.cursorStack.pop();\n    return this.pos;\n  }\n\n  /**\n   * Debug a single line\n   * @param line \n   * @param numWidth \n   * @param col \n   */\n  debugLine(line: TextLine, numWidth: number, col: number) {\n    let { ln, text } = line;\n    if (_.isUndefined(numWidth)) {\n      numWidth = (ln + '').length;\n    }\n    if (col) {\n      text = text.substring(0, col - 1) + chalk.bgBlue(text.charAt(col - 1)) + text.substring(col);\n    }\n    console.log(`${chalk.blueBright(`${col ? '>' : ' '} ${_.padStart(ln + '', numWidth)} |`)} ${text}`);\n  }\n\n  /**\n   * Debug cursor column position\n   * @param text Text of the line\n   * @param col Cursor position\n   * @param numWidth fixed line number width\n   */\n  debugCursor(text: string, col: number, numWidth: number) {\n    const pos = text.substr(0, col - 1).replace(P_FULL_WIDTH_CHARACTER, 'XX').length;\n    console.log(chalk.blueBright(`  ${_.repeat(' ', numWidth)} | ${_.repeat(' ', pos)}^ ${col}`));\n  }\n\n  /**\n   * Debug current position state, with previous and following lines set by range\n   * @param range \n   */\n  debugState(range = 0) {\n    const { ln, col } = this.getPosition();\n    const lineIndex = ln - 1;\n    const lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n    const numWidth = <number>_.max(lines.map(l => (l.ln + '').length));\n    lines.forEach((line) => {\n      const isCurrent = line.ln === ln;\n      this.debugLine(line, numWidth, isCurrent ? col : 0);\n      if (isCurrent) {\n        this.debugCursor(line.text, col, numWidth);\n      }\n    });\n    console.log();\n  }\n\n}\n\nexport { TextLine };\nexport default TextStream;\n","import { SourcePosition } from \"./TextStream\";\n\nexport default class ParseError extends Error {\n\n  public message: string;\n  public text: string;\n  public from: SourcePosition;\n  public to: SourcePosition;\n  \n  constructor(message: string, text: string, from: SourcePosition, to: SourcePosition) {\n    super(message);\n    this.message = message;\n    this.text = text;\n    this.from = from;\n    this.to = to;\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from '../SourceEditor/SourceEditor';\nimport VisualEditor from '../VisualEditor/VisualEditor';\nimport '@blueprintjs/core/lib/css/blueprint.css';\nimport 'normalize.css/normalize.css';\nimport './Editor.scss';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from '../TreeView/TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  defaultSource: string;\n  className: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  source: string\n  root: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source, { needMetadataMarker: true });\n    (global as any).node = node;\n    console.info('Root node exported as global variable \"node\"', node);\n  } catch(err) {\n    if (err instanceof zaml.ParseError) {\n      const message = `\n        [ParseError]{ERROR.TYPE}: {#MESSAGE ${err.message}}\n\n        #SOURCE\n        content\n\n        from {#POS.START ${err.from.ln}:${err.from.col}} to {#POS.END ${err.to.ln}:${err.to.col}}\n      `;\n      node = zaml.parse(message);\n      const sourceBlock = node.querySelector('#SOURCE');\n      const { text } = err.from.line;\n      if (!sourceBlock) return node;\n      const sourceText = sourceBlock.findOneBy({type: NodeType.TEXT});\n      if (!sourceText) return node;\n      sourceText.content = `${text} `;\n      sourceText.createEntitiesFromText([{\n        type: 'ERROR',\n        start: err.from.col - 1,\n        end: err.to.col - 1,\n      }]);\n    } else {\n      node = zaml.parse(`Error: [${err.message}]{MESSAGE}`);\n      console.error(err);\n    }\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    defaultSource: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    defaultSource: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  public preventSourceChange: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      source: props.defaultSource,\n      root: parse(props.defaultSource),\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n    this.preventSourceChange = false;\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n  }\n\n  componentWillUpdate(nextProps: Props, nextState: State) {\n    if (nextState.selectedNode !== this.state.selectedNode) {\n      console.log('selected node:', nextState.selectedNode);\n    }\n    if (nextState.root !== this.state.root) {\n      console.log('new node:', nextState.root);\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  handleSourceChange(source: string) {\n    if (this.preventSourceChange) return;\n    this.setState({\n      root: parse(source),\n      selectedNode: undefined,\n    });\n  }\n\n  handleNodeChange(root?: zaml.Node, selected?: zaml.Node) {\n    if (!root) return;\n    this.preventSourceChange = true;\n    this.setState({\n      source: root.toSource(),\n      selectedNode: selected,\n    }, () => {\n      this.preventSourceChange = false;\n    });\n  }\n\n  render() {\n    const { source } = this.state;\n    const { root, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={source}\n                height={sourcePaneHeight - 40}\n                onChange={(value: string) => this.handleSourceChange(value)}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  root={root}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onChange={(r?: zaml.Node, n?: zaml.Node) => this.handleNodeChange(r, n)}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  root={root}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                  onChange={n => this.handleNodeChange(root, n)}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref9 = /*#__PURE__*/React.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgLogo = function SvgLogo(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\",\n    ref: svgRef\n  }, props), title === undefined ? _ref2 : title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9);\n};\n\nvar ForwardRef = React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgLogo, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { ForwardRef as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.scss';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            ></span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {node.openDescriptorStart}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {node.openDescriptorEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {node.closingDescriptor}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {node.descriptor}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import React from 'react';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreePropEditor.scss';\nimport TabView from '../Common/TabView';\nimport { KeyValueMap } from '@zaml/parser/typings/Node';\n\ninterface Props {\n  node?: zaml.Node;\n  onChange: (node: zaml.Node) => void;\n}\n\ninterface State {\n  selectedTab?: string;\n  editingIndex: number;\n  inlineError: string;\n}\n\nenum Tab {\n  Labels = 'Labels',\n  Attributes = 'Attributes',\n  Metadata = 'Metadata',\n}\n\nconst tabs = _.values(Tab);\nconst defaultTab = tabs[0];\nconst defaultEditingIndex = -1;\n\nexport default class TreePropEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.instanceOf(zaml.Node),\n  };\n\n  static defaultProps: Props = {\n    onChange: () => {},\n  };\n\n  state = {\n    selectedTab: defaultTab,\n    editingIndex: defaultEditingIndex,\n    inlineError: '',\n  };\n\n  editingElement: HTMLInputElement | null = null;\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (nextProps.node !== this.props.node) {\n      this.setState({\n        selectedTab: defaultTab,\n        editingIndex: defaultEditingIndex,\n      });\n    }\n  }\n\n  renderValue(value: any) {\n    if (value instanceof zaml.Node) {\n      return value.toSource();\n    } else {\n      return JSON.stringify(value);\n    }\n  }\n\n  renderEmptyTip() {\n    return (\n      <div className=\"select-tip\">Please select a node</div>\n    )\n  }\n\n  renderTabContent() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    if (!node) {\n      return this.renderEmptyTip();\n    }\n    switch(selectedTab) {\n      case Tab.Labels:\n        return this.renderLabelEditor(node);\n      case Tab.Attributes:\n        return this.renderAttributeEditor(node, node.attributes);\n      case Tab.Metadata:\n        return this.renderAttributeEditor(node, node.metadata);\n    }\n  }\n\n  focusEditingElement() {\n    if (this.editingElement) {\n      this.editingElement.focus();\n      this.editingElement.select();\n    }\n  }\n\n  handleLabelEdit(index: number) {\n    this.setState({ editingIndex: index }, () => {\n      this.focusEditingElement();\n    });\n  }\n\n  handleLabelUpdate(label: string) {\n    const { node, onChange } = this.props;\n    const { editingIndex } = this.state;\n    if (!node) return;\n    const originalLabel = node.labels[editingIndex] || '';\n    if (label !== originalLabel) {\n      try {\n        zaml.parse(`{INLINE #${label}}TESTING{/INLINE}`);\n      } catch (e) {\n        this.setState({ inlineError: 'Invalid label'});\n        return;\n      }\n      if (editingIndex === node.labels.length) {\n        node.addLabel(label);\n      } else {\n        if (label === '' || node.labels.indexOf(label) >= 0) {\n          node.removeLabel(originalLabel);\n        } else {\n          node.labels[editingIndex] = label;\n        }\n      }\n    }\n    this.cancelLabelEditing();\n    onChange(node);\n  }\n\n  cancelLabelEditing() {\n    this.setState({\n      editingIndex: defaultEditingIndex,\n      inlineError: '',\n    });\n  }\n  \n  renderLabelEditor(node: zaml.Node) {\n    const { editingIndex, inlineError } = this.state;\n    const labels = [...node.labels, ''];\n    return (\n      <div className=\"label-editor\">\n        <table>\n          <tbody>\n          {labels.map((label, i) => (\n            <tr\n              key={label}\n              className={classNames({ error: i === editingIndex && inlineError })}\n            >\n              <td className=\"marker\">{label || i === editingIndex ? '#': ''}</td>\n              {i === editingIndex ?\n                <td>\n                  <input\n                    ref={ref => this.editingElement = ref}\n                    defaultValue={label}\n                    onBlur={(event: React.FocusEvent<HTMLInputElement>) => {\n                      this.handleLabelUpdate(event.currentTarget.value);\n                    }}\n                    onKeyDown={(event: React.KeyboardEvent<HTMLInputElement>) => {\n                      if (event.key === 'Enter') {\n                        this.handleLabelUpdate(event.currentTarget.value);\n                      } else if (event.key === 'Escape') {\n                        this.cancelLabelEditing();\n                      }\n                    }}\n                  />\n                </td>\n              :\n                <td\n                  className=\"editable\"\n                  onClick={() => this.handleLabelEdit(i)}\n                >\n                  {label}\n                </td>\n              }\n            </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderAttributeEditor(node: zaml.Node, props: KeyValueMap) {\n    const keys = Object.keys(props);\n    return (\n      <div className=\"attribute-editor\">\n        <table>\n          <tbody>\n            {keys.map(key => (\n              <tr key={key}>\n                <th>{key}</th>\n                <td>{this.renderValue(props[key])}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  render() {\n    const { selectedTab } = this.state;\n    return (\n      <div className=\"zaml-prop-editor\">\n        <TabView\n          tabs={tabs}\n          selectedTab={selectedTab}\n          onTabChange={(tab: string) => this.setState({ selectedTab: tab })}\n        >\n          {this.renderTabContent()}\n        </TabView>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport './TabView.scss';\n\ninterface Props {\n  tabs: string[];\n  selectedTab: string;\n  onTabChange: (tab: string) => void;\n}\n\nexport default class TabView extends React.Component<Props> {\n\n  render() {\n    const { tabs, selectedTab, onTabChange, children } = this.props\n    return (\n      <div className=\"tab-view\">\n        <ul className=\"tabs\">\n          {tabs.map(tab => (\n            <li\n              key={tab}\n              className={classNames('tab', { selected: tab === selectedTab })}\n              onClick={() => onTabChange(tab)}\n            >\n              <span className=\"label\">{tab}</span>\n            </li>\n          ))}\n        </ul>\n        <div className=\"content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePath from './TreePath';\nimport TreeToolbar from './TreeToolbar';\nimport TreePropEditor from './TreePropEditor';\nimport './TreeView.scss';\n\ninterface Props {\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart;\n  expandedNodes: string[];\n}\n\nconst nil = () => {};\n\nexport default class TreeView extends React.Component<Props, State> {\n  static propTypes = {\n    node: PropTypes.shape({}),\n  };\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n    onChange: nil,\n  };\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds)\n      });\n    }\n  }\n\n  render() {\n    const {\n      root,\n      selectedNode,\n      onSelect,\n      onHover,\n      onChange,\n    } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <SplitPane split=\"horizontal\" defaultSize=\"60%\" minSize={200}>\n          <div className=\"tree-container\">\n            <TreeToolbar />\n            <div className=\"tree\">\n              <TreeNode\n                node={root}\n                selectedNode={selectedNode}\n                selectedPart={selectedPart}\n                expandedNodes={expandedNodes}\n                onSelect={onSelect}\n                onSelectPart={p => this.setState({ selectedPart: p })}\n                onMouseEnter={onHover}\n                onMouseOut={() => onHover()}\n                onExpansionChange={(n: zaml.Node, expanded: boolean) =>\n                  this.handleExpansionChange(n, expanded)\n                }\n              />\n            </div>\n            <TreePath selectedNode={selectedNode} onSelect={onSelect} />\n          </div>\n          <TreePropEditor node={selectedNode} onChange={onChange} />\n        </SplitPane>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[{]/, indent: true},\n    {regex: /[}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport './SourceEditor.scss';\nimport './codemirror-mode';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.editor) {\n      if (nextProps.height !== this.props.height && this.editor) {\n        this.editor.setSize(null, nextProps.height);\n      }\n      if (nextProps.value !== this.props.value) {\n        this.editor.setValue(nextProps.value);\n      }\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.scss';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            node-id={node.id}\n            href={node.attributes.url}\n          >\n            <VisualNode\n              node-id={node.children[0].id}\n              {...this.props}\n              node={node.children[0]}\n            />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      'node-id': node.id,\n    }, children);\n  }\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { ContextMenuTarget, Menu, MenuItem, MenuDivider } from \"@blueprintjs/core\"\nimport VisualNode from './VisualNode';\nimport './VisualEditor.scss';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  commonEntityNames?: string[];\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node, selected?: zaml.Node) => void;\n}\n\ninterface State {\n}\n\n@ContextMenuTarget\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    commonEntityNames: PropTypes.arrayOf(PropTypes.string),\n    root: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    commonEntityNames: ['PER', 'ORG', 'LOC', 'DATE'],\n    onSelect: () => {},\n    onChange: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n  }\n\n  handleDoubleClick(event: React.MouseEvent) {\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const domNode = range.startContainer;\n    const text = domNode.textContent;\n    if (!text) return;\n    event.preventDefault();\n    event.stopPropagation();\n    const punctuationPattern = /[!?:;]/g;\n    let startPos = 0;\n    let endPos = text.length;\n    let pos = 0;\n    while (punctuationPattern.exec(text)) {\n      startPos = pos;\n      pos = punctuationPattern.lastIndex;\n      punctuationPattern.lastIndex++;\n      if (pos > range.startOffset) {\n        endPos = pos;\n        break;\n      }\n    }\n    range.setStart(domNode, startPos);\n    range.setEnd(domNode, endPos);\n  }\n\n  handleCreateBlock() {\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const commonNode = this.getNodeByElement(range.commonAncestorContainer as HTMLElement);\n    let startNode = this.getNodeByElement(range.startContainer as HTMLElement);\n    let endNode = this.getNodeByElement(range.endContainer as HTMLElement);\n    if (!commonNode || !startNode || !endNode) {\n      return;\n    }\n    const block = zaml.Node.createBlockByRange({\n      startNode,\n      startOffset: range.startOffset,\n      endNode,\n      endOffset: range.endOffset,\n    });\n    selection.removeAllRanges();\n    onChange(root, block);\n  }\n\n  handleRemoveBlock(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const parent = node.flatten();\n    onChange(root, parent);\n  }\n\n  handleCreateEntity(target: zaml.Node, name: string | null) {\n    if (!name) return;\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0) return;\n    if (selection.anchorNode !== selection.focusNode) {\n      alert('Entity is only allowed in pure text!');\n      return;\n    }\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const entityNodes = target.createEntities([{\n      type: name,\n      start: range.startOffset,\n      end: range.endOffset,\n    }]);\n    onChange(root, entityNodes[0]);\n  }\n\n  handleRemoveEntity(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const textNode = node.removeEntity();\n    onChange(root, textNode);\n  }\n\n  handleInspect(node: zaml.Node) {\n    const { onSelect } = this.props;\n    onSelect(node);\n  }\n\n  handleSplitSentences(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    node.splitText('', 'SENTENCE');\n    onChange(root);\n  }\n\n  getNodeByElement(element: HTMLElement) {\n    const { root } = this.props;\n    if (!root) return undefined;\n    if (element.nodeType === element.TEXT_NODE || element.classList.contains('children')) {\n      if (!element.parentElement) {\n        return undefined;\n      }\n      element = element.parentElement;\n    }\n    const id = element.getAttribute('node-id');\n    if (!id) return undefined;\n    return root.getNodeById(id);\n  }\n\n  render() {\n    const { root: node, selectedNode } = this.props;\n    return (\n      <div\n        className=\"zaml-visual-editor\"\n        onDoubleClick={(event: React.MouseEvent) => this.handleDoubleClick(event)}\n      >\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n        />\n      </div>\n    )\n  }\n\n  renderContextMenu(e: React.MouseEvent<HTMLElement>) {\n    const { commonEntityNames } = this.props;\n    const target = this.getNodeByElement(e.target as HTMLElement);\n    let node = target;\n    if (!target) return;\n    if (target.type === NodeType.TEXT) {\n      node = target.parent;\n    }\n    if (!node) return;\n    const wrapperNode = node;\n    return (\n      <Menu id=\"menu\">\n        <MenuItem disabled text={node.descriptor} />\n        <MenuDivider />\n        <MenuItem\n          text=\"Create Block\"\n          onClick={() => this.handleCreateBlock()}\n        />\n        {node.isWrappingTag &&\n          <MenuItem\n            text=\"Remove Block\"\n            onClick={() => this.handleRemoveBlock(node)}\n          />\n        }\n        {node.isBlock &&\n          <MenuItem\n            text=\"Split Sentences\"\n            onClick={() => this.handleSplitSentences(node)}\n          />\n        }\n        {target.type === NodeType.TEXT && target.parent && target.parent.type !== NodeType.ENTITY &&\n          <MenuItem text=\"Create Entity\">\n            {commonEntityNames && commonEntityNames.map(name => (\n              <MenuItem\n                key={name}\n                text={name}\n                onClick={() => this.handleCreateEntity(target, name)}\n              />\n            ))}\n            <MenuItem\n              text=\"other...\"\n              onClick={() => this.handleCreateEntity(target, prompt('Please input entity type', 'PER'))}\n            />\n          </MenuItem>\n        }\n        {node.type === NodeType.ENTITY &&\n          <MenuItem\n            text=\"Remove Entity\"\n            onClick={() => this.handleRemoveEntity(node)}\n          />\n        }\n        <MenuDivider />\n        <MenuItem\n          text=\"Inspect\"\n          onClick={() => this.handleInspect(wrapperNode)}\n        />\n      </Menu>\n    );\n  }\n}\n"],"sourceRoot":""}