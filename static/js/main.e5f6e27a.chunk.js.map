{"version":3,"sources":["../../zaml-parser/lib/index.js","App.tsx","sample/default.ts","serviceWorker.ts","index.tsx","../../zaml-parser/lib/constants.js","Editor/Pane.tsx","../../zaml-parser/lib/util.js","../../zaml-parser/lib/Node.js","../../zaml-parser/lib/TextStream.js","../../zaml-parser/lib/ParseError.js","Editor/Editor.tsx","Editor/logo.svg","TreeView/TreeNode.tsx","TreeView/TreePathItem.tsx","TreeView/TreePath.tsx","TreeView/TreeToolbar.tsx","TreeView/TreePropEditor.tsx","Common/TabView.tsx","TreeView/TreeView.tsx","SourceEditor/codemirror-mode.ts","SourceEditor/SourceEditor.tsx","VisualEditor/VisualNode.tsx","VisualEditor/VisualEditor.tsx","../../zaml-parser/lib/Tokenizer.js","../../zaml-parser/lib/TextLine.js"],"names":["_interopRequireWildcard","__webpack_require__","_interopRequireDefault","Object","defineProperty","exports","value","tokenize","parse","enumerable","get","_Tokenizer","default","_TextStream","TextLine","_Node","NodeType","_ParseError","text","options","process","console","warn","_default","ParseError","Tokenizer","TextStream","Node","App","react_default","a","createElement","className","Editor","defaultSource","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","PROCESSING_TIMEOUT","P_MARKER","END_MARKERS","START_MARKERS","P_FULL_WIDTH_CHARACTER","P_BOOLEAN_FALSE","P_BOOLEAN_TRUE","P_STRING_LITERAL_UNQUOTED_TESTER","P_STRING_LITERAL_UNQUOTED","P_STRING_LITERAL_QUOTED","P_NUMBER_VALUE","P_NUMBER_LITERAL_FULL","P_NUMBER_LITERAL","P_NUMBER_START","P_DATE_LITERAL","T_STRING_START","P_TAG_NAME_MULTILINE","P_TAG_NAME","P_ATTRIBUTE_LIST_MULTILINE","P_ATTRIBUTE_LIST","P_ATTRIBUTE_NAME_MULTILINE","P_ATTRIBUTE_NAME","P_ATTRIBUTE_ASSIGN","P_LABEL","P_VAR_NAME","P_LABEL_START","P_LIST_SEPARATOR","P_WHITE_SPACES_EXT","P_WHITE_SPACE","P_PARAGRAPH_BREAK","P_SPACE_WRAPPED_LINE_BREAK","P_LINE_BREAK","P_ASSIGN_YAML","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","T_METADATA_FAVORED_ASSIGN","T_PARAGRAPH_BREAK","T_LINE_BREAKS","T_LINE_BREAK","T_ASSIGN_YAML","T_ASSIGN_XML","T_TAG_END","T_TAG_CLOSING","T_TAG_START","T_ENTITY_END","T_ENTITY_START","P_MULTIPLE_LINE_COMMENT","T_SINGLE_LINE_COMMENT","T_METADATA_MARKER","T_TAB","T_SPACE","DEFAULT_INDENT_SPACES","combinePatterns","_","list","map","p","isRegExp","source","escapeRegExp","join","RegExp","concat","Infinity","Pane","props","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","_this$props","title","children","react__WEBPACK_IMPORTED_MODULE_5___default","classNames","React","defaultProps","formatValue","parseValue","P_DATE_FORMAT","test","Date","parseNumber","number","parseFloat","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","spacer","stringify","node","indent","arguments","length","undefined","pos","defaultOptions","space","_constants","simple","toSource","metadataMarker","attributeAsString","opt","defaults","simpleTag","isSimpleTag","labels","keys","attributes","unwrapped","isBlockTag","start","textStart","isText","content","replace","isEntity","child","first","Error","isTag","isBlock","name","listCount","forEach","key","i","isBoolean","each","label","isParagraph","isEmpty","metadata","isWrappingTag","subText","next","nextSibling","trimEnd","isLastChild","end","textEnd","chalk","isAnsiSupported","isChrome","isNode","_slicedToArray2","asString","isDate","toISOString","JSON","isString","includes","charAt","toString","isNumber","isNaN","repeat","release","userAgent","colorful","mapValues","reset","bold","dim","italic","underline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","white","blackBright","grey","gray","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","whiteBright","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgBlackBright","bgGrey","bgGray","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhiteBright","_ref","_ref2","testNode","find","_find","findOne","_findOne","parseJson","toJsonMap","parseJsonMap","TreeRules","WrappingTags","BlockTags","BlockNodeTypes","P_LABEL_EXPRESSION","P_ENTITY_EXPRESSION","P_TAG_EXPRESSION","P_NODE_EXPRESSION","NodeTypes","_TreeRules","_regenerator","_asyncToGenerator2","_toConsumableArray2","_objectSpread2","_classCallCheck2","_createClass2","_defineProperty2","_util","_2","nanoid","values","ROOT","PARAGRAPH","Descriptor","BLOCK","INLINE","ENTITY","TEXT","FRAGMENT","ANY","defaultFinderCallback","pattern","isFunction","is","TypeError","result","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","json","create","type","id","childData","appendChild","normalize","toJSON","isPlainObject","_props$source","_props$start","_props$end","states","_props$attributes","_props$metadata","_props$labels","parent","_props$content","_props$text","_source","appendText","TAG","COMMENT","tagName","isArray","commonDescriptor","c","allowed","n1","n2","ancestor","path1","path","path2","shift","paths","range","startNode","startOffset","endNode","endOffset","RangeError","_parent","fragment","createFragment","block","createTag","substring","insertBefore","removeChild","findCommonAncestor","_paths","baseStartNode","baseEndNode","_startIndex","indexOf","_sort","sort","_sort2","startIndex","endIndex","_fragment","extractNodes","isStartSided","isSidedDescendantOf","isEndSided","foundBlock","n","_block2","createBlock","insertAt","inserting","startText","_block","endText","expression","exec","validNode","side","firstChild","lastChild","prependChild","pull","index","pullAt","_this$children","_this","splice","apply","ref","validParent","refIndex","newChild","oldChild","contains","validChild","replaceChild","set","data","merge","has","unset","isRoot","_this2","selector","one","intersection","findBy","hasChild","findTextByRange","callback","separator","isInlineBlock","lastPos","lastIndex","textNodes","filter","_startNode","tn","_endNode","createBlockByRange","_this3","stack","childLength","merged","textNode","createText","slice","mergeText","items","entityNodes","sortBy","item","entityNode","createChild","substr","replaceWith","entities","_this4","cache","Map","createEntities","_extractEntities","mark","_callee","extractor","nodeList","textList","wrap","_context","prev","Promise","all","sent","extractArray","extract","stop","_x","previousSibling","_options$position","position","_options$textPosition","textPosition","_options$internalId","internalId","omitBy","isUndefined","openDescriptorStart","openDescriptorEnd","descriptor","childIndex","rootNode","getRootNode","last","siblings","unshift","_TextLine","LINE_BREAKS","tabSize","lines","markers","cursorStack","init","matched","offset","ln","_text","_text2","lineOffsetIndexes","lineIndex","sortedLastIndex","line","col","trimSpaces","_this$getPosition","getPosition","trimStart","_this$getPosition2","ok","ch","lastMatch","chr","string","eat","eof","peek","caseInsensitive","left","_options$toEOL","toEOL","_options$toEOF","toEOF","_options$consume","consume","_options$skipMatched","skipMatched","_this$search","search","_line","readTo","nextLine","read","_options$consume2","_this$search2","marker","extend","_data","pop","trim","numWidth","log","padStart","_this$getPosition5","max","min","l","isCurrent","debugLine","debugCursor","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_wrapNativeSuper2","_Error","message","from","to","zaml","needMetadataMarker","global","info","sourceBlock","querySelector","sourceText","findOneBy","createEntitiesFromText","error","state","root","sourcePaneHeight","onResize","throttle","bind","_Users_alvin_Projects_nexushubs_zaml_lang_packages_zaml_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__","preventSourceChange","addEventListener","passive","removeEventListener","nextProps","nextState","selectedNode","height","innerHeight","setState","selected","_this$state","hoveredNode","react__WEBPACK_IMPORTED_MODULE_7___default","href","_svgr_webpack_prettier_svgo_logo_svg__WEBPACK_IMPORTED_MODULE_16__","react_split_pane__WEBPACK_IMPORTED_MODULE_9__","split","defaultSize","minSize","_Pane__WEBPACK_IMPORTED_MODULE_10__","_SourceEditor_SourceEditor__WEBPACK_IMPORTED_MODULE_11__","onChange","handleSourceChange","_VisualEditor_VisualEditor__WEBPACK_IMPORTED_MODULE_12__","onSelect","r","handleNodeChange","_TreeView_TreeView__WEBPACK_IMPORTED_MODULE_17__","onHover","d","__webpack_exports__","SvgComponent","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","_extends","assign","target","prototype","hasOwnProperty","fill","_ref3","_ref4","cx","cy","_ref5","_ref6","x","y","width","rx","ry","_ref7","_ref8","points","data-name","viewBox","NodePart","nil","TreeNode","classCallCheck","possibleConstructorReturn","getPrototypeOf","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","Whole","Header","onClick","event","stopPropagation","commonProps","_onMouseEnter","_onMouseOut","_x2","react","onlyText","node-selected","truncate","Footer","closingDescriptor","TreePathItem","TreePath","buildNodeList","TreePathItem_TreePathItem","TreeToolbar","Tab","TabView","tabs","selectedTab","onTabChange","tab","defaultTab","defaultEditingIndex","TreePropEditor","editingIndex","inlineError","editingElement","renderEmptyTip","Labels","renderLabelEditor","Attributes","renderAttributeEditor","Metadata","focus","select","focusEditingElement","originalLabel","e","addLabel","removeLabel","cancelLabelEditing","toConsumableArray","defaultValue","onBlur","handleLabelUpdate","currentTarget","onKeyDown","handleLabelEdit","renderValue","_this5","TabView_TabView","renderTabContent","TreeView","without","nodeIds","union","index_esm","TreeToolbar_TreeToolbar","TreeNode_TreeNode","handleExpansionChange","TreePath_TreePath","TreePropEditor_TreePropEditor","CodeMirror","defineSimpleMode","regex","token","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","editor","setSize","setValue","react_codemirror2","onBeforeChange","_onChange","_x3","editorDidMount","VisualNode","element","node-name","node-id","url","toLowerCase","VisualEditor","ContextMenuTarget","handleContextMenu","currentNode","selection","getSelection","rangeCount","getRangeAt","domNode","startContainer","textContent","preventDefault","punctuationPattern","startPos","endPos","setStart","setEnd","commonNode","getNodeByElement","commonAncestorContainer","endContainer","removeAllRanges","_this$props2","flatten","_this$props3","anchorNode","focusNode","alert","_this$props4","removeEntity","_this$props5","splitText","nodeType","TEXT_NODE","classList","parentElement","getAttribute","getNodeById","_this$props6","onDoubleClick","handleDoubleClick","VisualNode_VisualNode","commonEntityNames","wrapperNode","menu","menuItem","disabled","menuDivider","handleCreateBlock","handleRemoveBlock","handleSplitSentences","handleCreateEntity","prompt","handleRemoveEntity","handleInspect","State","stateNames","getStateName","countLineBreaks","stream","verbose","NODE_ENV","PUBLIC_URL","DEBUG","parsed","_console","_this$options","bigIntAsString","timeStart","now","METADATA","lastState","inline","embedded","isClosing","nodeStack","debugStack","lastNode","pushNode","debug","popNode","createError","levelUpBlock","blockNode","FINISH","debugState","eatWhile","metadataMatched","NORMAL","ATTRIBUTE_LIST","sol","eol","START","SINGLE_COMMENT","MULTIPLE_COMMENT","TAG_START","TAG_END","ENTITY_START","END","TAG_NAME","LABEL_START","_child","metaKey","pushCursor","popCursor","_child2","simpleBlock","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","_child3","clearLabels","clearMetadata","ATTRIBUTE_ASSIGN","ATTRIBUTE_NAME","_key","_ch2","ATTRIBUTE_FINISH","ATTRIBUTE_VALUE","_ch3","_value","isNull","_key2","_value2","setMetadata","setAttribute","parseMetadata","tagNode","setAttributes","ENTITY_END","skipOver","_child4","ENTITY_BODY","_text3"],"mappings":"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","file":"static/js/main.e5f6e27a.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.parse = parse;\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _Tokenizer.default;\n  }\n});\nObject.defineProperty(exports, \"TextStream\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.default;\n  }\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.TextLine;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.default;\n  }\n});\nObject.defineProperty(exports, \"NodeType\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.NodeType;\n  }\n});\nObject.defineProperty(exports, \"ParseError\", {\n  enumerable: true,\n  get: function get() {\n    return _ParseError.default;\n  }\n});\nexports.default = void 0;\n\nvar _Tokenizer = _interopRequireDefault(require(\"./Tokenizer\"));\n\nvar _TextStream = _interopRequireWildcard(require(\"./TextStream\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/**\n * @module @zaml/parser\n * @typicalname parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\n\n\nfunction parse(text, options) {\n  var tokenizer = new _Tokenizer.default(text, options);\n  return tokenizer.process();\n}\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\n\n\nfunction tokenize(text, options) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nvar _default = {\n  ParseError: _ParseError.default,\n  Tokenizer: _Tokenizer.default,\n  TextStream: _TextStream.default,\n  TextLine: _TextStream.TextLine,\n  Node: _Node.default,\n  NodeType: _Node.NodeType,\n  tokenize: tokenize,\n  parse: parse\n};\nexports.default = _default;","import React, { Component } from 'react';\nimport './App.scss';\nimport Editor from './Editor/Editor';\nimport contract from './sample/default';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Editor defaultSource={contract} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export default `---\nfoo: bar\n---\n#Question #Q #Q1 \n  What is your name?\n\n#Answer #A \n  My name is [Jack]{PER}\n`\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROCESSING_TIMEOUT = exports.P_MARKER = exports.END_MARKERS = exports.START_MARKERS = exports.P_FULL_WIDTH_CHARACTER = exports.P_BOOLEAN_FALSE = exports.P_BOOLEAN_TRUE = exports.P_STRING_LITERAL_UNQUOTED_TESTER = exports.P_STRING_LITERAL_UNQUOTED = exports.P_STRING_LITERAL_QUOTED = exports.P_NUMBER_VALUE = exports.P_NUMBER_LITERAL_FULL = exports.P_NUMBER_LITERAL = exports.P_NUMBER_START = exports.P_DATE_LITERAL = exports.T_STRING_START = exports.P_TAG_NAME_MULTILINE = exports.P_TAG_NAME = exports.P_ATTRIBUTE_LIST_MULTILINE = exports.P_ATTRIBUTE_LIST = exports.P_ATTRIBUTE_NAME_MULTILINE = exports.P_ATTRIBUTE_NAME = exports.P_ATTRIBUTE_ASSIGN = exports.P_LABEL = exports.P_VAR_NAME = exports.P_LABEL_START = exports.P_LIST_SEPARATOR = exports.P_WHITE_SPACES_EXT = exports.P_WHITE_SPACE = exports.P_PARAGRAPH_BREAK = exports.P_SPACE_WRAPPED_LINE_BREAK = exports.P_LINE_BREAK = exports.P_ASSIGN_YAML = exports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = exports.T_METADATA_FAVORED_ASSIGN = exports.T_PARAGRAPH_BREAK = exports.T_LINE_BREAKS = exports.T_LINE_BREAK = exports.T_ASSIGN_YAML = exports.T_ASSIGN_XML = exports.T_TAG_END = exports.T_TAG_CLOSING = exports.T_TAG_START = exports.T_ENTITY_END = exports.T_ENTITY_START = exports.P_MULTIPLE_LINE_COMMENT = exports.T_SINGLE_LINE_COMMENT = exports.T_METADATA_MARKER = exports.T_TAB = exports.T_SPACE = exports.DEFAULT_INDENT_SPACES = exports.combinePatterns = void 0;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar combinePatterns = function combinePatterns(list) {\n  return list.map(function (p) {\n    return _.isRegExp(p) ? p.source : _.escapeRegExp(p);\n  }).join('|');\n};\n\nexports.combinePatterns = combinePatterns;\nvar DEFAULT_INDENT_SPACES = 2;\nexports.DEFAULT_INDENT_SPACES = DEFAULT_INDENT_SPACES;\nvar T_SPACE = ' ';\nexports.T_SPACE = T_SPACE;\nvar T_TAB = '\\t';\nexports.T_TAB = T_TAB;\nvar T_METADATA_MARKER = \"---\";\nexports.T_METADATA_MARKER = T_METADATA_MARKER;\nvar T_SINGLE_LINE_COMMENT = '~';\nexports.T_SINGLE_LINE_COMMENT = T_SINGLE_LINE_COMMENT;\nvar P_MULTIPLE_LINE_COMMENT = '~{3,}';\nexports.P_MULTIPLE_LINE_COMMENT = P_MULTIPLE_LINE_COMMENT;\nvar T_ENTITY_START = '[';\nexports.T_ENTITY_START = T_ENTITY_START;\nvar T_ENTITY_END = ']';\nexports.T_ENTITY_END = T_ENTITY_END;\nvar T_TAG_START = '{';\nexports.T_TAG_START = T_TAG_START;\nvar T_TAG_CLOSING = '/';\nexports.T_TAG_CLOSING = T_TAG_CLOSING;\nvar T_TAG_END = '}';\nexports.T_TAG_END = T_TAG_END;\nvar T_ASSIGN_XML = '=';\nexports.T_ASSIGN_XML = T_ASSIGN_XML;\nvar T_ASSIGN_YAML = ':：';\nexports.T_ASSIGN_YAML = T_ASSIGN_YAML;\nvar T_LINE_BREAK = '\\n';\nexports.T_LINE_BREAK = T_LINE_BREAK;\nvar T_LINE_BREAKS = '\\r\\n';\nexports.T_LINE_BREAKS = T_LINE_BREAKS;\nvar T_PARAGRAPH_BREAK = '\\n\\n';\nexports.T_PARAGRAPH_BREAK = T_PARAGRAPH_BREAK;\nvar T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexports.T_METADATA_FAVORED_ASSIGN = T_METADATA_FAVORED_ASSIGN;\nvar T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\nexports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_TAG_ATTRIBUTE_FAVORED_ASSIGN;\nvar P_ASSIGN_YAML = /[:：]/;\nexports.P_ASSIGN_YAML = P_ASSIGN_YAML;\nvar P_LINE_BREAK = /\\r?\\n/g;\nexports.P_LINE_BREAK = P_LINE_BREAK;\nvar P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexports.P_SPACE_WRAPPED_LINE_BREAK = P_SPACE_WRAPPED_LINE_BREAK;\nvar P_PARAGRAPH_BREAK = new RegExp(\"\".concat(P_LINE_BREAK.source, \"\\\\s*\").concat(P_LINE_BREAK.source), 'g');\nexports.P_PARAGRAPH_BREAK = P_PARAGRAPH_BREAK;\nvar P_WHITE_SPACE = /[ \\t]/g;\nexports.P_WHITE_SPACE = P_WHITE_SPACE;\nvar P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexports.P_WHITE_SPACES_EXT = P_WHITE_SPACES_EXT;\nvar P_LIST_SEPARATOR = /[,，]/g;\nexports.P_LIST_SEPARATOR = P_LIST_SEPARATOR;\nvar P_LABEL_START = /[#＃]/g;\nexports.P_LABEL_START = P_LABEL_START;\nvar P_VAR_NAME = /(?:[A-Za-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\.0-9A-Z_a-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])*/g;\nexports.P_VAR_NAME = P_VAR_NAME;\nvar P_LABEL = new RegExp(\"\".concat(P_LABEL_START.source).concat(P_VAR_NAME.source), 'g');\nexports.P_LABEL = P_LABEL;\nvar P_ATTRIBUTE_ASSIGN = new RegExp(\"[\".concat([T_ASSIGN_XML, T_ASSIGN_YAML].join(''), \"]\"));\nexports.P_ATTRIBUTE_ASSIGN = P_ATTRIBUTE_ASSIGN;\nvar P_ATTRIBUTE_NAME = new RegExp(\"(?:\".concat(P_VAR_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"), 'g');\nexports.P_ATTRIBUTE_NAME = P_ATTRIBUTE_NAME;\nvar P_ATTRIBUTE_NAME_MULTILINE = new RegExp(\"(?:\".concat(P_VAR_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACES_EXT, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"), 'g');\nexports.P_ATTRIBUTE_NAME_MULTILINE = P_ATTRIBUTE_NAME_MULTILINE;\nvar P_ATTRIBUTE_LIST = new RegExp(\"(\".concat(P_VAR_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"|\").concat(P_LABEL, \")\"), 'g');\nexports.P_ATTRIBUTE_LIST = P_ATTRIBUTE_LIST;\nvar P_ATTRIBUTE_LIST_MULTILINE = new RegExp(\"(\".concat(P_VAR_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"?|\").concat(P_LABEL, \")\"), 'g');\nexports.P_ATTRIBUTE_LIST_MULTILINE = P_ATTRIBUTE_LIST_MULTILINE;\nvar P_TAG_NAME = P_ATTRIBUTE_NAME;\nexports.P_TAG_NAME = P_TAG_NAME;\nvar P_TAG_NAME_MULTILINE = P_ATTRIBUTE_NAME_MULTILINE;\nexports.P_TAG_NAME_MULTILINE = P_TAG_NAME_MULTILINE;\nvar T_STRING_START = '\"';\nexports.T_STRING_START = T_STRING_START;\nvar P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?|\\d{4}-[01]\\d-[0-3]\\d/g;\nexports.P_DATE_LITERAL = P_DATE_LITERAL;\nvar P_NUMBER_START = /[\\d\\.\\-]/;\nexports.P_NUMBER_START = P_NUMBER_START;\nvar P_NUMBER_LITERAL = /\\-?(\\d*\\.\\d*|\\d+)(e\\-?\\d+)?/g;\nexports.P_NUMBER_LITERAL = P_NUMBER_LITERAL;\nvar P_NUMBER_LITERAL_FULL = new RegExp(\"^\".concat(P_NUMBER_LITERAL.source, \"$\"));\nexports.P_NUMBER_LITERAL_FULL = P_NUMBER_LITERAL_FULL;\nvar P_NUMBER_VALUE = new RegExp(\"\".concat(P_NUMBER_LITERAL.source, \"(?=\").concat(combinePatterns([P_WHITE_SPACES_EXT, T_TAG_END]), \")\"), 'g');\nexports.P_NUMBER_VALUE = P_NUMBER_VALUE;\nvar P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\\")*\"/g;\nexports.P_STRING_LITERAL_QUOTED = P_STRING_LITERAL_QUOTED;\nvar P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexports.P_STRING_LITERAL_UNQUOTED = P_STRING_LITERAL_UNQUOTED;\nvar P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(\"^\".concat(P_STRING_LITERAL_UNQUOTED.source, \"$\"));\nexports.P_STRING_LITERAL_UNQUOTED_TESTER = P_STRING_LITERAL_UNQUOTED_TESTER;\nvar P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexports.P_BOOLEAN_TRUE = P_BOOLEAN_TRUE;\nvar P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexports.P_BOOLEAN_FALSE = P_BOOLEAN_FALSE;\nvar P_FULL_WIDTH_CHARACTER = /(?:[\\xD7\\u2014\\u2026\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3001\\u3002\\u3005\\u3007\\u300A-\\u300D\\u3010\\u3011\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFF01\\uFF03\\uFF05\\uFF06\\uFF08\\uFF09\\uFF0B-\\uFF0D\\uFF1A\\uFF1B\\uFF1D\\uFF1F\\uFF20\\uFFE5]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])/g;\nexports.P_FULL_WIDTH_CHARACTER = P_FULL_WIDTH_CHARACTER;\nvar START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexports.START_MARKERS = START_MARKERS;\nvar END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexports.END_MARKERS = END_MARKERS;\nvar P_MARKER = new RegExp(\"(\".concat(combinePatterns([P_PARAGRAPH_BREAK].concat(START_MARKERS, [T_TAG_END, P_MULTIPLE_LINE_COMMENT, T_SINGLE_LINE_COMMENT])), \")\"), 'g');\nexports.P_MARKER = P_MARKER;\nvar PROCESSING_TIMEOUT = Infinity;\nexports.PROCESSING_TIMEOUT = PROCESSING_TIMEOUT;","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatValue = formatValue;\nexports.parseValue = parseValue;\nexports.parseNumber = parseNumber;\nexports.spacer = spacer;\nexports.stringify = stringify;\nexports.chalk = exports.isAnsiSupported = exports.isChrome = exports.isNode = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Node = _interopRequireDefault(require(\"./Node\"));\n\nvar P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n/**\n * Stringify attribute value\n * @param value \n */\n\nfunction formatValue(value) {\n  var asString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (_.isDate(value)) {\n    value = value.toISOString();\n\n    if (asString) {\n      return JSON.stringify(value);\n    }\n\n    return value.replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString(value)) {\n    if ([_constants.T_TAG_START, _constants.T_ENTITY_START].includes(value.charAt(0)) || _constants.P_NUMBER_LITERAL_FULL.test(value) || !_constants.P_STRING_LITERAL_UNQUOTED_TESTER.test(value)) {\n      value = JSON.stringify(value);\n    }\n\n    return value;\n  } else if (_.isBoolean(value)) {\n    value = value.toString();\n\n    if (asString) {\n      value = JSON.stringify(value);\n    }\n\n    return value;\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    if (asString) {\n      value = value.toString();\n    }\n\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n/**\n * Parse attribute value\n * @param value \n */\n\n\nfunction parseValue(value) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * Parse number\n * @param value \n */\n\n\nfunction parseNumber(value) {\n  var number = parseFloat(value);\n\n  if (/^\\d+$/.test(value) && (number > Number.MAX_SAFE_INTEGER || number < Number.MIN_SAFE_INTEGER)) {\n    return value;\n  }\n\n  return number;\n}\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\n\n\nfunction spacer(space, indent) {\n  if (indent <= 0) return '';\n  return _.repeat(_constants.T_SPACE, space * indent);\n}\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\n\n\nfunction stringify(node, options) {\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var defaultOptions = {\n    space: _constants.DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false,\n    metadataMarker: true,\n    attributeAsString: false\n  };\n\n  var opt = _.defaults(options, defaultOptions);\n\n  var text = '';\n  var simpleTag = opt.simple && node.isSimpleTag && (node.labels.length > 0 || Object.keys(node.attributes).length > 0);\n  var unwrapped = simpleTag && node.isBlockTag && node.children.length === 1;\n\n  if (opt.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n\n  if (node.isText) {\n    if (opt.toSource) {\n      text += (node.content || '').replace(/\\n/g, \"\\n\".concat(spacer(opt.space, indent - 1)));\n    } else {\n      text += node.content;\n    }\n  } else {\n    if (node.isEntity) {\n      var child = _.first(node.children);\n\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n\n      if (opt.toSource) {\n        text += _constants.T_ENTITY_START;\n      }\n\n      text += stringify(child, opt, indent, pos + text.length);\n\n      if (opt.toSource) {\n        text += _constants.T_ENTITY_END;\n      }\n    }\n\n    if (opt.toSource && (node.isTag || node.isEntity)) {\n      if (node.isBlock) {\n        text += spacer(opt.space, indent);\n      }\n\n      if (!unwrapped) {\n        text += _constants.T_TAG_START;\n      }\n\n      if (!simpleTag) {\n        text += node.name;\n      }\n\n      var listCount = 0;\n\n      _.keys(node.attributes).forEach(function (key, i) {\n        var value = node.attributes[key];\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        if (!simpleTag && _.isBoolean(value) && value && !opt.attributeAsString) {\n          text += key;\n        } else if (value instanceof _Node.default) {\n          text += stringify(node, opt, 0, pos + text.length);\n        } else {\n          text += \"\".concat(key, \"=\").concat(formatValue(value, opt.attributeAsString));\n        }\n      });\n\n      _.each(node.labels, function (label, i) {\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        text += \"#\".concat(label);\n      });\n\n      if (!unwrapped) {\n        text += simpleTag ? _constants.T_SPACE : _constants.T_TAG_END;\n      }\n\n      if (node.isBlock) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (opt.toSource && node.isParagraph) {\n      text += spacer(opt.space, indent);\n    }\n\n    if (opt.toSource && !_.isEmpty(node.metadata)) {\n      if (opt.metadataMarker) {\n        text += spacer(opt.space, indent + 1) + _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n      }\n\n      _.each(node.metadata, function (value, key) {\n        text += spacer(opt.space, indent + 1);\n        text += \"\".concat(key, \": \");\n\n        if (value instanceof _Node.default) {\n          text += stringify(value, opt, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n\n        text += _constants.T_LINE_BREAK;\n      });\n\n      text += spacer(opt.space, indent + 1);\n\n      if (opt.metadataMarker) {\n        text += _constants.T_METADATA_MARKER;\n      }\n\n      text += _constants.T_LINE_BREAK;\n    }\n\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(function (child) {\n        var subText = stringify(child, opt, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n\n    var next = node.nextSibling;\n\n    if (node.isBlock) {\n      if (opt.toSource) {\n        text = _.trimEnd(text, _constants.T_LINE_BREAK);\n      }\n\n      text += _constants.T_LINE_BREAK;\n\n      if (node.isParagraph && !node.isLastChild) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (opt.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(opt.space, indent);\n      }\n\n      if (simpleTag) {\n        if (!unwrapped) {\n          text += _constants.T_TAG_END;\n        }\n      } else {\n        text += _constants.T_TAG_START + _constants.T_TAG_CLOSING + node.name + _constants.T_TAG_END;\n      }\n\n      if (node.isBlockTag) {\n        text += _constants.T_LINE_BREAK;\n\n        if (next && next.isBlock) {\n          text += _constants.T_LINE_BREAK;\n        }\n      }\n    }\n  }\n\n  if (opt.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}\n\nvar isNode = typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node';\nexports.isNode = isNode;\nvar isChrome = !isNode && /Chrome/.test(window.navigator.userAgent);\nexports.isChrome = isChrome;\nvar isAnsiSupported = isNode || isChrome; // lite version of https://github.com/chalk/chalk\n\nexports.isAnsiSupported = isAnsiSupported;\nvar colorful = isAnsiSupported ? function (start, end) {\n  return function (text) {\n    return \"\\x1B[\".concat(start, \"m\").concat(text, \"\\x1B[\").concat(end, \"m\");\n  };\n} : function (start, end) {\n  return function (text) {\n    return text;\n  };\n};\nvar chalkStyles = {\n  // modifier\n  reset: [0, 0],\n  // 21 isn't widely supported and 22 does the same thing\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  // color\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  // Bright color\n  blackBright: [90, 39],\n  grey: [90, 39],\n  gray: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  // bgColor\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  // Bright color\n  bgBlackBright: [100, 49],\n  bgGrey: [90, 39],\n  bgGray: [90, 39],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n};\n\nvar chalk = _.mapValues(chalkStyles, function (_ref) {\n  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n      start = _ref2[0],\n      end = _ref2[1];\n\n  return colorful(start, end);\n});\n\nexports.chalk = chalk;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testNode = testNode;\nexports.find = _find;\nexports.findOne = _findOne;\nexports.parseJson = parseJson;\nexports.toJsonMap = toJsonMap;\nexports.parseJsonMap = parseJsonMap;\nexports.default = exports.TreeRules = exports.WrappingTags = exports.BlockTags = exports.BlockNodeTypes = exports.P_LABEL_EXPRESSION = exports.P_ENTITY_EXPRESSION = exports.P_TAG_EXPRESSION = exports.P_NODE_EXPRESSION = exports.NodeTypes = exports.NodeType = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _2 = require(\".\");\n\nvar _constants = require(\"./constants\");\n\nvar _TreeRules;\n\nvar nanoid = require('nanoid');\n\nvar NodeType;\nexports.NodeType = NodeType;\n\n(function (NodeType) {\n  NodeType[\"FRAGMENT\"] = \"fragment\";\n  NodeType[\"ROOT\"] = \"root\";\n  NodeType[\"PARAGRAPH\"] = \"paragraph\";\n  NodeType[\"TAG\"] = \"tag\";\n  NodeType[\"ENTITY\"] = \"entity\";\n  NodeType[\"TEXT\"] = \"text\";\n  NodeType[\"COMMENT\"] = \"comment\";\n})(NodeType || (exports.NodeType = NodeType = {}));\n\nvar NodeTypes = _.values(NodeType);\n\nexports.NodeTypes = NodeTypes;\nvar P_NODE_EXPRESSION = /^<([A-Z]+)>$/;\nexports.P_NODE_EXPRESSION = P_NODE_EXPRESSION;\nvar P_TAG_EXPRESSION = /^{([A-Z]+)}$/;\nexports.P_TAG_EXPRESSION = P_TAG_EXPRESSION;\nvar P_ENTITY_EXPRESSION = /^\\[([A-Z]+)\\]$/;\nexports.P_ENTITY_EXPRESSION = P_ENTITY_EXPRESSION;\nvar P_LABEL_EXPRESSION = new RegExp(\"^\".concat(_constants.P_LABEL_START, \"(\").concat(_constants.P_VAR_NAME, \")$\"));\nexports.P_LABEL_EXPRESSION = P_LABEL_EXPRESSION;\nvar BlockNodeTypes = [NodeType.ROOT, NodeType.PARAGRAPH];\nexports.BlockNodeTypes = BlockNodeTypes;\nvar BlockTags = ['BLOCK', 'QUOTE', 'SECTION', 'HEADER', 'FOOTER'];\nexports.BlockTags = BlockTags;\nvar WrappingTags = BlockTags.concat(['INLINE', 'SENTENCE', 'NUM', 'HEADING']);\nexports.WrappingTags = WrappingTags;\nvar Descriptor;\n\n(function (Descriptor) {\n  Descriptor[\"ROOT\"] = \"<root>\";\n  Descriptor[\"PARAGRAPH\"] = \"<paragraph>\";\n  Descriptor[\"BLOCK\"] = \"{BLOCK}\";\n  Descriptor[\"INLINE\"] = \"{INLINE}\";\n  Descriptor[\"ENTITY\"] = \"[ENTITY]\";\n  Descriptor[\"TEXT\"] = \"(text)\";\n  Descriptor[\"FRAGMENT\"] = \"<fragment>\";\n  Descriptor[\"ANY\"] = \"*\";\n})(Descriptor || (Descriptor = {}));\n\nvar TreeRules = (_TreeRules = {}, (0, _defineProperty2.default)(_TreeRules, Descriptor.ROOT, [Descriptor.PARAGRAPH, Descriptor.BLOCK]), (0, _defineProperty2.default)(_TreeRules, Descriptor.PARAGRAPH, [Descriptor.INLINE, Descriptor.ENTITY, Descriptor.TEXT]), (0, _defineProperty2.default)(_TreeRules, Descriptor.BLOCK, [Descriptor.PARAGRAPH, Descriptor.BLOCK]), (0, _defineProperty2.default)(_TreeRules, Descriptor.INLINE, [Descriptor.INLINE, Descriptor.ENTITY, Descriptor.TEXT]), (0, _defineProperty2.default)(_TreeRules, Descriptor.ENTITY, [Descriptor.TEXT]), (0, _defineProperty2.default)(_TreeRules, Descriptor.TEXT, []), (0, _defineProperty2.default)(_TreeRules, Descriptor.FRAGMENT, [Descriptor.ANY]), _TreeRules);\nexports.TreeRules = TreeRules;\n\nvar defaultFinderCallback = function defaultFinderCallback(node) {\n  return true;\n};\n\nfunction testNode(pattern, node) {\n  if (_.isFunction(pattern)) {\n    return pattern(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\n\n\nfunction _find(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        _find(childNode, pattern, result);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\n\n\nfunction _findOne(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n\n  if (testNode(pattern, node)) {\n    return node;\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var childNode = _step2.value;\n\n        var result = _findOne(childNode, pattern);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    ;\n  }\n\n  return undefined;\n}\n\nfunction parseJson(json) {\n  var node = Node.create(json.type, json.name, {\n    id: json.id,\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content\n  });\n\n  if (json.children) {\n    _.each(json.children, function (childData) {\n      node.appendChild(parseJson(childData));\n    });\n  }\n\n  node.normalize();\n  return node;\n}\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\n\n\nfunction toJsonMap(map) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n\n  return _.mapValues(map, function (value) {\n    if (value instanceof Node) {\n      return value.toJSON(options);\n    }\n\n    return value;\n  });\n}\n\nfunction parseJsonMap(json) {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n\n  return _.mapValues(json, function (value) {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n\n    return (0, _util.parseValue)(value);\n  });\n}\n/**\n * AST node class\n * @class\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Node, null, [{\n    key: \"create\",\n\n    /**\n     * Create node, shortcut for constructor \n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n    value: function create(type, name, props) {\n      return new Node(type, name, props);\n    }\n    /**\n     * Create paragraph node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createParagraph\",\n    value: function createParagraph(props) {\n      return new Node(NodeType.PARAGRAPH, undefined, props);\n    }\n    /**\n     * Create root node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createRoot\",\n    value: function createRoot(props) {\n      return new Node(NodeType.ROOT, undefined, props);\n    }\n    /**\n     * Create text node\n     * @param [props]\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(content, props) {\n      return new Node(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n        content: content\n      }));\n    }\n    /**\n     * Create a common tag\n     * @param tagName Tag name, e.g. `'BLOCK'`, `'INLINE'`, `'SENTENCE'`\n     * @param [props]\n     */\n\n  }, {\n    key: \"createTag\",\n    value: function createTag(tagName, props) {\n      return new Node(NodeType.TAG, tagName, props);\n    }\n    /**\n     * Create block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(props) {\n      return new Node(NodeType.TAG, 'BLOCK', props);\n    }\n    /**\n     * Create inline block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createInlineBlock\",\n    value: function createInlineBlock(props) {\n      return new Node(NodeType.TAG, 'INLINE', props);\n    }\n    /**\n     * Create node instance from ZAML source\n     * @param source \n     */\n\n  }, {\n    key: \"fromSource\",\n    value: function fromSource(source) {\n      return (0, _2.parse)(source);\n    }\n    /**\n     * Create node from json serializable data\n     * @param json \n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return parseJson(json);\n    }\n    /**\n     * Creating fragment node\n     */\n\n  }, {\n    key: \"createFragment\",\n    value: function createFragment() {\n      return Node.create(NodeType.FRAGMENT);\n    }\n    /**\n     * Check if a node is valid\n     * @param node \n     */\n\n  }, {\n    key: \"validNode\",\n    value: function validNode(node) {\n      if (!(node instanceof Node)) {\n        throw new TypeError('invalid node');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validParent\",\n    value: function validParent(node) {\n      if (!_.isArray(node.children)) {\n        throw new Error('node is not a valid parent');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validChild\",\n    value: function validChild(node) {\n      if (!node.parent) {\n        throw new Error('node is not a valid child');\n      }\n    }\n  }, {\n    key: \"validTreeRule\",\n    value: function validTreeRule(parent, child) {\n      var p = parent.commonDescriptor;\n      var c = child.commonDescriptor;\n      var allowed = TreeRules[p];\n\n      if (allowed[0] !== Descriptor.ANY || !allowed.includes(c)) {\n        throw new Error(\"can not add \".concat(c, \" as child of \").concat(p));\n      }\n    }\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(n1, n2) {\n      var path1 = n1.path;\n      var path2 = n2.path;\n      var ancestor;\n\n      while (path1.length > 0 && path2.length > 0) {\n        if (_.first(path1) !== _.first(path2)) {\n          break;\n        }\n\n        ancestor = path1.shift();\n        path2.shift();\n      }\n\n      if (!ancestor) {\n        return undefined;\n      }\n\n      return {\n        ancestor: ancestor,\n        paths: [path1, path2]\n      };\n    }\n    /**\n     * Find the common ancestor of the range, and creates a wrapping block (or tag) with the nodes\n     * within the range in it.\n     * \n     * If the range is within a block (BLOCK tag or paragraph), a inline tag is created, otherwise\n     * a BLOCK tag is created.\n     * \n     * If a BLOCK tag is used, `startOffset` and `endOffset` will be ignored, to avoid block overlap.\n     * \n     * If either `startNode` or `endNode` is not direct child of common ancestor nor the node is not\n     * sided aligned with the direct child of the ancestor, text offset will be ignored to avoid\n     * split of tags or entity.\n     * \n     * @param range A range object which contains start and end node, alone with their text offset\n     * @param props Custom tag props\n     * @param tagName If inline tag is needed, specify the tag name instead of default `'INLINE'`\n     */\n\n  }, {\n    key: \"createBlockByRange\",\n    value: function createBlockByRange(range) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var startNode = range.startNode,\n          startOffset = range.startOffset,\n          endNode = range.endNode,\n          endOffset = range.endOffset;\n\n      if (!_.isNumber(startOffset) || !_.isNumber(endOffset)) {\n        throw new TypeError('range offset must be number');\n      }\n\n      if (!startNode.isText || !endNode.isText) {\n        throw new TypeError('range node must be text');\n      }\n\n      if (!startNode.content || !endNode.content) {\n        throw new Error('invalid text node');\n      }\n\n      if (startNode === endNode) {\n        if (startOffset < 0 || startOffset > startNode.content.length || endOffset < 0 || endOffset > startNode.content.length) {\n          throw new RangeError('sub text out of range');\n        }\n\n        if (!startNode.parent) {\n          throw new Error('can not create block on isolated text node');\n        }\n\n        var _parent = startNode.parent;\n        var fragment = Node.createFragment();\n        var block = Node.createTag(tagName, (0, _objectSpread2.default)({}, props, {\n          text: startNode.content.substring(startOffset, endOffset)\n        }));\n\n        if (startOffset > 0) {\n          fragment.appendText(startNode.content.substring(0, startOffset));\n        }\n\n        fragment.appendChild(block);\n\n        if (endOffset < startNode.content.length) {\n          fragment.appendText(startNode.content.substring(endOffset));\n        }\n\n        _parent.insertBefore(fragment, startNode);\n\n        _parent.removeChild(startNode);\n\n        return block;\n      } else {\n        var result = Node.findCommonAncestor(startNode, endNode);\n        if (!result || !result.ancestor) return undefined;\n        var ancestor = result.ancestor,\n            _paths = result.paths;\n        var baseStartNode = _paths[0][0];\n        var baseEndNode = _paths[1][0];\n\n        var _startIndex = ancestor.children.indexOf(baseStartNode);\n\n        var _endIndex = ancestor.children.indexOf(baseEndNode);\n\n        var _sort = [_startIndex, _endIndex].sort(),\n            _sort2 = (0, _slicedToArray2.default)(_sort, 2),\n            startIndex = _sort2[0],\n            endIndex = _sort2[1];\n\n        if (_startIndex !== startIndex) {\n          var _ref = [baseEndNode, baseStartNode];\n          baseStartNode = _ref[0];\n          baseEndNode = _ref[1];\n        }\n\n        var _fragment = ancestor.extractNodes(startIndex, endIndex + 1);\n\n        var isStartSided = startNode.isSidedDescendantOf(baseStartNode, 'start') && startOffset === 0;\n        var isEndSided = endNode.isSidedDescendantOf(baseEndNode, 'end') && endOffset === endNode.content.length;\n        var foundBlock = ancestor.findOne(function (n) {\n          return n.isBlock;\n        });\n        var hasBlock = foundBlock && foundBlock !== ancestor;\n\n        if (!hasBlock && (_paths[0].length === 1 || isStartSided || _paths[1].length === 1 || isEndSided)) {\n          var inserting = Node.createFragment();\n          var startText = startNode.content;\n\n          if (startOffset > 0) {\n            baseStartNode.content = startText.substring(startOffset);\n            inserting.appendText(startText.substring(0, startOffset));\n          }\n\n          var _block = Node.createTag(tagName, props);\n\n          _block.appendChild(_fragment);\n\n          inserting.appendChild(_block);\n          var endText = endNode.content;\n\n          if (endOffset < endNode.content.length) {\n            baseEndNode.content = endText.substring(0, endOffset);\n            inserting.appendText(endText.substring(endOffset));\n          }\n\n          ancestor.insertAt(inserting, startIndex);\n          return _block;\n        } else {\n          var _block2 = Node.createBlock(props);\n\n          ancestor.insertAt(_block2, startIndex);\n\n          _block2.appendChild(_fragment);\n\n          return _block2;\n        }\n      }\n    }\n  }]);\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n\n  function Node(type, name) {\n    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Node);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", '');\n    (0, _defineProperty2.default)(this, \"type\", void 0);\n    (0, _defineProperty2.default)(this, \"name\", void 0);\n    (0, _defineProperty2.default)(this, \"start\", -1);\n    (0, _defineProperty2.default)(this, \"end\", -1);\n    (0, _defineProperty2.default)(this, \"textStart\", -1);\n    (0, _defineProperty2.default)(this, \"textEnd\", -1);\n    (0, _defineProperty2.default)(this, \"states\", void 0);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"labels\", void 0);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"content\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", '');\n    (0, _defineProperty2.default)(this, \"children\", void 0);\n    var id = props.id,\n        _props$source = props.source,\n        source = _props$source === void 0 ? '' : _props$source,\n        _props$start = props.start,\n        start = _props$start === void 0 ? -1 : _props$start,\n        _props$end = props.end,\n        end = _props$end === void 0 ? -1 : _props$end,\n        states = props.states,\n        _props$attributes = props.attributes,\n        attributes = _props$attributes === void 0 ? {} : _props$attributes,\n        _props$metadata = props.metadata,\n        metadata = _props$metadata === void 0 ? {} : _props$metadata,\n        _props$labels = props.labels,\n        labels = _props$labels === void 0 ? [] : _props$labels,\n        parent = props.parent,\n        _props$content = props.content,\n        content = _props$content === void 0 ? '' : _props$content,\n        _props$text = props.text,\n        text = _props$text === void 0 ? '' : _props$text;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(\"invalid node type \".concat(type));\n    }\n\n    this.id = id || nanoid();\n    this.states = states || {};\n    this.type = type;\n    this.name = undefined;\n    this.start = start;\n    this.end = end;\n    this.textStart = -1;\n    this.textEnd = -1;\n    this.parent = parent;\n    this._source = undefined;\n    this.content = undefined;\n    this.children = [];\n    this.labels = [];\n    this.attributes = {};\n    this.metadata = {};\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n\n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n  /**\n   * Get a short descriptor to identify node's type and basic information\n   */\n\n\n  (0, _createClass2.default)(Node, [{\n    key: \"getRootNode\",\n\n    /**\n     * Property indicates if the root is root (which has no children)\n     */\n    value: function getRootNode() {\n      var node = this;\n\n      while (node.parent) {\n        node = node.parent;\n      }\n\n      if (node === this) {\n        return undefined;\n      }\n\n      return node;\n    }\n    /**\n     * Check node match the expression\n     * @example\n     * <root>: Root node\n     * <paragraph>: Paragraph node\n     * {BLOCK}: BLOCK tag\n     * {INLINE}: INLINE tag\n     * [PER]: entity\n     * @param expression \n     */\n\n  }, {\n    key: \"is\",\n    value: function is(expression) {\n      if (!_.isString(expression)) {\n        throw new TypeError('invalid node descriptor');\n      }\n\n      var match = null;\n\n      if (match = P_NODE_EXPRESSION.exec(expression)) {\n        return this.type === match[1];\n      } else if (match = P_TAG_EXPRESSION.exec(expression)) {\n        return this.type === NodeType.TAG && this.name === match[1];\n      } else if (match = P_ENTITY_EXPRESSION.exec(expression)) {\n        return this.type === NodeType.ENTITY && this.name === match[1];\n      } else if (match = P_LABEL_EXPRESSION.exec(expression)) {\n        return this.type === NodeType.TAG && this.labels.includes(match[1]);\n      }\n\n      return false;\n    }\n    /**\n     * whether a node is a descendant of a given node\n     * @param node \n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      Node.validNode(node);\n\n      while (node) {\n        if (node === this) {\n          return true;\n        }\n\n        if (!node.parent) {\n          return false;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Get a list of ancestors\n     */\n\n  }, {\n    key: \"hasChild\",\n\n    /**\n     * Check if this node has any children\n     */\n    value: function hasChild() {\n      return this.children.length > 0;\n    }\n    /**\n     * Check if this node is the only child of its parent\n     */\n\n  }, {\n    key: \"isOnlyDescendantOf\",\n\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n    value: function isOnlyDescendantOf(ancestor) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length !== 1) {\n          return false;\n        }\n\n        node = node.children[0];\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n\n  }, {\n    key: \"isSidedDescendantOf\",\n    value: function isSidedDescendantOf(ancestor, side) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        node = side === 'start' ? node.firstChild : node.lastChild;\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Create a child node\n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n\n  }, {\n    key: \"createChild\",\n    value: function createChild(type, name, props) {\n      var node = new Node(type, name, props);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Insert a node at the beginning of the children\n     * @param node \n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(node) {\n      return this.insertAt(node, 0);\n    }\n    /**\n     * Append a node to children list\n     * @param node \n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.insertAt(node, Infinity);\n    }\n    /**\n     * Append text node child\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = this.content || '';\n        this.content += text;\n        return this;\n      } else {\n        if (this.lastChild && this.lastChild.isText) {\n          this.lastChild.content += text;\n        } else {\n          var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n            content: text\n          }));\n          this.appendChild(child);\n        }\n      }\n    }\n    /**\n     * Add text node child at the beginning\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"prependText\",\n    value: function prependText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = \"\".concat(text).concat(this.content || '');\n        return this;\n      } else {\n        var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n          content: text\n        }));\n        this.prependChild(child);\n      }\n    }\n    /**\n     * Remove one child\n     * @param node\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      _.pull(this.children, child);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Remove one child by index\n     * @param index\n     */\n\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var child = this.children[index];\n\n      _.pullAt(this.children, index);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Insert a node at specified position\n     * @param node \n     * @param index \n     */\n\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(node, index) {\n      var _this = this;\n\n      if (node.type === NodeType.FRAGMENT) {\n        var _this$children;\n\n        (_this$children = this.children).splice.apply(_this$children, [index, 0].concat((0, _toConsumableArray2.default)(node.children)));\n\n        node.children.forEach(function (child) {\n          child.parent = _this;\n        });\n        node.children = [];\n      } else {\n        this.children.splice(index, 0, node);\n\n        if (node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node.parent = this;\n      }\n\n      return node;\n    }\n    /**\n     * Insert a node before another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex);\n      return node;\n    }\n    /**\n     * Insert a node after another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex + 1);\n      return node;\n    }\n    /**\n     * Replace a child with another node, assuming current node is a parent\n     * @param newChild \n     * @param oldChild \n     * @returns The replaced child\n     */\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      Node.validParent(this);\n\n      if (newChild.contains(this)) {\n        throw new TypeError('the new child contains the parent');\n      }\n\n      if (oldChild.parent !== this) {\n        throw new TypeError('the old child is not a child of this node');\n      }\n\n      this.insertBefore(newChild, oldChild);\n      this.removeChild(oldChild);\n      return oldChild;\n    }\n    /**\n     * Replace current child node with another node, assuming current node is child\n     * @param node Node to be replaced with\n     */\n\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(node) {\n      Node.validChild(this);\n\n      if (!this.parent) {\n        throw new Error('can not replace isolated node');\n      }\n\n      this.parent.replaceChild(node, this);\n      return node;\n    }\n    /**\n     * Set single attribute value\n     * @param {string} key Attribute key\n     * @param {any} value Attribute value\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      _.set(this.attributes, key, value);\n    }\n    /**\n     * Set multiple attributes\n     * @param data Key-value pair\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(data) {\n      _.merge(this.attributes, data);\n    }\n    /**\n     * Get attribute value\n     * @param key \n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return _.get(this.attributes, key);\n    }\n    /**\n     * Check if a specified attribute key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return _.has(this.attributes, key);\n    }\n    /**\n     * Remove an attribute\n     * @param {string} key \n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      _.unset(this.attributes, key);\n    }\n    /**\n     * Remove all attributes\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes() {\n      this.attributes = {};\n    }\n    /**\n     * Set single metadata value\n     * @param key Key or key-value pair\n     * @param value Metadata value (only when key is string)\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(key, value) {\n      if (_.isString(key)) {\n        _.set(this.metadata, key, value);\n      } else {\n        _.merge(this.metadata, key);\n      }\n    }\n    /**\n     * Get metadata value\n     * @param key \n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(key) {\n      return _.get(this.metadata, key);\n    }\n    /**\n     * Remove a metadata\n     * @param key \n     */\n\n  }, {\n    key: \"removeMetadata\",\n    value: function removeMetadata(key) {\n      _.unset(this.metadata, key);\n    }\n    /**\n     * Remove all metadata\n     */\n\n  }, {\n    key: \"clearMetadata\",\n    value: function clearMetadata() {\n      this.metadata = {};\n    }\n    /**\n     * Check if a specified metadata key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasMetadata\",\n    value: function hasMetadata(key) {\n      return _.has(this.metadata, key);\n    }\n    /**\n     * Add label to node\n     * @param label \n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(label) {\n      if (!_.isString(label)) {\n        throw new TypeError('label must be string');\n      }\n\n      if (!this.labels.includes(label)) {\n        this.labels.push(label);\n      }\n    }\n    /**\n     * Check if the node has specified label\n     * @param label \n     */\n\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(label) {\n      return this.labels.includes(label);\n    }\n    /**\n     * Remove label\n     * @param label \n     */\n\n  }, {\n    key: \"removeLabel\",\n    value: function removeLabel(label) {\n      _.pull(this.labels, label);\n    }\n    /**\n     * Remove all labels\n     */\n\n  }, {\n    key: \"clearLabels\",\n    value: function clearLabels() {\n      this.labels = [];\n    }\n    /**\n     * Rebuild text and source position, in case modification has been applied to node\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var source = this.toSource();\n\n      if (this.isRoot) {\n        this._source = source;\n      }\n\n      this.toString();\n    }\n    /**\n     * Get node by id\n     * @param id \n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      return _findOne(this, function (node) {\n        return node.id === id;\n      });\n    }\n    /**\n     * Find matched descendants recursively\n     * @param selector Node selector object\n     * @param [one] Find the first matched node or a list of node\n     */\n\n  }, {\n    key: \"findBy\",\n    value: function findBy() {\n      var _this2 = this;\n\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var type = selector.type,\n          name = selector.name,\n          text = selector.text,\n          source = selector.source,\n          label = selector.label;\n      var finder = one ? _findOne : _find;\n      return finder(this, function (node) {\n        var match = true;\n\n        if (type) {\n          match = match && type === node.type;\n        }\n\n        if (name) {\n          match = match && name === node.name;\n        }\n\n        if (text && node.type === NodeType.TEXT && node.content) {\n          if (_.isRegExp(text)) {\n            match = match && !!text.match(node.content);\n          } else if (_.isString(text)) {\n            match = match && node.content.includes(text);\n          } else {\n            throw new TypeError('text filter should be RegExp or string');\n          }\n        }\n\n        if (source && node._source) {\n          if (_.isRegExp(source)) {\n            match = match && !!source.match(node._source);\n          } else if (_.isString(source)) {\n            match = match && node._source.includes(source);\n          } else {\n            throw new TypeError('source filter should be RegExp or string');\n          }\n        }\n\n        if (label) {\n          if (_.isArray(label)) {\n            match = match && _.intersection(_this2.labels, label).length > 0;\n          } else {\n            match = match && _this2.labels.includes(label);\n          }\n        }\n\n        return match;\n      });\n      ;\n    }\n    /**\n     * Find nodes by selector recursively and return the first one\n     * @param selector \n     */\n\n  }, {\n    key: \"findOneBy\",\n    value: function findOneBy() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.findBy(selector, true);\n    }\n    /**\n     * Find matched text node by text source range\n     * @param start \n     * @param end \n     */\n\n  }, {\n    key: \"findTextByRange\",\n    value: function findTextByRange(start, end) {\n      if (this.textStart === undefined || this.textEnd === undefined) {\n        return undefined;\n      }\n\n      if (this.textStart <= start && this.textEnd >= end) {\n        if (this.type === NodeType.TEXT) {\n          return this;\n        } else if (this.hasChild()) {\n          for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            var match = child.findTextByRange(start, end);\n\n            if (match) {\n              return match;\n            }\n          }\n\n          ;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Find matched children recursively by callback\n     * @param callback\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback) {\n      return _find(this, callback);\n    }\n    /**\n     * Find matched children recursively and return the first one\n     * @param callback\n     */\n\n  }, {\n    key: \"findOne\",\n    value: function findOne(callback) {\n      return _findOne(this, callback);\n    }\n    /**\n     * Find all nodes by selector, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return _find(this, selector);\n    }\n    /**\n     * Find nodes by selector and return the first one, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return _findOne(this, selector);\n    }\n    /**\n     * Split node text into tag wrapped sections, e.g. splitting sentences\n     * \n     * @example \n     * node.splitText('!?.');\n     * @param separator RegExp or character list in string, to split\n     * @param tagName Custom tag name, like `'SENTENCE'`\n     */\n\n  }, {\n    key: \"splitText\",\n    value: function splitText(separator) {\n      var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'INLINE';\n      var props = arguments.length > 2 ? arguments[2] : undefined;\n      var pattern = separator instanceof RegExp ? separator : new RegExp(\"[\".concat(_.escapeRegExp(separator), \"]\"), 'g');\n      var list = this.find(function (node) {\n        return node.isParagraph || node.isInlineBlock;\n      });\n      list.forEach(function (node) {\n        var text = node.toString();\n        var pos = 0;\n        var lastPos = 0;\n        pattern.lastIndex = 0;\n\n        while (pattern.exec(text)) {\n          // recreate text offset for each node\n          node.toString();\n          pos = pattern.lastIndex;\n          var textNodes = node.children.filter(function (n) {\n            return n.isText;\n          });\n\n          var _startNode = textNodes.find(function (tn) {\n            return tn.textStart <= lastPos && tn.textEnd > lastPos;\n          });\n\n          var _endNode = textNodes.find(function (tn) {\n            return tn.textStart < pos && tn.textEnd >= pos;\n          });\n\n          if (!_startNode || !_endNode) {\n            break;\n          }\n\n          var range = {\n            startNode: _startNode,\n            startOffset: lastPos - _startNode.textStart,\n            endNode: _endNode,\n            endOffset: pos - _endNode.textStart\n          };\n          Node.createBlockByRange(range, tagName, props);\n          lastPos = pos;\n        }\n      });\n    }\n    /**\n     * Merge neighbor text nodes\n     */\n\n  }, {\n    key: \"mergeText\",\n    value: function mergeText() {\n      var _this3 = this;\n\n      var stack = [];\n      var childLength = this.children.length;\n      this.children.forEach(function (child, i) {\n        if (child.isText) {\n          stack.push(child);\n        }\n\n        if (!child.isText || i === childLength - 1) {\n          if (stack.length > 1) {\n            var merged = stack.map(function (child) {\n              return child.content;\n            }).join('');\n            var textNode = Node.createText(merged);\n\n            _this3.insertBefore(textNode, stack[0]);\n\n            var n;\n\n            while (n = stack.shift()) {\n              _this3.removeChild(n);\n            }\n          }\n\n          stack = [];\n        }\n      });\n    }\n  }, {\n    key: \"extractNodes\",\n    value: function extractNodes(startIndex, endIndex) {\n      var fragment = Node.createFragment();\n\n      if (startIndex < 0 || startIndex >= this.children.length || endIndex < 0 || endIndex > this.children.length) {\n        throw new RangeError('invalid range of children');\n      }\n\n      var nodes = this.children.slice(startIndex, endIndex);\n      nodes.forEach(function (child) {\n        fragment.appendChild(child);\n      });\n      return fragment;\n    }\n    /**\n     * Remove a element and move its children to its parent\n     */\n\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      if (!this.parent) {\n        return;\n      }\n\n      var parent = this.parent;\n      var fragment = this.extractNodes(0, this.children.length);\n      parent.insertBefore(fragment, this);\n      parent.removeChild(this);\n      parent.mergeText();\n      return parent;\n    }\n    /**\n     * Process text node in current node and parse entities\n     */\n\n  }, {\n    key: \"createEntities\",\n    value: function createEntities(items) {\n      var entityNodes = [];\n\n      if (this.type !== NodeType.TEXT) {\n        console.warn('createEntities() should exec only on text node');\n      }\n\n      if (!this.content || _.isEmpty(items)) {\n        return entityNodes;\n      }\n\n      var text = this.content;\n      items = _.sortBy(items, ['start']);\n      var fragment = Node.createFragment();\n      var lastPos = 0;\n      items.forEach(function (item) {\n        if (item.start >= item.end || item.start < lastPos) {\n          return;\n        }\n\n        if (item.start > lastPos) {\n          fragment.appendText(text.substring(lastPos, item.start));\n        }\n\n        var entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n          attributes: item.data\n        });\n        entityNode.appendText(text.substring(item.start, item.end));\n        entityNodes.push(entityNode);\n        lastPos = item.end;\n      });\n\n      if (lastPos < text.length) {\n        fragment.appendText(text.substr(lastPos));\n      }\n\n      this.replaceWith(fragment);\n      return entityNodes;\n    }\n    /**\n     * Create entity nodes based on text source position\n     * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n     */\n\n  }, {\n    key: \"createEntitiesFromText\",\n    value: function createEntitiesFromText(entities) {\n      var _this4 = this;\n\n      this.toString();\n      var cache = new Map();\n\n      _.each(entities, function (item) {\n        var textNode = _this4.findTextByRange(item.start, item.end);\n\n        if (textNode === undefined) {\n          return;\n        }\n\n        if (cache.has(textNode)) {\n          cache.get(textNode).push(item);\n        } else {\n          cache.set(textNode, [item]);\n        }\n      });\n\n      cache.forEach(function (items, textNode) {\n        textNode.createEntities(items.map(function (item) {\n          return (0, _objectSpread2.default)({}, item, {\n            start: item.start - (textNode.textStart || 0),\n            end: item.end - (textNode.textStart || 0)\n          });\n        }));\n      });\n    }\n    /**\n     * Extract entities from text node\n     */\n\n  }, {\n    key: \"extractEntities\",\n    value: function () {\n      var _extractEntities = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(extractor) {\n        var nodeList, textList, result;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nodeList = this.find(function (node) {\n                  return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n                });\n                textList = nodeList.map(function (node) {\n                  return node.content;\n                });\n\n                if (!_.isFunction(extractor)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 5;\n                return Promise.all(textList.map(function (text) {\n                  return extractor(text);\n                }));\n\n              case 5:\n                result = _context.sent;\n                _context.next = 21;\n                break;\n\n              case 8:\n                if (!_.isFunction(extractor.extractArray)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 11;\n                return extractor.extractArray(textList);\n\n              case 11:\n                result = _context.sent;\n                _context.next = 21;\n                break;\n\n              case 14:\n                if (!_.isFunction(extractor.extract)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                _context.next = 17;\n                return Promise.all(textList.map(function (text) {\n                  return extractor.extract(text);\n                }));\n\n              case 17:\n                result = _context.sent;\n                _context.next = 21;\n                break;\n\n              case 20:\n                throw new TypeError('invalid extractor');\n\n              case 21:\n                nodeList.forEach(function (node, i) {\n                  var items = result[i];\n\n                  if (!_.isArray(items)) {\n                    throw new Error('invalid extraction result');\n                  }\n\n                  node.createEntities(items);\n                });\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function extractEntities(_x) {\n        return _extractEntities.apply(this, arguments);\n      };\n    }()\n    /**\n     * Remove wrapping entity and put text back\n     */\n\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity() {\n      if (this.type !== NodeType.ENTITY || !this.firstChild || this.firstChild.type !== NodeType.TEXT) {\n        throw new Error('invalid entity');\n      }\n\n      ;\n\n      if (!this.parent) {\n        throw new Error('can not remove isolated entity');\n      }\n\n      var text = this.firstChild.content || '';\n      var textNode;\n      var parent = this.parent,\n          previousSibling = this.previousSibling,\n          nextSibling = this.nextSibling;\n\n      if (previousSibling && previousSibling.isText) {\n        textNode = previousSibling;\n      }\n\n      if (textNode) {\n        textNode.appendText(text);\n      } else {\n        textNode = Node.create(NodeType.TEXT, undefined, {\n          content: text\n        });\n        parent.insertBefore(textNode, this);\n      }\n\n      if (nextSibling && nextSibling.isText) {\n        textNode.appendText(nextSibling.content || '');\n        parent.removeChild(nextSibling);\n      }\n\n      parent.removeChild(this);\n      return textNode;\n    }\n    /**\n     * Build plain text of the node (stripping tags & entities)\n     * @param [options]\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      return (0, _util.stringify)(this, options);\n    }\n    /**\n     * Build source code of the node\n     * @param [options]\n     */\n\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _util.stringify)(this, (0, _objectSpread2.default)({}, options, {\n        toSource: true\n      }));\n    }\n    /**\n     * Convert node to JSON serializable object\n     * @param options \n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$position = options.position,\n          position = _options$position === void 0 ? false : _options$position,\n          _options$textPosition = options.textPosition,\n          textPosition = _options$textPosition === void 0 ? false : _options$textPosition,\n          _options$internalId = options.internalId,\n          internalId = _options$internalId === void 0 ? false : _options$internalId;\n      return _.omitBy({\n        id: internalId ? this.id : undefined,\n        type: this.type,\n        name: this.name,\n        content: this.content,\n        attributes: toJsonMap(this.attributes),\n        metadata: toJsonMap(this.metadata, options),\n        labels: this.labels.length ? this.labels : undefined,\n        position: position ? {\n          start: this.start,\n          end: this.end\n        } : undefined,\n        textPosition: textPosition ? {\n          start: this.textStart,\n          end: this.textEnd\n        } : undefined,\n        children: _.isEmpty(this.children) ? undefined : this.children.map(function (child) {\n          return child.toJSON(options);\n        })\n      }, _.isUndefined);\n    }\n  }, {\n    key: \"descriptor\",\n    get: function get() {\n      if (this.isEntity || this.isTag || this.isText) {\n        return \"\".concat(this.openDescriptorStart).concat(this.openDescriptorEnd);\n      } else {\n        return this.type;\n      }\n    }\n    /**\n     * Get descriptor ignoring name difference\n     */\n\n  }, {\n    key: \"commonDescriptor\",\n    get: function get() {\n      if (this.isRoot) {\n        return Descriptor.ROOT;\n      } else if (this.isBlockTag) {\n        return Descriptor.BLOCK;\n      } else if (this.isParagraph) {\n        return Descriptor.PARAGRAPH;\n      } else if (this.isInlineBlock) {\n        return Descriptor.INLINE;\n      } else if (this.isEntity) {\n        return Descriptor.ENTITY;\n      } else if (this.isText) {\n        return Descriptor.TEXT;\n      } else {\n        return Descriptor.ANY;\n      }\n    }\n  }, {\n    key: \"openDescriptorStart\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[\".concat(this.name);\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name);\n\n        case NodeType.TEXT:\n          return '(text';\n\n        default:\n          return \"<\".concat(this.type);\n      }\n    }\n  }, {\n    key: \"openDescriptorEnd\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"]\";\n\n        case NodeType.TAG:\n          return \"}\";\n\n        case NodeType.TEXT:\n          return '';\n\n        default:\n          return '>';\n      }\n    }\n  }, {\n    key: \"closingDescriptor\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[/\".concat(this.name, \"]\");\n\n        case NodeType.TAG:\n          return \"{/\".concat(this.name, \"}\");\n\n        case NodeType.TEXT:\n          return ')';\n\n        default:\n          return \"</\".concat(this.type, \">\");\n      }\n    }\n  }, {\n    key: \"selector\",\n    get: function get() {\n      var selector = this.descriptor;\n\n      if (this.parent) {\n        selector = \"\".concat(this.descriptor, \"[\").concat(this.childIndex, \"]\");\n      }\n\n      return selector;\n    }\n  }, {\n    key: \"rootSelector\",\n    get: function get() {\n      if (!this.parent) {\n        return this.selector;\n      }\n\n      var selectors = this.path.map(function (node) {\n        return node.selector;\n      });\n      return selectors.join(' > ');\n    }\n    /**\n     * Check if the node is root\n     */\n\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.type === NodeType.ROOT;\n    }\n    /**\n     * Check if the node is paragraph\n     */\n\n  }, {\n    key: \"isParagraph\",\n    get: function get() {\n      return this.type === NodeType.PARAGRAPH;\n    }\n    /**\n     * Check if the node is tag\n     */\n\n  }, {\n    key: \"isTag\",\n    get: function get() {\n      return this.type === NodeType.TAG;\n    }\n    /**\n     * Check if the node is entity\n     */\n\n  }, {\n    key: \"isEntity\",\n    get: function get() {\n      return this.type === NodeType.ENTITY;\n    }\n    /**\n     * Check if the node is text\n     */\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type === NodeType.TEXT;\n    }\n    /**\n     * Check if the node is text and not wrapping by entity\n     */\n\n  }, {\n    key: \"isPlainText\",\n    get: function get() {\n      return this.type === NodeType.TEXT && (!this.parent || this.parent.type !== NodeType.ENTITY);\n    }\n    /**\n     * Check if the node is wrapping tag\n     */\n\n  }, {\n    key: \"isWrappingTag\",\n    get: function get() {\n      return this.isTag && WrappingTags.includes(this.name);\n    }\n    /**\n     * Check if the node is block tag\n     */\n\n  }, {\n    key: \"isBlockTag\",\n    get: function get() {\n      return this.isTag && BlockTags.includes(this.name);\n    }\n    /**\n     * Check if the node is simple block or inline block\n     */\n\n  }, {\n    key: \"isSimpleTag\",\n    get: function get() {\n      return this.isTag && ['BLOCK', 'INLINE'].includes(this.name);\n    }\n    /**\n     * Property indicates if the node is a block (wrapping other nodes)\n     */\n\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      var type = this.type,\n          name = this.name;\n      return BlockNodeTypes.includes(type) || this.isBlockTag;\n    }\n    /**\n     * If node is inline block\n     */\n\n  }, {\n    key: \"isInlineBlock\",\n    get: function get() {\n      return this.isTag && !this.isBlockTag;\n    }\n    /**\n     * Get parent node, alias for node.parent\n     */\n\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    }\n    /**\n     * Get child nodes, alias for node.children\n     */\n\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    }\n    /**\n     * Get source code of the node\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      if (this.type === NodeType.ROOT) {\n        return this._source || '';\n      }\n\n      var rootNode = this.getRootNode();\n\n      if (!rootNode) {\n        throw new Error('ROOT node not found');\n      }\n\n      return rootNode.source.substring(this.start || 0, this.end);\n    }\n    /**\n     * Get node inner text\n     */\n\n  }, {\n    key: \"innerText\",\n    get: function get() {\n      if (this.type === NodeType.TEXT) {\n        return this.content;\n      } else if (this.type === NodeType.ENTITY) {\n        var textNode = this.children[0];\n        return textNode ? textNode.content : '';\n      } else {\n        return this.toString();\n      }\n    }\n    /**\n     * Check if the node is the first child of its parent\n     */\n\n  }, {\n    key: \"isFirstChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.first(parent.children) === this;\n    }\n    /**\n     * Check if the node is the last child of its parent\n     */\n\n  }, {\n    key: \"isLastChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.last(parent.children) === this;\n    }\n    /**\n     * Siblings from same parent\n     */\n\n  }, {\n    key: \"siblings\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return [this];\n      }\n\n      return parent.children;\n    }\n    /**\n     * Get index of parent children\n     */\n\n  }, {\n    key: \"childIndex\",\n    get: function get() {\n      var siblings = this.siblings;\n      return siblings.indexOf(this);\n    }\n    /**\n     * Next sibling node\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex + 1] || undefined;\n    }\n    /**\n     * Previous sibling node\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex - 1] || undefined;\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      var list = [];\n      var node = this;\n\n      while (node) {\n        list.unshift(node);\n        node = node.parent;\n      }\n\n      return list;\n    }\n    /**\n     * Get the first child of current node\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.first(this.children);\n    }\n    /**\n     * Get the last child of current node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.last(this.children);\n    }\n  }, {\n    key: \"isOnlyChild\",\n    get: function get() {\n      if (!this.parent) {\n        return false;\n      }\n\n      return this.parent.children.length === 1;\n    }\n  }]);\n  return Node;\n}();\n\n(0, _defineProperty2.default)(Node, \"Types\", NodeType);\nvar _default = Node;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextLine.default;\n  }\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _TextLine = _interopRequireDefault(require(\"./TextLine\"));\n\nvar _constants = require(\"./constants\"); // improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\n\n\nvar NOT_FOUND = -1;\nvar LINE_BREAKS = /\\r?\\n/g;\n/**\n * Stream like text string\n * @typicalname stream\n */\n\nvar TextStream =\n/*#__PURE__*/\nfunction () {\n  /** Current cursor position */\n\n  /** Original text */\n\n  /** Tab size */\n\n  /** Text lines */\n\n  /** Start position of each line */\n\n  /** Markers */\n\n  /** Cursor stack positions */\n\n  /** Last matched string of methods like eat() match() */\n  function TextStream(text) {\n    var tabSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    (0, _classCallCheck2.default)(this, TextStream);\n    (0, _defineProperty2.default)(this, \"pos\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"tabSize\", void 0);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"lineOffsetIndexes\", []);\n    (0, _defineProperty2.default)(this, \"markers\", void 0);\n    (0, _defineProperty2.default)(this, \"cursorStack\", void 0);\n    (0, _defineProperty2.default)(this, \"lastMatch\", '');\n    this.pos = 0;\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n\n    this.text = text;\n    /**\n     * @description Tab size\n     */\n\n    this.tabSize = tabSize;\n    /**\n     * @description Lines, separated by line breaks\n     */\n\n    this.lines = [];\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n\n    this.markers = [];\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n\n    this.cursorStack = [];\n    this.init();\n  }\n  /**\n   * Prepare line indexes\n   */\n\n\n  (0, _createClass2.default)(TextStream, [{\n    key: \"init\",\n    value: function init() {\n      var lines = [];\n      var matched;\n      var offset = 0;\n      var ln = 1;\n      LINE_BREAKS.lastIndex = 0;\n\n      do {\n        matched = LINE_BREAKS.exec(this.text);\n\n        if (matched) {\n          var length = matched.index - offset;\n\n          var _text = this.text.substr(offset, length);\n\n          lines.push(new _TextLine.default(lines, _text, ln, offset));\n          offset += length + matched[0].length;\n        } else {\n          var _length = this.text.length - offset; // process last line without line break symbol\n\n\n          if (_length > 0) {\n            var _text2 = this.text.substr(offset);\n\n            lines.push(new _TextLine.default(lines, _text2, ln, offset));\n          }\n        }\n\n        ln++;\n      } while (matched);\n\n      this.lines = lines;\n      this.lineOffsetIndexes = _.map(lines, 'offset');\n    }\n    /**\n     * Get line and column position of the cursor\n     * @param pos Cursor position of the text\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      var lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n      var line = this.lines[lineIndex];\n\n      if (!line) {\n        throw new Error('cursor position is invalid');\n      }\n\n      var ln = line.ln,\n          offset = line.offset;\n      var col = pos - offset + 1;\n      return {\n        ln: ln,\n        col: col,\n        pos: pos,\n        line: line\n      };\n    }\n    /**\n     * Check if cursor is at the start of a line\n     * @param [trimSpaces] Whether to trim starting spaces\n     */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition = this.getPosition(),\n          col = _this$getPosition.col,\n          line = _this$getPosition.line;\n\n      if (col - 1 === 0) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimStart = _.trimStart(line.text),\n          length = _$trimStart.length;\n\n      return col - 1 <= line.length - length;\n    }\n    /**\n     * Check if cursor is at the end of a line\n     * @param [trimSpaces] Whether to trim ending spaces\n     */\n\n  }, {\n    key: \"eol\",\n    value: function eol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition2 = this.getPosition(),\n          col = _this$getPosition2.col,\n          line = _this$getPosition2.line;\n\n      if (col - 1 === line.length) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimEnd = _.trimEnd(line.text),\n          length = _$trimEnd.length;\n\n      return col - 1 >= length;\n    }\n    /**\n     * Check if cursor is at the end of whole text\n     * @param {number} [pos] \n     */\n\n  }, {\n    key: \"eof\",\n    value: function eof(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      return pos >= this.text.length;\n    }\n    /**\n     * Get one next char, but keep the cursor position (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.text.charAt(this.pos);\n    }\n    /**\n     * Get one next char, and move cursor forward (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.text.length) {\n        return this.text.charAt(this.pos++);\n      }\n\n      return '';\n    }\n    /**\n     * Consumes one char if the next char fitting the pattern\n     * @param pattern \n     * @returns The char been eaten\n     */\n\n  }, {\n    key: \"eat\",\n    value: function eat(pattern) {\n      var ch = this.text.charAt(this.pos) || '';\n      var ok;\n\n      if (_.isUndefined(ch)) {\n        ok = false;\n      } else if (_.isString(pattern)) {\n        ok = ch === pattern;\n      } else if (_.isRegExp(pattern)) {\n        pattern.lastIndex = 0;\n        ok = pattern.test(ch);\n      } else if (_.isFunction(pattern)) {\n        ok = pattern(ch);\n      }\n\n      if (ok) {\n        this.lastMatch = ch;\n        ++this.pos;\n        return ch;\n      }\n\n      return '';\n    }\n    /**\n     * Consumes chars while fitting the pattern\n     * @param match \n     * @returns Eaten characters\n     */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(pattern) {\n      var start = this.pos;\n      var chr;\n      var string = '';\n\n      do {\n        chr = this.eat(pattern);\n\n        if (chr) {\n          string += chr;\n        }\n      } while (chr && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes chars until the first char not fitting the pattern\n     * @param pattern char or pattern\n     * @returns eaten characters\n     */\n\n  }, {\n    key: \"eatUntil\",\n    value: function eatUntil(pattern) {\n      var start = this.pos;\n      var ch;\n      var string = '';\n\n      do {\n        ch = this.eat(pattern);\n\n        if (!ch) {\n          string += this.peek();\n          this.pos++;\n        } else {\n          this.pos--;\n        }\n      } while (!ch && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes spaces\n     * @returns {boolean} If any space has been consumed\n     */\n\n  }, {\n    key: \"eatSpaces\",\n    value: function eatSpaces() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n        this.pos++;\n      }\n\n      return this.pos > start;\n    }\n    /**\n     * Find position of matched text to the pattern\n     * @param pattern \n     * @param options\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var caseInsensitive = options.caseInsensitive;\n      var index = NOT_FOUND;\n      var length = 0;\n      var matched = '';\n\n      if (typeof pattern === 'string') {\n        if (caseInsensitive) {\n          pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n        } else {\n          index = this.text.indexOf(pattern, this.pos);\n\n          if (index !== NOT_FOUND) {\n            matched = pattern;\n          }\n        }\n      }\n\n      if (pattern instanceof RegExp) {\n        pattern.lastIndex = this.pos;\n        var result = pattern.exec(this.text);\n\n        if (result) {\n          index = result.index;\n          matched = result[0];\n        } else {\n          index = NOT_FOUND;\n        }\n      }\n\n      var _matched = matched;\n      length = _matched.length;\n      return {\n        index: index,\n        length: length,\n        matched: matched\n      };\n    }\n    /**\n     * Read n chars after current cursor\n     * @param [n] Number of chars to read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var left = this.text.length - this.pos;\n\n      if (left <= 0) {\n        return '';\n      } else if (left < n) {\n        n = left;\n      }\n\n      var result = this.text.substr(this.pos, n);\n      this.pos += n;\n      return result;\n    }\n    /**\n     * Read to text or pattern\n     * @param pattern \n     * @param [options]\n     * @returns Sub-text after current cursor and before (or contains) matched text\n     */\n\n  }, {\n    key: \"readTo\",\n    value: function readTo(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$toEOL = options.toEOL,\n          toEOL = _options$toEOL === void 0 ? false : _options$toEOL,\n          _options$toEOF = options.toEOF,\n          toEOF = _options$toEOF === void 0 ? false : _options$toEOF,\n          _options$consume = options.consume,\n          consume = _options$consume === void 0 ? false : _options$consume,\n          _options$skipMatched = options.skipMatched,\n          skipMatched = _options$skipMatched === void 0 ? false : _options$skipMatched;\n      var start = this.pos;\n\n      var _this$search = this.search(pattern),\n          index = _this$search.index,\n          length = _this$search.length;\n\n      var match = '';\n      var end = -1;\n\n      if (toEOL) {\n        var _this$getPosition3 = this.getPosition(),\n            _line = _this$getPosition3.line;\n\n        end = _line.offset + _line.length;\n      } else if (toEOF) {\n        end = this.text.length;\n      }\n\n      if (index !== NOT_FOUND) {\n        if (toEOL || toEOF) {\n          if (index < end) {\n            end = index;\n          } else {\n            length = 0;\n          }\n        } else {\n          end = index;\n        }\n      }\n\n      if (end !== -1) {\n        this.pos = end;\n\n        if (consume) {\n          end += length;\n          this.pos = end;\n        } else if (skipMatched) {\n          this.pos += length;\n        }\n\n        match = this.text.substring(start, end);\n      }\n\n      this.lastMatch = match;\n      return match;\n    }\n    /**\n     * Read to pattern (contains the matched text)\n     * @param {} pattern Text to find or pattern\n     * @param {object} options Match options\n     * @returns {string} Sub-text after current cursor and until the end of matched text\n     */\n\n  }, {\n    key: \"readOver\",\n    value: function readOver(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        consume: true\n      }));\n    }\n    /**\n     * Read one line\n     * @returns {string} Text containing one line (not including line break)\n     */\n\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var _this$getPosition4 = this.getPosition(),\n          line = _this$getPosition4.line;\n\n      var nextLine = line.next();\n\n      if (this.eof()) {\n        return '';\n      }\n\n      if (nextLine) {\n        this.pos = nextLine.offset;\n        return line.text;\n      } else {\n        var length = line.offset + line.length - this.pos;\n        return this.read(length);\n      }\n    }\n    /**\n     * Move cursor to end of text\n     */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.text.length;\n    }\n    /**\n     * Skip to the beginning of matched text\n     * @param pattern\n     * @param options\n     */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, options);\n      return start !== this.pos;\n    }\n    /**\n     * Skip to the end of matched text\n     * @param pattern\n     */\n\n  }, {\n    key: \"skipOver\",\n    value: function skipOver(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        skipMatched: true\n      }));\n      return start !== this.pos;\n    }\n    /**\n     * Move cursor back\n     * @param n Steps\n     */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.pos -= n;\n    }\n    /**\n     * Check if rest text begins with pattern\n     * @param pattern \n     * @param [options] \n     */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$consume2 = options.consume,\n          consume = _options$consume2 === void 0 ? true : _options$consume2,\n          caseInsensitive = options.caseInsensitive;\n\n      var _this$search2 = this.search(pattern, {\n        caseInsensitive: caseInsensitive\n      }),\n          index = _this$search2.index,\n          length = _this$search2.length,\n          matched = _this$search2.matched;\n\n      if (index !== this.pos) {\n        return '';\n      }\n\n      if (consume) {\n        this.pos += length;\n      }\n\n      this.lastMatch = matched;\n      return matched;\n    }\n    /**\n     * Reset the marker stack\n     */\n\n  }, {\n    key: \"resetMarker\",\n    value: function resetMarker() {\n      this.markers = [];\n    }\n    /**\n     * Add a marker to stack\n     * @param data\n     * @param start\n     */\n\n  }, {\n    key: \"pushMarker\",\n    value: function pushMarker(data, start) {\n      if (_.isUndefined(start)) {\n        start = this.pos;\n      }\n\n      this.markers.push({\n        data: data,\n        start: start\n      });\n    }\n    /**\n     * Set data for current marker\n     * @param data\n     */\n\n  }, {\n    key: \"setMarkerData\",\n    value: function setMarkerData(data) {\n      var marker = _.last(this.markers);\n\n      if (!marker) return;\n\n      _.extend(marker.data, data);\n    }\n    /**\n     * Get data of current markder\n     */\n\n  }, {\n    key: \"getMarkerData\",\n    value: function getMarkerData() {\n      var marker = _.last(this.markers);\n\n      if (!marker) return {};\n      return marker.data;\n    }\n    /**\n     * Return a combined structure of text and it's position according to the previously set start\n     * marker\n     * @param [data] Additional data\n     * @param [end] End marker, if not set, previous set value will be used\n     */\n\n  }, {\n    key: \"popMarker\",\n    value: function popMarker() {\n      var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!_.isPlainObject(_data)) {\n        throw new TypeError('invalid data parameter');\n      }\n\n      if (_.isUndefined(end)) {\n        end = this.pos;\n      }\n\n      var marker = this.markers.pop();\n\n      if (!marker) {\n        return undefined;\n      }\n\n      var data = marker.data,\n          start = marker.start;\n      return {\n        text: this.text.substring(marker.start || 0, end),\n        position: {\n          start: start,\n          end: end\n        },\n        data: (0, _objectSpread2.default)({}, data, _data)\n      };\n    }\n  }, {\n    key: \"findLine\",\n    value: function findLine(text) {\n      return _.find(this.lines, function (line) {\n        return _.trim(line.text) === text;\n      });\n    }\n    /**\n     * Push current cursor to cursor stack, if new position provided, set current cursor to it\n     * @param [pos] \n     */\n\n  }, {\n    key: \"pushCursor\",\n    value: function pushCursor(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      this.cursorStack.push(this.pos);\n      this.pos = pos;\n    }\n    /**\n     * Pop last from cursor stack and set it to current cursor\n     */\n\n  }, {\n    key: \"popCursor\",\n    value: function popCursor() {\n      if (this.cursorStack.length === 0) {\n        throw new Error('out of cursor stack!');\n      }\n\n      this.pos = this.cursorStack.pop();\n      return this.pos;\n    }\n    /**\n     * Debug a single line\n     * @param line \n     * @param numWidth \n     * @param col \n     */\n\n  }, {\n    key: \"debugLine\",\n    value: function debugLine(line, numWidth, col) {\n      var ln = line.ln,\n          text = line.text;\n\n      if (_.isUndefined(numWidth)) {\n        numWidth = (ln + '').length;\n      }\n\n      if (col) {\n        text = text.substring(0, col - 1) + _util.chalk.bgBlue(text.charAt(col - 1)) + text.substring(col);\n      }\n\n      console.log(\"\".concat(_util.chalk.blueBright(\"\".concat(col ? '>' : ' ', \" \").concat(_.padStart(ln + '', numWidth), \" |\")), \" \").concat(text));\n    }\n    /**\n     * Debug cursor column position\n     * @param text Text of the line\n     * @param col Cursor position\n     * @param numWidth fixed line number width\n     */\n\n  }, {\n    key: \"debugCursor\",\n    value: function debugCursor(text, col, numWidth) {\n      var pos = text.substr(0, col - 1).replace(_constants.P_FULL_WIDTH_CHARACTER, 'XX').length;\n      console.log(_util.chalk.blueBright(\"  \".concat(_.repeat(' ', numWidth), \" | \").concat(_.repeat(' ', pos), \"^ \").concat(col)));\n    }\n    /**\n     * Debug current position state, with previous and following lines set by range\n     * @param range \n     */\n\n  }, {\n    key: \"debugState\",\n    value: function debugState() {\n      var _this = this;\n\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$getPosition5 = this.getPosition(),\n          ln = _this$getPosition5.ln,\n          col = _this$getPosition5.col;\n\n      var lineIndex = ln - 1;\n\n      var lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n\n      var numWidth = _.max(lines.map(function (l) {\n        return (l.ln + '').length;\n      }));\n\n      lines.forEach(function (line) {\n        var isCurrent = line.ln === ln;\n\n        _this.debugLine(line, numWidth, isCurrent ? col : 0);\n\n        if (isCurrent) {\n          _this.debugCursor(line.text, col, numWidth);\n        }\n      });\n      console.log();\n    }\n  }]);\n  return TextStream;\n}();\n\nvar _default = TextStream;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n\n  function ParseError(message, text, from, to) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"message\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"text\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"from\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"to\", void 0);\n    _this.message = message;\n    _this.text = text;\n    _this.from = from;\n    _this.to = to;\n    return _this;\n  }\n\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.default = ParseError;","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from '../SourceEditor/SourceEditor';\nimport VisualEditor from '../VisualEditor/VisualEditor';\nimport '@blueprintjs/core/lib/css/blueprint.css';\nimport 'normalize.css/normalize.css';\nimport './Editor.scss';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from '../TreeView/TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  defaultSource: string;\n  className: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  source: string\n  root: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source, { needMetadataMarker: true });\n    (global as any).node = node;\n    console.info('Root node exported as global variable \"node\"', node);\n  } catch(err) {\n    if (err instanceof zaml.ParseError) {\n      const message = `\n        [ParseError]{ERROR.TYPE}: {#MESSAGE ${err.message}}\n\n        #SOURCE\n        content\n\n        from {#POS.START ${err.from.ln}:${err.from.col}} to {#POS.END ${err.to.ln}:${err.to.col}}\n      `;\n      node = zaml.parse(message);\n      const sourceBlock = node.querySelector('#SOURCE');\n      const { text } = err.from.line;\n      if (!sourceBlock) return node;\n      const sourceText = sourceBlock.findOneBy({type: NodeType.TEXT});\n      if (!sourceText) return node;\n      sourceText.content = `${text} `;\n      sourceText.createEntitiesFromText([{\n        type: 'ERROR',\n        start: err.from.col - 1,\n        end: err.to.col - 1,\n      }]);\n    } else {\n      node = zaml.parse(`Error: [${err.message}]{MESSAGE}`);\n      console.error(err);\n    }\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    defaultSource: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    defaultSource: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  public preventSourceChange: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      source: props.defaultSource,\n      root: parse(props.defaultSource),\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n    this.preventSourceChange = false;\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n  }\n\n  componentWillUpdate(nextProps: Props, nextState: State) {\n    if (nextState.selectedNode !== this.state.selectedNode) {\n      console.log('selected node:', nextState.selectedNode);\n    }\n    if (nextState.root !== this.state.root) {\n      console.log('new node:', nextState.root);\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  handleSourceChange(source: string) {\n    if (this.preventSourceChange) return;\n    this.setState({\n      root: parse(source),\n      selectedNode: undefined,\n    });\n  }\n\n  handleNodeChange(root?: zaml.Node, selected?: zaml.Node) {\n    if (!root) return;\n    this.preventSourceChange = true;\n    this.setState({\n      source: root.toSource(),\n      selectedNode: selected,\n    }, () => {\n      this.preventSourceChange = false;\n    });\n  }\n\n  render() {\n    const { source } = this.state;\n    const { root, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={source}\n                height={sourcePaneHeight - 40}\n                onChange={(value: string) => this.handleSourceChange(value)}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  root={root}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onChange={(r?: zaml.Node, n?: zaml.Node) => this.handleNodeChange(r, n)}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  root={root}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                  onChange={n => this.handleNodeChange(root, n)}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar _ref =\n/*#__PURE__*/\nReact.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref4 =\n/*#__PURE__*/\nReact.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref5 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref6 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref7 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref8 =\n/*#__PURE__*/\nReact.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgComponent = function SvgComponent(props) {\n  return React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\"\n  }, props), _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n};\n\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { SvgComponent as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.scss';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      const isEntity = node.type === NodeType.ENTITY;\n      const isTag = node.type === NodeType.TAG;\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      let name = (isTag || isEntity) ? node.name : node.type;\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            >▾</span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {node.openDescriptorStart}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {node.openDescriptorEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {node.closingDescriptor}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\nimport { NodePart } from './TreeNode';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {node.descriptor}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreePropEditor.scss';\nimport TabView from '../Common/TabView';\nimport { KeyValueMap } from '@zaml/parser/typings/Node';\n\ninterface Props {\n  node?: zaml.Node;\n  onChange: (node: zaml.Node) => void;\n}\n\ninterface State {\n  selectedTab?: string;\n  editingIndex: number;\n  inlineError: string;\n}\n\nenum Tab {\n  Labels = 'Labels',\n  Attributes = 'Attributes',\n  Metadata = 'Metadata',\n}\n\nconst tabs = _.values(Tab);\nconst defaultTab = tabs[0];\nconst defaultEditingIndex = -1;\n\nexport default class TreePropEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.instanceOf(zaml.Node),\n  };\n\n  static defaultProps: Props = {\n    onChange: () => {},\n  };\n\n  state = {\n    selectedTab: defaultTab,\n    editingIndex: defaultEditingIndex,\n    inlineError: '',\n  };\n\n  editingElement: HTMLInputElement | null = null;\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (nextProps.node !== this.props.node) {\n      this.setState({\n        selectedTab: defaultTab,\n        editingIndex: defaultEditingIndex,\n      });\n    }\n  }\n\n  renderValue(value: any) {\n    if (value instanceof zaml.Node) {\n      return value.toSource();\n    } else {\n      return JSON.stringify(value);\n    }\n  }\n\n  renderEmptyTip() {\n    return (\n      <div className=\"select-tip\">Please select a node</div>\n    )\n  }\n\n  renderTabContent() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    if (!node) {\n      return this.renderEmptyTip();\n    }\n    switch(selectedTab) {\n      case Tab.Labels:\n        return this.renderLabelEditor(node);\n      case Tab.Attributes:\n        return this.renderAttributeEditor(node, node.attributes);\n      case Tab.Metadata:\n        return this.renderAttributeEditor(node, node.metadata);\n    }\n  }\n\n  focusEditingElement() {\n    if (this.editingElement) {\n      this.editingElement.focus();\n      this.editingElement.select();\n    }\n  }\n\n  handleLabelEdit(index: number) {\n    this.setState({ editingIndex: index }, () => {\n      this.focusEditingElement();\n    });\n  }\n\n  handleLabelUpdate(label: string) {\n    const { node, onChange } = this.props;\n    const { editingIndex } = this.state;\n    if (!node) return;\n    const originalLabel = node.labels[editingIndex] || '';\n    if (label !== originalLabel) {\n      try {\n        zaml.parse(`{INLINE #${label}}TESTING{/INLINE}`);\n      } catch (e) {\n        this.setState({ inlineError: 'Invalid label'});\n        return;\n      }\n      if (editingIndex === node.labels.length) {\n        node.addLabel(label);\n      } else {\n        if (label === '' || node.labels.indexOf(label) >= 0) {\n          node.removeLabel(originalLabel);\n        } else {\n          node.labels[editingIndex] = label;\n        }\n      }\n    }\n    this.cancelLabelEditing();\n    onChange(node);\n  }\n\n  cancelLabelEditing() {\n    this.setState({\n      editingIndex: defaultEditingIndex,\n      inlineError: '',\n    });\n  }\n  \n  renderLabelEditor(node: zaml.Node) {\n    const { editingIndex, inlineError } = this.state;\n    const labels = [...node.labels, ''];\n    return (\n      <div className=\"label-editor\">\n        <table>\n          <tbody>\n          {labels.map((label, i) => (\n            <tr\n              key={label}\n              className={classNames({ error: i === editingIndex && inlineError })}\n            >\n              <td className=\"marker\">{label || i === editingIndex ? '#': ''}</td>\n              {i === editingIndex ?\n                <td>\n                  <input\n                    ref={ref => this.editingElement = ref}\n                    defaultValue={label}\n                    onBlur={(event: React.FocusEvent<HTMLInputElement>) => {\n                      this.handleLabelUpdate(event.currentTarget.value);\n                    }}\n                    onKeyDown={(event: React.KeyboardEvent<HTMLInputElement>) => {\n                      if (event.key === 'Enter') {\n                        this.handleLabelUpdate(event.currentTarget.value);\n                      } else if (event.key === 'Escape') {\n                        this.cancelLabelEditing();\n                      }\n                    }}\n                  />\n                </td>\n              :\n                <td\n                  className=\"editable\"\n                  onClick={() => this.handleLabelEdit(i)}\n                >\n                  {label}\n                </td>\n              }\n            </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderAttributeEditor(node: zaml.Node, props: KeyValueMap) {\n    const keys = Object.keys(props);\n    return (\n      <div className=\"attribute-editor\">\n        <table>\n          <tbody>\n            {keys.map(key => (\n              <tr key={key}>\n                <th>{key}</th>\n                <td>{this.renderValue(props[key])}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  render() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    return (\n      <div className=\"zaml-prop-editor\">\n        <TabView\n          tabs={tabs}\n          selectedTab={selectedTab}\n          onTabChange={(tab: string) => this.setState({ selectedTab: tab })}\n        >\n          {this.renderTabContent()}\n        </TabView>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport './TabView.scss';\n\ninterface Props {\n  tabs: string[];\n  selectedTab: string;\n  onTabChange: (tab: string) => void;\n}\n\nexport default class TabView extends React.Component<Props> {\n\n  render() {\n    const { tabs, selectedTab, onTabChange, children } = this.props\n    return (\n      <div className=\"tab-view\">\n        <ul className=\"tabs\">\n          {tabs.map(tab => (\n            <li\n              key={tab}\n              className={classNames('tab', { selected: tab === selectedTab })}\n              onClick={() => onTabChange(tab)}\n            >\n              <span className=\"label\">{tab}</span>\n            </li>\n          ))}\n        </ul>\n        <div className=\"content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePath from './TreePath';\nimport TreeToolbar from './TreeToolbar';\nimport TreePropEditor from './TreePropEditor';\nimport './TreeView.scss';\n\ninterface Props {\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart;\n  expandedNodes: string[];\n}\n\nconst nil = () => {};\n\nexport default class TreeView extends React.Component<Props, State> {\n  static propTypes = {\n    node: PropTypes.shape({}),\n  };\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n    onChange: nil,\n  };\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds)\n      });\n    }\n  }\n\n  render() {\n    const {\n      root,\n      selectedNode,\n      onSelect,\n      onHover,\n      onChange,\n    } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <SplitPane split=\"horizontal\" defaultSize=\"60%\" minSize={200}>\n          <div className=\"tree-container\">\n            <TreeToolbar />\n            <div className=\"tree\">\n              <TreeNode\n                node={root}\n                selectedNode={selectedNode}\n                selectedPart={selectedPart}\n                expandedNodes={expandedNodes}\n                onSelect={onSelect}\n                onSelectPart={p => this.setState({ selectedPart: p })}\n                onMouseEnter={onHover}\n                onMouseOut={() => onHover()}\n                onExpansionChange={(n: zaml.Node, expanded: boolean) =>\n                  this.handleExpansionChange(n, expanded)\n                }\n              />\n            </div>\n            <TreePath selectedNode={selectedNode} onSelect={onSelect} />\n          </div>\n          <TreePropEditor node={selectedNode} onChange={onChange} />\n        </SplitPane>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:：=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[\\{]/, indent: true},\n    {regex: /[\\}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport './SourceEditor.scss';\nimport './codemirror-mode';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.editor) {\n      if (nextProps.height !== this.props.height && this.editor) {\n        this.editor.setSize(null, nextProps.height);\n      }\n      if (nextProps.value !== this.props.value) {\n        this.editor.setValue(nextProps.value);\n      }\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.scss';\n\nconst { NodeType } = zaml;\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            node-id={node.id}\n            href={node.attributes.url}\n          >\n            <VisualNode\n              node-id={node.children[0].id}\n              {...this.props}\n              node={node.children[0]}\n            />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      'node-id': node.id,\n    }, children);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { ContextMenuTarget, Menu, MenuItem, MenuDivider } from \"@blueprintjs/core\"\nimport VisualNode from './VisualNode';\nimport './VisualEditor.scss';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  commonEntityNames?: string[];\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node, selected?: zaml.Node) => void;\n}\n\ninterface State {\n}\n\n@ContextMenuTarget\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    commonEntityNames: PropTypes.arrayOf(PropTypes.string),\n    root: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    commonEntityNames: ['PER', 'ORG', 'LOC', 'DATE'],\n    onSelect: () => {},\n    onChange: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n  }\n\n  handleDoubleClick(event: React.MouseEvent) {\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const domNode = range.startContainer;\n    const text = domNode.textContent;\n    if (!text) return;\n    event.preventDefault();\n    event.stopPropagation();\n    const punctuationPattern = /[!?:;。！？：；]/g;\n    let startPos = 0;\n    let endPos = text.length;\n    let pos = 0;\n    while (punctuationPattern.exec(text)) {\n      startPos = pos;\n      pos = punctuationPattern.lastIndex;\n      punctuationPattern.lastIndex++;\n      if (pos > range.startOffset) {\n        endPos = pos;\n        break;\n      }\n    }\n    range.setStart(domNode, startPos);\n    range.setEnd(domNode, endPos);\n  }\n\n  handleCreateBlock() {\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const commonNode = this.getNodeByElement(range.commonAncestorContainer as HTMLElement);\n    let startNode = this.getNodeByElement(range.startContainer as HTMLElement);\n    let endNode = this.getNodeByElement(range.endContainer as HTMLElement);\n    if (!commonNode || !startNode || !endNode) {\n      return;\n    }\n    const block = zaml.Node.createBlockByRange({\n      startNode,\n      startOffset: range.startOffset,\n      endNode,\n      endOffset: range.endOffset,\n    });\n    selection.removeAllRanges();\n    onChange(root, block);\n  }\n\n  handleRemoveBlock(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const parent = node.flatten();\n    onChange(root, parent);\n  }\n\n  handleCreateEntity(target: zaml.Node, name: string | null) {\n    if (!name) return;\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.anchorNode !== selection.focusNode) {\n      alert('Entity is only allowed in pure text!');\n      return;\n    }\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const entityNodes = target.createEntities([{\n      type: name,\n      start: range.startOffset,\n      end: range.endOffset,\n    }]);\n    onChange(root, entityNodes[0]);\n  }\n\n  handleRemoveEntity(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    const textNode = node.removeEntity();\n    onChange(root, textNode);\n  }\n\n  handleInspect(node: zaml.Node) {\n    const { onSelect } = this.props;\n    onSelect(node);\n  }\n\n  handleSplitSentences(node?: zaml.Node) {\n    if (!node) return;\n    const { root, onChange } = this.props;\n    node.splitText('：。！？', 'SENTENCE');\n    onChange(root);\n  }\n\n  getNodeByElement(element: HTMLElement) {\n    const { root: root } = this.props;\n    if (!root) return undefined;\n    if (element.nodeType === element.TEXT_NODE || element.classList.contains('children')) {\n      if (!element.parentElement) {\n        return undefined;\n      }\n      element = element.parentElement;\n    }\n    const id = element.getAttribute('node-id');\n    if (!id) return undefined;\n    return root.getNodeById(id);\n  }\n\n  render() {\n    const { root: node, selectedNode } = this.props;\n    return (\n      <div\n        className=\"zaml-visual-editor\"\n        onDoubleClick={(event: React.MouseEvent) => this.handleDoubleClick(event)}\n      >\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n        />\n      </div>\n    )\n  }\n\n  renderContextMenu(e: React.MouseEvent<HTMLElement>) {\n    const { commonEntityNames } = this.props;\n    const target = this.getNodeByElement(e.target as HTMLElement);\n    let node = target;\n    if (!target) return;\n    if (target.type === NodeType.TEXT) {\n      node = target.parent;\n    }\n    if (!node) return;\n    const wrapperNode = node;\n    return (\n      <Menu id=\"menu\">\n        <MenuItem disabled text={node.descriptor} />\n        <MenuDivider />\n        <MenuItem\n          text=\"Create Block\"\n          onClick={() => this.handleCreateBlock()}\n        />\n        {node.isWrappingTag &&\n          <MenuItem\n            text=\"Remove Block\"\n            onClick={() => this.handleRemoveBlock(node)}\n          />\n        }\n        {node.isBlock &&\n          <MenuItem\n            text=\"Split Sentences\"\n            onClick={() => this.handleSplitSentences(node)}\n          />\n        }\n        {target.type === NodeType.TEXT && target.parent && target.parent.type !== NodeType.ENTITY &&\n          <MenuItem text=\"Create Entity\">\n            {commonEntityNames && commonEntityNames.map(name => (\n              <MenuItem\n                key={name}\n                text={name}\n                onClick={() => this.handleCreateEntity(target, name)}\n              />\n            ))}\n            <MenuItem\n              text=\"other...\"\n              onClick={() => this.handleCreateEntity(target, prompt('Please input entity type', 'PER'))}\n            />\n          </MenuItem>\n        }\n        {node.type === NodeType.ENTITY &&\n          <MenuItem\n            text=\"Remove Entity\"\n            onClick={() => this.handleRemoveEntity(node)}\n          />\n        }\n        <MenuDivider />\n        <MenuItem\n          text=\"Inspect\"\n          onClick={() => this.handleInspect(wrapperNode)}\n        />\n      </Menu>\n    );\n  }\n}\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _TextStream = _interopRequireDefault(require(\"./TextStream\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _constants = require(\"./constants\");\n\nvar State;\n\n(function (State) {\n  State[State[\"METADATA\"] = 0] = \"METADATA\";\n  State[State[\"NORMAL\"] = 1] = \"NORMAL\";\n  State[State[\"SINGLE_COMMENT\"] = 2] = \"SINGLE_COMMENT\";\n  State[State[\"MULTIPLE_COMMENT\"] = 3] = \"MULTIPLE_COMMENT\";\n  State[State[\"START\"] = 4] = \"START\";\n  State[State[\"TAG_START\"] = 5] = \"TAG_START\";\n  State[State[\"TAG_NAME\"] = 6] = \"TAG_NAME\";\n  State[State[\"ATTRIBUTE_LIST\"] = 7] = \"ATTRIBUTE_LIST\";\n  State[State[\"ATTRIBUTE_NAME\"] = 8] = \"ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_ASSIGN\"] = 9] = \"ATTRIBUTE_ASSIGN\";\n  State[State[\"ATTRIBUTE_VALUE\"] = 10] = \"ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_FINISH\"] = 11] = \"ATTRIBUTE_FINISH\";\n  State[State[\"TAG_END\"] = 12] = \"TAG_END\";\n  State[State[\"LABEL_START\"] = 13] = \"LABEL_START\";\n  State[State[\"ENTITY_START\"] = 14] = \"ENTITY_START\";\n  State[State[\"ENTITY_BODY\"] = 15] = \"ENTITY_BODY\";\n  State[State[\"ENTITY_END\"] = 16] = \"ENTITY_END\";\n  State[State[\"END\"] = 17] = \"END\";\n  State[State[\"FINISH\"] = 18] = \"FINISH\";\n})(State || (State = {}));\n\n;\nvar stateNames = ['METADATA', 'NORMAL', 'SINGLE_COMMENT', 'MULTIPLE_COMMENT', 'START', 'TAG_START', 'TAG_NAME', 'ATTRIBUTE_LIST', 'ATTRIBUTE_NAME', 'ATTRIBUTE_ASSIGN', 'ATTRIBUTE_VALUE', 'ATTRIBUTE_FINISH', 'TAG_END', 'LABEL_START', 'ENTITY_START', 'ENTITY_BODY', 'ENTITY_END', 'END', 'FINISH'];\n\nvar getStateName = function getStateName(state) {\n  return stateNames[state];\n};\n\nvar countLineBreaks = function countLineBreaks(text) {\n  var result = text.match(_constants.P_LINE_BREAK);\n  return result ? result.length : 0;\n};\n\n;\n/**\n * Tokenizer class\n * @class\n */\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Tokenizer, null, [{\n    key: \"from\",\n    value: function from(text, options) {\n      return new Tokenizer(text, options);\n    }\n  }]);\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n\n  function Tokenizer(text, options) {\n    (0, _classCallCheck2.default)(this, Tokenizer);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"stream\", void 0);\n    (0, _defineProperty2.default)(this, \"options\", void 0);\n    (0, _defineProperty2.default)(this, \"parsed\", void 0);\n\n    if (!_.isString(text)) {\n      throw new TypeError('input must be string');\n    } // ensure new line at the end of file\n\n\n    if (!/\\n\\s*$/.test(text)) {\n      text += _constants.T_LINE_BREAK;\n    }\n\n    this.text = text;\n    this.stream = new _TextStream.default(text);\n    var defaultOptions = {\n      verbose: process && process.env.DEBUG === 'verbose'\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  (0, _createClass2.default)(Tokenizer, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n    /**\n     * Process a text and parse to AST\n     * @returns Root node of parsed AST\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this = this;\n\n      var text = this.text,\n          stream = this.stream;\n      var _this$options = this.options,\n          needMetadataMarker = _this$options.needMetadataMarker,\n          attributeAsString = _this$options.attributeAsString,\n          bigIntAsString = _this$options.bigIntAsString;\n      var timeStart = Date.now();\n      var state = State.METADATA;\n      var start = 0;\n      var lastState = 0;\n      var lastPos = -1;\n      var states = {\n        unwrapped: false,\n        inline: false,\n        embedded: false,\n        isClosing: false,\n        key: undefined,\n        value: undefined\n      };\n\n      var root = _Node.default.create(_Node.NodeType.ROOT, undefined, {\n        source: text\n      });\n\n      var nodeStack = [];\n      var node = root;\n\n      var debugStack = function debugStack(lastNode) {\n        if (!_this.options.verbose) {\n          return;\n        }\n\n        var separator = ' > ';\n        var stack = nodeStack.concat([node]);\n        var list = stack.map(function (n, i) {\n          if (n) {\n            var _text = n.descriptor;\n\n            if (i === stack.length - 1) {\n              _text = _util.chalk.cyanBright(_text);\n            } else {\n              _text = _util.chalk.green(_text);\n            }\n\n            return _text;\n          }\n\n          return '';\n        });\n        var result = list.join(_util.chalk.redBright(separator));\n\n        if (lastNode) {\n          result += _util.chalk.grey(\"\".concat(separator).concat(lastNode.descriptor));\n        }\n\n        return result;\n      };\n\n      var pushNode = function pushNode(n) {\n        if (node.start === -1) {\n          node.start = stream.pos;\n        }\n\n        nodeStack.push(node);\n        node = n;\n\n        _this.debug(\"push: \".concat(debugStack(), \"\\n\"));\n      };\n\n      var popNode = function popNode(error) {\n        var lastNode = node;\n        node.end = stream.pos;\n\n        if (node.start === node.end || node.type === _Node.NodeType.PARAGRAPH && !node.hasChild() && node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node = nodeStack.pop();\n\n        _this.debug(\"pop : \".concat(debugStack(lastNode), \"\\n\"));\n\n        if (!node) {\n          throw createError(error || 'unexpected closing node');\n        }\n      }; // replace wrapping paragraph with current block tag\n\n\n      var levelUpBlock = function levelUpBlock() {\n        if (node.parent && node.parent.type === _Node.NodeType.PARAGRAPH) {\n          var blockNode = node;\n          popNode();\n          node.removeChild(blockNode);\n          popNode();\n          node.appendChild(blockNode);\n          pushNode(blockNode);\n        }\n      };\n\n      var createError = function createError(message) {\n        var from;\n        var to;\n        from = stream.getPosition(lastPos);\n        to = stream.pos === lastPos ? stream.getPosition(lastPos + 1) : stream.getPosition();\n\n        _this.debug(\"error: '\".concat(message, \"' at \").concat(from.ln, \":\").concat(from.col));\n\n        _this.debug('current node:');\n\n        if (node) {\n          _this.debug(node.toJSON());\n        }\n\n        _this.debug('current parsing state:');\n\n        _this.debug(JSON.stringify(root, null, 2));\n\n        return new _ParseError.default(message, text, from, to);\n      };\n\n      while (state !== State.FINISH) {\n        // parse failure watcher\n        if (Date.now() - timeStart >= _constants.PROCESSING_TIMEOUT) {\n          this.debug('parsing timeout!');\n          state = State.FINISH;\n        }\n\n        if (state === lastState && lastPos === stream.pos) {\n          throw new Error('Parser fall into infinite loop!');\n        }\n\n        lastState = state;\n        lastPos = stream.pos;\n        this.debug(_util.chalk.magenta(\"# \".concat(getStateName(state), \", pos = \").concat(stream.pos)));\n\n        if (this.options.verbose) {\n          stream.debugState();\n        }\n\n        switch (state) {\n          case State.METADATA:\n            {\n              stream.eatWhile(_constants.P_WHITE_SPACES_EXT);\n              var metadataMatched = stream.match(_constants.T_METADATA_MARKER);\n\n              if (needMetadataMarker && !metadataMatched) {\n                state = State.NORMAL;\n                break;\n              }\n\n              if (metadataMatched || stream.match(_constants.P_ATTRIBUTE_LIST_MULTILINE, {\n                consume: false\n              })) {\n                node.states.metadata = true;\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.NORMAL:\n            {\n              if (stream.sol(true) || stream.eol(true)) {\n                stream.eatWhile(_constants.P_WHITE_SPACE);\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK)) {\n                popNode();\n\n                if (node.states.unwrapped) {\n                  popNode();\n                }\n\n                break;\n              }\n\n              start = stream.pos;\n\n              if (node.type !== _Node.NodeType.PARAGRAPH && !node.isInlineBlock && stream.sol(true)) {\n                var child = node.createChild(_Node.NodeType.PARAGRAPH, undefined, {\n                  start: start\n                });\n                pushNode(child);\n              }\n\n              var originalText = stream.readTo(_constants.P_MARKER, {\n                toEOF: true\n              });\n              var _text2 = originalText;\n\n              if (_text2) {\n                if (node.children.length === 0) {\n                  _text2 = _.trimStart(_text2);\n                }\n\n                _text2 = _text2.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, _constants.T_LINE_BREAK);\n                _text2 = _.trimEnd(_text2, _constants.T_LINE_BREAKS);\n\n                if (_text2) {\n                  node.appendText(_text2, {\n                    start: start,\n                    end: stream.pos\n                  });\n                }\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK, {\n                consume: false\n              })) {\n                state = State.NORMAL;\n              } else {\n                state = State.START;\n              }\n\n              break;\n            }\n\n          case State.START:\n            {\n              start = stream.pos;\n              var ch = stream.eat(_constants.P_MARKER);\n              _constants.P_LABEL_START.lastIndex = 0;\n\n              if (ch === _constants.T_SINGLE_LINE_COMMENT) {\n                var rest = stream.eatWhile(_constants.T_SINGLE_LINE_COMMENT);\n\n                if (rest.length === 0) {\n                  state = State.SINGLE_COMMENT;\n                } else {\n                  state = State.MULTIPLE_COMMENT;\n                }\n              } else if (ch === _constants.T_TAG_START) {\n                state = State.TAG_START;\n              } else if (_constants.P_LABEL_START.test(ch)) {\n                states.unwrapped = true;\n                state = State.TAG_START;\n              } else if (ch === _constants.T_TAG_END) {\n                states.isClosing = true;\n                state = State.TAG_END;\n              } else if (ch === _constants.T_ENTITY_START) {\n                state = State.ENTITY_START;\n              } else if (stream.eof()) {\n                state = State.END;\n              } else {\n                throw createError('empty start');\n              }\n\n              break;\n            }\n\n          case State.SINGLE_COMMENT:\n          case State.MULTIPLE_COMMENT:\n            {\n              start = stream.pos;\n              var content = void 0;\n\n              if (state === State.SINGLE_COMMENT) {\n                content = stream.readTo(_constants.P_LINE_BREAK);\n              } else {\n                content = stream.readTo(_constants.P_MULTIPLE_LINE_COMMENT, {\n                  skipMatched: true\n                });\n              }\n\n              if (content) {\n                if (state === State.MULTIPLE_COMMENT) {\n                  content = content.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n                }\n\n                content = _.trim(content);\n              }\n\n              if (content) {\n                node.createChild(_Node.NodeType.COMMENT, undefined, {\n                  start: start,\n                  end: stream.pos,\n                  content: content\n                });\n              }\n\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.TAG_START:\n            {\n              if (stream.eat(_constants.T_TAG_CLOSING)) {\n                states.isClosing = true;\n                state = State.TAG_NAME;\n              } else if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (node.type !== _Node.NodeType.ENTITY && (states.unwrapped || stream.eat(_constants.P_LABEL_START))) {\n                state = State.LABEL_START;\n              } else {\n                var _child = _Node.default.create(_Node.NodeType.TAG, '', {\n                  start: start\n                });\n\n                if (states.embedded) {\n                  _child.states.embedded = true;\n                  _child.states.metaKey = states.key;\n                  states.embedded = false;\n                } else {\n                  node.appendChild(_child);\n                }\n\n                pushNode(_child);\n                state = State.TAG_NAME;\n              }\n\n              if (state === State.NORMAL || state === State.LABEL_START) {\n                stream.pushCursor(start);\n                var tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n                stream.popCursor();\n\n                if (node.type === _Node.NodeType.PARAGRAPH && tagName === 'BLOCK') {\n                  popNode();\n                }\n\n                var _child2 = node.createChild(_Node.NodeType.TAG, tagName, {\n                  start: start,\n                  states: {\n                    simpleBlock: true,\n                    unwrapped: states.unwrapped\n                  }\n                });\n\n                states.unwrapped = false;\n                pushNode(_child2);\n              }\n\n              break;\n            }\n\n          case State.TAG_NAME:\n            {\n              var name = stream.match(_constants.P_TAG_NAME_MULTILINE);\n\n              if (!name) {\n                throw createError('expected tag name');\n              }\n\n              states.inline = name === 'INLINE';\n\n              if (states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  stream.pushCursor(start);\n                  popNode();\n                  stream.popCursor();\n                }\n\n                if (name !== node.name) {\n                  throw createError('unexpected closing tag');\n                }\n\n                var _ch = stream.eat(_constants.T_TAG_END);\n\n                if (!_ch) {\n                  throw createError('invalid closing tag');\n                }\n\n                if (!(states.inline || node.isInlineBlock) && !stream.eol()) {\n                  throw createError('closing block tag must take the whole line');\n                }\n\n                state = State.TAG_END;\n              } else {\n                node.name = name;\n\n                if (node.isWrappingTag) {\n                  stream.pushCursor(node.start || 0);\n\n                  if (node.name === 'BLOCK' && !stream.sol(true)) {\n                    throw createError('unexpected start of block inline');\n                  }\n\n                  stream.popCursor();\n\n                  if (node.isBlock) {\n                    levelUpBlock();\n                  }\n                }\n\n                state = State.ATTRIBUTE_LIST;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_LIST:\n            {\n              var spaces = stream.eatWhile(node.isInlineBlock || node.states.simpleBlock && !node.states.metadata ? _constants.P_WHITE_SPACE : _constants.P_WHITE_SPACES_EXT);\n              var isParsingMetadata = node.states.metadata;\n\n              if (isParsingMetadata) {\n                var endOfFrontMatter = false;\n\n                if (stream.match(_constants.T_METADATA_MARKER)) {\n                  if (!stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('expected new line after metadata closed');\n                  }\n\n                  endOfFrontMatter = true;\n                }\n\n                var lineBreaks = countLineBreaks(spaces);\n\n                if (lineBreaks > 1) {\n                  endOfFrontMatter = true;\n                }\n\n                if (endOfFrontMatter) {\n                  state = State.NORMAL;\n                  node.states.metadata = false;\n                  break;\n                } // deal with simple block at the beginning\n\n\n                if (node.type === _Node.NodeType.ROOT && !stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                }) && lineBreaks === 1) {\n                  var _child3 = node.createChild(_Node.NodeType.TAG, 'BLOCK', {\n                    labels: node.labels,\n                    states: {\n                      unwrapped: true\n                    },\n                    metadata: node.metadata\n                  });\n\n                  node.clearLabels();\n                  node.clearMetadata();\n                  pushNode(_child3);\n                  state = State.NORMAL;\n                  break;\n                }\n              }\n\n              if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (stream.eat(_constants.T_TAG_END)) {\n                state = State.TAG_END;\n              } else if (stream.match(_constants.P_LABEL_START)) {\n                state = State.LABEL_START;\n              } else {\n                if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n                  if (_.isEmpty(node.attributes) && _constants.P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                    states.key = node.name;\n                    node.name = 'BLOCK';\n                    node.states.simpleBlock = true;\n                    levelUpBlock();\n                    state = State.ATTRIBUTE_ASSIGN;\n                    break;\n                  } else {\n                    throw createError('expecting end of tag \"}\" or attribute list');\n                  }\n                }\n\n                if (stream.match(node.isInlineBlock || node.states.simpleBlock || node.states.metadata ? _constants.P_ATTRIBUTE_LIST : _constants.P_ATTRIBUTE_LIST_MULTILINE, {\n                  consume: false\n                })) {\n                  state = State.ATTRIBUTE_NAME;\n                } else {\n                  state = State.NORMAL;\n                }\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_NAME:\n            {\n              var _key = stream.match(node.isInlineBlock || node.states.simpleBlock ? _constants.P_ATTRIBUTE_NAME : _constants.P_ATTRIBUTE_NAME_MULTILINE);\n\n              if (!_key) {\n                throw createError('expecting attribute name');\n              }\n\n              states.key = _key;\n              state = State.ATTRIBUTE_ASSIGN;\n              break;\n            }\n\n          case State.ATTRIBUTE_ASSIGN:\n            {\n              var _ch2 = stream.peek();\n\n              if (_ch2 === _constants.T_TAG_END) {\n                state = State.ATTRIBUTE_FINISH;\n              } else {\n                _ch2 = stream.eat(_constants.P_ATTRIBUTE_ASSIGN);\n\n                if (!_ch2) {\n                  if (node.states.simpleBlock) {\n                    throw createError('expecting assignment \"=\" or \":\"');\n                  }\n\n                  states.value = true;\n                  state = State.ATTRIBUTE_FINISH;\n                  break;\n                }\n\n                if (_constants.P_ASSIGN_YAML.test(_ch2)) {\n                  stream.eatWhile(_constants.P_WHITE_SPACE);\n\n                  if (stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('unexpected end of line');\n                  }\n                }\n\n                state = State.ATTRIBUTE_VALUE;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_VALUE:\n            {\n              var _ch3 = stream.peek();\n\n              var _value = undefined;\n\n              if (_ch3 === _constants.T_TAG_START || _ch3 === _constants.T_ENTITY_START) {\n                states.embedded = true;\n                state = State.START;\n                break;\n              } else if (_ch3 === _constants.T_STRING_START) {\n                _value = stream.match(_constants.P_STRING_LITERAL_QUOTED);\n\n                try {\n                  _value = JSON.parse(_value);\n                } catch (e) {\n                  throw createError('invalid string literal');\n                }\n              } else if (attributeAsString) {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n              } else if (_value = stream.match(_constants.P_DATE_LITERAL)) {\n                _value = new Date(_value);\n              } else if (_value = stream.match(_constants.P_NUMBER_VALUE)) {\n                if (bigIntAsString) {\n                  _value = (0, _util.parseNumber)(_value);\n                } else {\n                  _value = parseFloat(_value);\n                }\n              } else if (stream.match(_constants.P_BOOLEAN_TRUE)) {\n                _value = true;\n              } else if (stream.match(_constants.P_BOOLEAN_FALSE)) {\n                _value = false;\n              } else {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n              }\n\n              if (_.isNull(_value)) {\n                throw createError('invalid attribute value');\n              }\n\n              states.value = _value;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n\n          case State.ATTRIBUTE_FINISH:\n            {\n              var _key2 = states.key,\n                  _value2 = states.value;\n              states.key = undefined;\n              states.value = undefined;\n\n              if (_.isUndefined(_value2)) {\n                _value2 = true;\n              }\n\n              if (node.states.metadata) {\n                node.setMetadata(_key2, _value2);\n              } else {\n                node.setAttribute(_key2, _value2);\n              }\n\n              this.debug(\"# \".concat(node.states.metadata ? 'metadata' : 'attribute', \" \").concat(_key2, \"=\").concat(JSON.stringify(_value2)));\n              this.debug();\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.TAG_END:\n            {\n              var parseMetadata = node.isBlockTag && !states.isClosing;\n              var tagNode = node;\n              states.inline = tagNode.isInlineBlock;\n\n              if (!node.isWrappingTag || states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  popNode();\n                }\n\n                popNode();\n\n                if (node.type === _Node.NodeType.ENTITY) {\n                  // copy tag properties to entity and remove temporary tag node\n                  node.setAttributes(tagNode.attributes);\n                  node.name = tagNode.name;\n                  node.removeChild(tagNode);\n                  state = State.ENTITY_END;\n                  tagNode = node;\n                  popNode();\n                }\n\n                if (tagNode.states.embedded) {\n                  if (node.states.metadata) {\n                    node.setMetadata(tagNode.states.metaKey, tagNode);\n                  } else {\n                    node.setAttribute(tagNode.states.metaKey, tagNode);\n                  }\n                }\n              }\n\n              if (states.isClosing && !states.inline) {\n                stream.skipOver(_constants.P_LINE_BREAK);\n              }\n\n              states.isClosing = false;\n              states.inline = false;\n\n              if (parseMetadata) {\n                state = State.METADATA;\n              } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.LABEL_START:\n            {\n              var label = stream.match(_constants.P_VAR_NAME);\n\n              if (!label) {\n                throw createError('expected label name');\n              }\n\n              node.addLabel(label);\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.ENTITY_START:\n            {\n              var _child4 = _Node.default.create(_Node.NodeType.ENTITY, '', {\n                start: start\n              });\n\n              if (states.embedded) {\n                _child4.states.embedded = true;\n                _child4.states.metaKey = states.key;\n                states.embedded = false;\n              } else {\n                node.appendChild(_child4);\n              }\n\n              pushNode(_child4);\n              state = State.ENTITY_BODY;\n              break;\n            }\n\n          case State.ENTITY_BODY:\n            {\n              start = stream.pos;\n\n              var _text3 = stream.readTo(_constants.T_ENTITY_END, {\n                skipMatched: true\n              });\n\n              if (!_text3) {\n                throw createError('empty entity');\n              } else if (_text3.search(_constants.P_LINE_BREAK) !== -1) {\n                throw createError('unexpected line break of entity');\n              }\n\n              node.appendText(_text3, {\n                start: start,\n                end: start + _text3.length\n              });\n\n              var _ch4 = stream.eat(_constants.T_TAG_START);\n\n              if (_ch4) {\n                state = State.TAG_START;\n              } else {\n                state = State.ENTITY_END;\n              }\n\n              break;\n            }\n\n          case State.ENTITY_END:\n            {\n              popNode();\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.END:\n            {\n              if (node.type !== _Node.NodeType.ROOT) {\n                popNode();\n              }\n\n              state = State.FINISH;\n              break;\n            }\n\n          case State.FINISH:\n            {\n              break;\n            }\n        }\n      }\n\n      root.toString();\n      this.parsed = true;\n      this.debug('parsed result:');\n      this.debug(JSON.stringify(root.toJSON(), null, 2));\n      return root;\n    }\n  }]);\n  return Tokenizer;\n}();\n\nvar _default = Tokenizer;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Class holding text line data\n */\n\n\nvar TextLine =\n/*#__PURE__*/\nfunction () {\n  function TextLine(lines, text, ln, offset) {\n    (0, _classCallCheck2.default)(this, TextLine);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"ln\", void 0);\n    (0, _defineProperty2.default)(this, \"offset\", void 0);\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n  /**\n   * Get the previous line\n   */\n\n\n  (0, _createClass2.default)(TextLine, [{\n    key: \"prev\",\n    value: function prev() {\n      return this.lines[this.ln - 2];\n    }\n    /**\n     * Get the next line\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.lines[this.ln];\n    }\n    /**\n     * Get text length of the line\n     */\n\n  }, {\n    key: \"toJSON\",\n\n    /**\n     * Convert to JSON serializable object\n     */\n    value: function toJSON() {\n      return {\n        ln: this.ln,\n        start: this.start,\n        end: this.end,\n        text: this.text\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n    /**\n     * Start position of the line, alias of `offset`\n     */\n\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.offset;\n    }\n    /**\n     * End position of the line\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n  }]);\n  return TextLine;\n}();\n\nvar _default = TextLine;\nexports.default = _default;"],"sourceRoot":""}