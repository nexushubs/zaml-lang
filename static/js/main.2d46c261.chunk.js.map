{"version":3,"sources":["Pane.tsx","codemirror-mode.ts","SourceEditor.tsx","VisualNode.tsx","VisualEditor.tsx","logo.svg","TreeNode.tsx","TreePathItem.tsx","TreePath.tsx","TreeToolbar.tsx","TreeView.tsx","Editor.tsx","sample/contract.ts","App.tsx","serviceWorker.ts","index.tsx","../../zaml-parser/lib/constants.js","../../zaml-parser/lib/Node.js","../../zaml-parser/lib/TextStream.js","../../zaml-parser/lib/Tokenizer.js","../../zaml-parser/lib/TextLine.js","../../zaml-parser/lib/ParseError.js","../../zaml-parser/lib/util.js","../../zaml-parser/lib/index.js"],"names":["Pane","props","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_this$props","title","className","children","react_default","a","createElement","classNames","React","Component","defaultProps","CodeMirror","defineSimpleMode","start","regex","token","next","indent","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","_this","state","value","nextProps","height","editor","setSize","_this2","onChange","react_codemirror2","options","onBeforeChange","data","setState","_onChange","_x","_x2","_x3","apply","arguments","toString","editorDidMount","NodeType","zaml","VisualNode","handleContextMenu","event","node","onContextMenu","preventDefault","stopPropagation","n","type","TEXT","parent","element","_this$props2","selectedNode","selected","ROOT","PARAGRAPH","ENTITY","name","node-name","href","attributes","url","assign","TAG","isBlock","_","isEmpty","push","content","key","map","child","i","id","concat","block","toLowerCase","VisualEditor","currentNode","contextMenu","show","onSelect","VisualNode_VisualNode","react_contexify_lib","disabled","onClick","_extends","target","length","source","prototype","hasOwnProperty","NodePart","_ref","_ref2","fill","d","_ref3","_ref4","cx","cy","r","_ref5","_ref6","x","y","width","rx","ry","_ref7","_ref8","points","logo_SvgComponent","data-name","viewBox","__webpack_require__","p","nil","TreeNode","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","indexOf","isRoot","Whole","Header","commonProps","_onMouseEnter","_onMouseOut","react","isWrappingTag","onlyText","isEntity","isTag","firstChild","nameStart","nameEnd","node-selected","undefined","labels","label","keys","JSON","stringify","truncate","Footer","TreePathItem","TreePath","nodeList","buildNodeList","includes","list","unshift","TreePathItem_TreePathItem","TreeToolbar","TreeView","toConsumableArray","without","nodeIds","path","union","onHover","_this$state","TreeToolbar_TreeToolbar","TreeNode_TreeNode","handleExpansionChange","TreePath_TreePath","Node","parse","create","err","createChild","text","message","Editor","sourcePaneHeight","onResize","throttle","bind","assertThisInitialized","window","addEventListener","passive","removeEventListener","innerHeight","hoveredNode","index_esm","split","defaultSize","minSize","Pane_Pane","SourceEditor_SourceEditor","VisualEditor_VisualEditor","TreeView_TreeView","contract","App","Editor_Editor","newValue","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","_interopRequireWildcard","defineProperty","exports","PROCESSING_TIMEOUT","P_MARKER","END_MARKERS","START_MARKERS","P_FULL_WIDTH_CHARACTER","P_BOOLEAN_FALSE","P_BOOLEAN_TRUE","P_STRING_LITERAL_UNQUOTED_TESTER","P_STRING_LITERAL_UNQUOTED","P_STRING_LITERAL_QUOTED","P_NUMBER_LITERAL","P_NUMBER_START","P_DATE_LITERAL","T_STRING_START","P_TAG_NAME","P_ATTRIBUTE_LIST","P_ATTRIBUTE_NAME","P_ATTRIBUTE_ASSIGN","P_LABEL_NAME","P_LABEL_START","P_LIST_SEPARATOR","P_WHITE_SPACES_EXT","P_WHITE_SPACE","P_PARAGRAPH_BREAK","P_SPACE_WRAPPED_LINE_BREAK","P_LINE_BREAK","P_ASSIGN_YAML","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","T_METADATA_FAVORED_ASSIGN","T_PARAGRAPH_BREAK","T_LINE_BREAKS","T_LINE_BREAK","T_ASSIGN_YAML","T_ASSIGN_XML","T_TAG_END","T_TAG_CLOSING","T_TAG_START","T_ENTITY_END","T_ENTITY_START","P_MULTIPLE_LINE_COMMENT","T_SINGLE_LINE_COMMENT","T_METADATA_MARKER","T_TAB","T_SPACE","DEFAULT_INDENT_SPACES","createPattern","combinePatterns","isRegExp","escapeRegExp","join","flags","RegExp","Infinity","_interopRequireDefault","find","_find","default","WrappingTags","BlockTags","BlockNodeTypes","NodeTypes","_regenerator","_asyncToGenerator2","_toConsumableArray2","_objectSpread2","_classCallCheck2","_createClass2","_defineProperty2","_util","_2","nanoid","values","defaultFinderCallback","testNode","pattern","isFunction","isString","is","TypeError","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","return","_findOne","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","parseJson","json","parseJsonMap","metadata","each","childData","appendChild","normalize","toJsonMap","mapValues","toJSON","isPlainObject","parseValue","_options$source","_options$start","_options$end","end","states","_options$attributes","_options$metadata","_options$labels","_options$content","_options$text","textStart","textEnd","_source","appendText","FRAGMENT","COMMENT","isArray","Error","expression","toUpperCase","test","substr","validNode","insertAt","pull","index","_this$children","splice","forEach","ref","validParent","refIndex","newChild","oldChild","contains","insertBefore","removeChild","validChild","replaceChild","set","merge","get","has","unset","isObject","toSource","selector","one","intersection","findBy","hasChild","findTextByRange","callback","items","console","warn","sortBy","fragment","createFragment","lastPos","item","substring","replaceWith","entities","_this3","cache","Map","textNode","createEntities","_extractEntities","mark","_callee","extractor","textList","wrap","_context","prev","extract","sent","stop","_options$position","position","_options$textPosition","textPosition","omitBy","isUndefined","isBlockTag","rootNode","getRootNode","first","last","siblings","childIndex","_default","enumerable","_TextLine","_chalk","_constants","LINE_BREAKS","TextStream","tabSize","pos","lines","markers","cursorStack","init","matched","offset","ln","lastIndex","exec","_text","_text2","lineOffsetIndexes","lineIndex","sortedLastIndex","line","col","trimSpaces","_this$getPosition","getPosition","trimStart","_this$getPosition2","trimEnd","charAt","ok","ch","lastMatch","chr","string","eat","eof","peek","caseInsensitive","left","_options$toEOL","toEOL","_options$toEOF","toEOF","_options$consume","consume","_options$skipMatched","skipMatched","_this$search","search","readTo","nextLine","read","_options$consume2","_this$search2","marker","extend","_data","pop","trim","numWidth","bgBlue","log","blueBright","padStart","replace","repeat","range","_this$getPosition5","slice","max","min","l","isCurrent","debugLine","debugCursor","process","State","_TextStream","_ParseError","_Node","stateNames","getStateName","countLineBreaks","Tokenizer","stream","defaultOptions","verbose","NODE_ENV","PUBLIC_URL","DEBUG","defaults","parsed","_console","timeStart","Date","now","METADATA","lastState","unwrapped","inline","embedded","isClosing","root","nodeStack","getNodeString","debugStack","lastNode","stack","cyanBright","green","redBright","grey","pushNode","debug","popNode","error","createError","levelUpBlock","blockNode","FINISH","magenta","debugState","eatWhile","ATTRIBUTE_LIST","NORMAL","sol","eol","isInlineBlock","START","SINGLE_COMMENT","MULTIPLE_COMMENT","TAG_START","TAG_END","ENTITY_START","END","TAG_NAME","LABEL_START","_child","metaKey","pushCursor","tagName","popCursor","_child2","simpleBlock","spacePattern","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","_child3","clearLabels","clearMetadata","ATTRIBUTE_ASSIGN","ATTRIBUTE_NAME","_key","_ch2","ATTRIBUTE_FINISH","eatSpaces","ATTRIBUTE_VALUE","_ch3","_value","parseFloat","isNull","_key2","_value2","setMetadata","setAttribute","parseMetadata","tagNode","setAttributes","ENTITY_END","skipOver","addLabel","_child4","ENTITY_BODY","TextLine","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_wrapNativeSuper2","ParseError","_Error","formatValue","P_DATE_FORMAT","spacer","isNumber","space","simple","simpleTag","isSimpleTag","listCount","isBoolean","subText","nextSibling","isLastChild","isDate","toISOString","isNaN","tokenize","_Tokenizer"],"mappings":"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","file":"static/js/main.2d46c261.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport './Editor.css';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[\\{]/, indent: true},\n    {regex: /[\\}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes, { number } from 'prop-types';\nimport classNames from 'classnames';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport './codemirror-mode';\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.props.height !== nextProps.height && this.editor) {\n      this.editor.setSize(null, nextProps.height);\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.css';\n\nconst { NodeType } = zaml;\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onContextMenu: (event: React.MouseEvent, node: zaml.Node) => void;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n    onContextMenu: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  handleContextMenu = (event: React.MouseEvent) => {\n    const { node, onContextMenu } = this.props;\n    event.preventDefault();\n    event.stopPropagation();\n    let n = node;\n    if (n && n.type === NodeType.TEXT) {\n      n = n.parent;\n    }\n    if (n) {\n      onContextMenu(event, n);\n    }\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            href={node.attributes.url}\n          >\n            <VisualNode {...this.props} node={node.children[0]} />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      id: `vn${node.id}`,\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      onContextMenu: this.handleContextMenu,\n    }, children);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { contextMenu, Menu, Item } from 'react-contexify';\nimport VisualNode from './VisualNode';\nimport './VisualEditor.css';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  node?: zaml.Node;\n}\n\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    onSelect: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n    contextMenu.show({ id: 'menu', event });\n  }\n\n  render() {\n    const { node, selectedNode, onSelect } = this.props;\n    const { node: n } = this.state;\n    return (\n      <div className=\"zaml-visual-editor\">\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n          onContextMenu={this.handleContextMenu}\n        />\n        <Menu id=\"menu\">\n          <Item disabled>{n ? (`${n.type}${n.name ? `:${n.name}` : ''}`) : '???'}</Item>\n          <Item onClick={() => onSelect(n)}>Inspect</Item>\n        </Menu>\n      </div>\n    )\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar _ref =\n/*#__PURE__*/\nReact.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref4 =\n/*#__PURE__*/\nReact.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref5 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref6 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref7 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref8 =\n/*#__PURE__*/\nReact.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgComponent = function SvgComponent(props) {\n  return React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\"\n  }, props), _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n};\n\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { SvgComponent as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.css';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      const isEntity = node.type === NodeType.ENTITY;\n      const isTag = node.type === NodeType.TAG;\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      const nameStart = isEntity ? '[' : isTag ? '{' : '<';\n      const nameEnd = isEntity ? ']' : isTag ? '}' : '>';\n      let name = (isTag || isEntity) ? node.name : node.type;\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            ></span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {nameStart}\n            {name}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {nameEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {nameStart}\n            /\n            {name}\n            {nameEnd}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\nimport { NodePart } from './TreeNode';\nimport './TreeView.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    let name: string = '';\n    if (node.type === NodeType.TEXT) {\n      name = '(text)'\n    } else if (node.type === NodeType.TAG) {\n      name = `{${node.name}}`;\n    } else if (node.type === NodeType.ENTITY) {\n      name = `[${node.name}]`;\n    } else {\n      name = node.type;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {name}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport './TreeView.css';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreeView.css';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport './TreeView.css';\nimport TreePath from './TreePath';\nimport { nodeEquals } from './utils';\nimport TreeToolbar from './TreeToolbar';\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart,\n  expandedNodes: string[];\n}\n\nconst nil = () => {}\n\nexport default class TreeView extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n  }\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds),\n      });\n    }\n  }\n\n  render() {\n    const { node, selectedNode, onSelect, onHover } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <TreeToolbar />\n        <div className=\"tree\">\n          <TreeNode\n            node={node}\n            selectedNode={selectedNode}\n            selectedPart={selectedPart}\n            expandedNodes={expandedNodes}\n            onSelect={onSelect}\n            onSelectPart={p => this.setState({ selectedPart: p })}\n            onMouseEnter={onHover}\n            onMouseOut={() => onHover()}\n            onExpansionChange={(n: zaml.Node, expanded: boolean) => this.handleExpansionChange(n, expanded)}\n          />\n        </div>\n        <TreePath\n          selectedNode={selectedNode}\n          onSelect={onSelect}\n        />\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from './SourceEditor';\nimport VisualEditor from './VisualEditor';\nimport './Editor.css';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from './TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  className: string;\n  value: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  node: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source);\n  } catch(err) {\n    node.createChild(NodeType.PARAGRAPH, undefined, { text: `Error: ${err.message}` });\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    const node = parse(props.value);\n    this.state = {\n      node,\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.props.value !== nextProps.value) {\n      this.setState({\n        node: parse(nextProps.value),\n      });\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  render() {\n    const { value, onChange } = this.props;\n    const { node, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={value}\n                height={sourcePaneHeight - 40}\n                onChange={onChange}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  node={node}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  node={node}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","export default \n`#\n[]{ORG}\n[345976348]{SOC}\n[]{PER}\n[D2806]{LOC}\n[]{PER}\n[230101197701018888]{ID}\n[13945018888]{MOBILE}\n---\n\n\n\n#. #\n{#. #. #. [37]{LOC}[]{QT}}{#. [105]{AREA}}{#.. [201911]{DATE}[20191231]{DATE}}{#.. []{MONEY value=100000}}\n\n#..\n\n\n#.. #...\n{#... []{DATE}}\n\n#... #.\n[]{DUE}[]{MONEY}\n\n#... #...\n\n\n#\n{#... []{DUE}[]{MONEY}}{#.. #. #. []{DUE}}\n\n{#. #\n  \n\n  #. #.. #.. #....\n  1. []{PERIOD}[1%]{RATE}\n\n  #. #... #.... #..\n  2. []{PERIOD}[100]{DATE}\n}\n\n{#. #.\n  \n\n  #...\n  1. \n\n  #..\n  2. \n}\n\n# #.. #..\n\n`;\n","import React, { Component } from 'react';\nimport './App.css';\nimport Editor from './Editor';\nimport contract from './sample/contract';\n\ninterface State {\n  value: string;\n}\n\nclass App extends Component<{}, State> {\n\n  state = {\n    value: contract,\n  };\n\n  render() {\n    const { value } = this.state;\n    return (\n      <div className=\"App\">\n        <Editor value={value} onChange={newValue => this.setState({ value: newValue })} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROCESSING_TIMEOUT = exports.P_MARKER = exports.END_MARKERS = exports.START_MARKERS = exports.P_FULL_WIDTH_CHARACTER = exports.P_BOOLEAN_FALSE = exports.P_BOOLEAN_TRUE = exports.P_STRING_LITERAL_UNQUOTED_TESTER = exports.P_STRING_LITERAL_UNQUOTED = exports.P_STRING_LITERAL_QUOTED = exports.P_NUMBER_LITERAL = exports.P_NUMBER_START = exports.P_DATE_LITERAL = exports.T_STRING_START = exports.P_TAG_NAME = exports.P_ATTRIBUTE_LIST = exports.P_ATTRIBUTE_NAME = exports.P_ATTRIBUTE_ASSIGN = exports.P_LABEL_NAME = exports.P_LABEL_START = exports.P_LIST_SEPARATOR = exports.P_WHITE_SPACES_EXT = exports.P_WHITE_SPACE = exports.P_PARAGRAPH_BREAK = exports.P_SPACE_WRAPPED_LINE_BREAK = exports.P_LINE_BREAK = exports.P_ASSIGN_YAML = exports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = exports.T_METADATA_FAVORED_ASSIGN = exports.T_PARAGRAPH_BREAK = exports.T_LINE_BREAKS = exports.T_LINE_BREAK = exports.T_ASSIGN_YAML = exports.T_ASSIGN_XML = exports.T_TAG_END = exports.T_TAG_CLOSING = exports.T_TAG_START = exports.T_ENTITY_END = exports.T_ENTITY_START = exports.P_MULTIPLE_LINE_COMMENT = exports.T_SINGLE_LINE_COMMENT = exports.T_METADATA_MARKER = exports.T_TAB = exports.T_SPACE = exports.DEFAULT_INDENT_SPACES = exports.createPattern = exports.combinePatterns = void 0;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar combinePatterns = function combinePatterns(list) {\n  return list.map(function (p) {\n    return _.isRegExp(p) ? p.source : _.escapeRegExp(p);\n  }).join('|');\n};\n\nexports.combinePatterns = combinePatterns;\n\nvar createPattern = function createPattern(source) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'g';\n  return new RegExp(source, flags);\n};\n\nexports.createPattern = createPattern;\nvar DEFAULT_INDENT_SPACES = 2;\nexports.DEFAULT_INDENT_SPACES = DEFAULT_INDENT_SPACES;\nvar T_SPACE = ' ';\nexports.T_SPACE = T_SPACE;\nvar T_TAB = '\\t';\nexports.T_TAB = T_TAB;\nvar T_METADATA_MARKER = \"---\";\nexports.T_METADATA_MARKER = T_METADATA_MARKER;\nvar T_SINGLE_LINE_COMMENT = '~';\nexports.T_SINGLE_LINE_COMMENT = T_SINGLE_LINE_COMMENT;\nvar P_MULTIPLE_LINE_COMMENT = '~{3,}';\nexports.P_MULTIPLE_LINE_COMMENT = P_MULTIPLE_LINE_COMMENT;\nvar T_ENTITY_START = '[';\nexports.T_ENTITY_START = T_ENTITY_START;\nvar T_ENTITY_END = ']';\nexports.T_ENTITY_END = T_ENTITY_END;\nvar T_TAG_START = '{';\nexports.T_TAG_START = T_TAG_START;\nvar T_TAG_CLOSING = '/';\nexports.T_TAG_CLOSING = T_TAG_CLOSING;\nvar T_TAG_END = '}';\nexports.T_TAG_END = T_TAG_END;\nvar T_ASSIGN_XML = '=';\nexports.T_ASSIGN_XML = T_ASSIGN_XML;\nvar T_ASSIGN_YAML = ':';\nexports.T_ASSIGN_YAML = T_ASSIGN_YAML;\nvar T_LINE_BREAK = '\\n';\nexports.T_LINE_BREAK = T_LINE_BREAK;\nvar T_LINE_BREAKS = '\\r\\n';\nexports.T_LINE_BREAKS = T_LINE_BREAKS;\nvar T_PARAGRAPH_BREAK = '\\n\\n';\nexports.T_PARAGRAPH_BREAK = T_PARAGRAPH_BREAK;\nvar T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexports.T_METADATA_FAVORED_ASSIGN = T_METADATA_FAVORED_ASSIGN;\nvar T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\nexports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_TAG_ATTRIBUTE_FAVORED_ASSIGN;\nvar P_ASSIGN_YAML = /[:]/;\nexports.P_ASSIGN_YAML = P_ASSIGN_YAML;\nvar P_LINE_BREAK = /\\r?\\n/g;\nexports.P_LINE_BREAK = P_LINE_BREAK;\nvar P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexports.P_SPACE_WRAPPED_LINE_BREAK = P_SPACE_WRAPPED_LINE_BREAK;\nvar P_PARAGRAPH_BREAK = createPattern(\"\".concat(P_LINE_BREAK.source, \"\\\\s*\").concat(P_LINE_BREAK.source));\nexports.P_PARAGRAPH_BREAK = P_PARAGRAPH_BREAK;\nvar P_WHITE_SPACE = /[ \\t]/g;\nexports.P_WHITE_SPACE = P_WHITE_SPACE;\nvar P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexports.P_WHITE_SPACES_EXT = P_WHITE_SPACES_EXT;\nvar P_LIST_SEPARATOR = /[,]/g;\nexports.P_LIST_SEPARATOR = P_LIST_SEPARATOR;\nvar P_LABEL_START = /[#]/g;\nexports.P_LABEL_START = P_LABEL_START;\nvar P_LABEL_NAME = /(?:[A-Za-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\.0-9A-Z_a-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])*/g;\nexports.P_LABEL_NAME = P_LABEL_NAME;\nvar P_ATTRIBUTE_ASSIGN = createPattern(\"[\".concat([T_ASSIGN_XML, T_ASSIGN_YAML].join(''), \"]\"), '');\nexports.P_ATTRIBUTE_ASSIGN = P_ATTRIBUTE_ASSIGN;\nvar P_ATTRIBUTE_NAME = createPattern(\"(?:\".concat(P_LABEL_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"), 'gu');\nexports.P_ATTRIBUTE_NAME = P_ATTRIBUTE_NAME;\nvar P_ATTRIBUTE_LIST = createPattern(\"(\".concat(P_LABEL_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"|\").concat(P_LABEL_START.source).concat(P_LABEL_NAME.source, \")\"));\nexports.P_ATTRIBUTE_LIST = P_ATTRIBUTE_LIST;\nvar P_TAG_NAME = P_ATTRIBUTE_NAME;\nexports.P_TAG_NAME = P_TAG_NAME;\nvar T_STRING_START = '\"';\nexports.T_STRING_START = T_STRING_START;\nvar P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\d(?:T[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?/g;\nexports.P_DATE_LITERAL = P_DATE_LITERAL;\nvar P_NUMBER_START = /[\\d\\.]/;\nexports.P_NUMBER_START = P_NUMBER_START;\nvar P_NUMBER_LITERAL = /(\\d+|\\d*\\.\\d+|\\d+\\.\\d*)(e\\d+)?/g;\nexports.P_NUMBER_LITERAL = P_NUMBER_LITERAL;\nvar P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\.)*\"/g;\nexports.P_STRING_LITERAL_QUOTED = P_STRING_LITERAL_QUOTED;\nvar P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexports.P_STRING_LITERAL_UNQUOTED = P_STRING_LITERAL_UNQUOTED;\nvar P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(\"^\".concat(P_STRING_LITERAL_UNQUOTED.source, \"$\"));\nexports.P_STRING_LITERAL_UNQUOTED_TESTER = P_STRING_LITERAL_UNQUOTED_TESTER;\nvar P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexports.P_BOOLEAN_TRUE = P_BOOLEAN_TRUE;\nvar P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexports.P_BOOLEAN_FALSE = P_BOOLEAN_FALSE;\nvar P_FULL_WIDTH_CHARACTER = /(?:[\\xD7\\u2014\\u2026\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3001\\u3002\\u3005\\u3007\\u300A-\\u300D\\u3010\\u3011\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFF01\\uFF03\\uFF05\\uFF06\\uFF08\\uFF09\\uFF0B-\\uFF0D\\uFF1A\\uFF1B\\uFF1D\\uFF1F\\uFF20\\uFFE5]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])/g;\nexports.P_FULL_WIDTH_CHARACTER = P_FULL_WIDTH_CHARACTER;\nvar START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexports.START_MARKERS = START_MARKERS;\nvar END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexports.END_MARKERS = END_MARKERS;\nvar P_MARKER = createPattern(\"(\".concat(combinePatterns([P_PARAGRAPH_BREAK].concat(START_MARKERS, [T_TAG_END, P_MULTIPLE_LINE_COMMENT, T_SINGLE_LINE_COMMENT])), \")\"));\nexports.P_MARKER = P_MARKER;\nvar PROCESSING_TIMEOUT = Infinity;\nexports.PROCESSING_TIMEOUT = PROCESSING_TIMEOUT;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = _find;\nexports.default = exports.WrappingTags = exports.BlockTags = exports.BlockNodeTypes = exports.NodeTypes = exports.NodeType = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _2 = require(\".\");\n\nvar nanoid = require('nanoid');\n\nvar NodeType;\nexports.NodeType = NodeType;\n\n(function (NodeType) {\n  NodeType[\"FRAGMENT\"] = \"fragment\";\n  NodeType[\"ROOT\"] = \"root\";\n  NodeType[\"PARAGRAPH\"] = \"paragraph\";\n  NodeType[\"TAG\"] = \"tag\";\n  NodeType[\"ENTITY\"] = \"entity\";\n  NodeType[\"TEXT\"] = \"text\";\n  NodeType[\"COMMENT\"] = \"comment\";\n})(NodeType || (exports.NodeType = NodeType = {}));\n\nvar NodeTypes = _.values(NodeType);\n\nexports.NodeTypes = NodeTypes;\nvar BlockNodeTypes = [NodeType.ROOT, NodeType.PARAGRAPH];\nexports.BlockNodeTypes = BlockNodeTypes;\nvar BlockTags = ['BLOCK', 'QUOTE', 'SECTION', 'HEADER', 'FOOTER'];\nexports.BlockTags = BlockTags;\nvar WrappingTags = BlockTags.concat(['INLINE', 'NUM', 'HEADING']);\nexports.WrappingTags = WrappingTags;\n\nvar defaultFinderCallback = function defaultFinderCallback(node) {\n  return true;\n};\n\nfunction testNode(pattern, node) {\n  if (_.isFunction(pattern)) {\n    return pattern(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\n\n\nfunction _find(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        _find(childNode, pattern, result);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\n\n\nfunction _findOne(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n\n  if (testNode(pattern, node)) {\n    return node;\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var childNode = _step2.value;\n\n        var result = _findOne(childNode, pattern);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    ;\n  }\n\n  return undefined;\n}\n\nfunction parseJson(json) {\n  var node = Node.create(json.type, json.name, {\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content\n  });\n\n  if (json.children) {\n    _.each(json.children, function (childData) {\n      node.appendChild(parseJson(childData));\n    });\n  }\n\n  node.normalize();\n  return node;\n}\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\n\n\nfunction toJsonMap(map) {\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n\n  return _.mapValues(map, function (value) {\n    if (value instanceof Node) {\n      return value.toJSON();\n    }\n\n    return value;\n  });\n}\n\nfunction parseJsonMap(json) {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n\n  return _.mapValues(json, function (value) {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n\n    return (0, _util.parseValue)(value);\n  });\n}\n/**\n * AST node class\n * @class\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Node, null, [{\n    key: \"create\",\n\n    /**\n     * @param type \n     * @param [name]\n     * @param [options]\n     */\n    value: function create(type, name, options) {\n      return new Node(type, name, options);\n    }\n    /**\n     * Create node instance from ZAML source\n     * @param source \n     */\n\n  }, {\n    key: \"fromSource\",\n    value: function fromSource(source) {\n      return (0, _2.parse)(source);\n    }\n    /**\n     * Create node from json serializable data\n     * @param {object} json \n     * @returns {Node}\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return parseJson(json);\n    }\n    /**\n     * Creating fragment node\n     * @returns {Node}\n     */\n\n  }, {\n    key: \"createFragment\",\n    value: function createFragment() {\n      return Node.create(NodeType.FRAGMENT);\n    }\n    /**\n     * Check if a node is valid\n     * @param node \n     */\n\n  }, {\n    key: \"validNode\",\n    value: function validNode(node) {\n      if (!(node instanceof Node)) {\n        throw new TypeError('invalid node');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validParent\",\n    value: function validParent(node) {\n      if (!_.isArray(node.children)) {\n        throw new Error('node is not a valid parent');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validChild\",\n    value: function validChild(node) {\n      if (!node.parent) {\n        throw new Error('node is not a valid child');\n      }\n    }\n  }]);\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [options]\n   */\n\n  function Node(type, name) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Node);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", '');\n    (0, _defineProperty2.default)(this, \"type\", void 0);\n    (0, _defineProperty2.default)(this, \"name\", void 0);\n    (0, _defineProperty2.default)(this, \"start\", -1);\n    (0, _defineProperty2.default)(this, \"end\", -1);\n    (0, _defineProperty2.default)(this, \"textStart\", -1);\n    (0, _defineProperty2.default)(this, \"textEnd\", -1);\n    (0, _defineProperty2.default)(this, \"states\", void 0);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"labels\", void 0);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"content\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", '');\n    (0, _defineProperty2.default)(this, \"children\", void 0);\n    var _options$source = options.source,\n        source = _options$source === void 0 ? '' : _options$source,\n        _options$start = options.start,\n        start = _options$start === void 0 ? -1 : _options$start,\n        _options$end = options.end,\n        end = _options$end === void 0 ? -1 : _options$end,\n        states = options.states,\n        _options$attributes = options.attributes,\n        attributes = _options$attributes === void 0 ? {} : _options$attributes,\n        _options$metadata = options.metadata,\n        metadata = _options$metadata === void 0 ? {} : _options$metadata,\n        _options$labels = options.labels,\n        labels = _options$labels === void 0 ? [] : _options$labels,\n        parent = options.parent,\n        _options$content = options.content,\n        content = _options$content === void 0 ? '' : _options$content,\n        _options$text = options.text,\n        text = _options$text === void 0 ? '' : _options$text;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(\"invalid node type \".concat(type));\n    }\n\n    this.id = nanoid();\n    /**\n     * Parser states\n     * @type {Object<string,any>}\n     */\n\n    this.states = states || {};\n    /**\n     * @type {NodeType}\n     * @description Node type\n     */\n\n    this.type = type;\n    /**\n     * @type {string}\n     * @description Node name, for tag, entity\n     */\n\n    this.name = undefined;\n    /**\n     * @type {number}\n     * @description Start source position to root node\n     */\n\n    this.start = start;\n    /**\n     * @type {number}\n     * @description End source position to root node\n     */\n\n    this.end = end;\n    /**\n     * @type {number}\n     * @description Start text source position to root node\n     */\n\n    this.textStart = -1;\n    /**\n     * @type {number}\n     * @description End text source position to root node\n     */\n\n    this.textEnd = -1;\n    /**\n     * @private\n     * @type {Node}\n     * @description Parent node\n     */\n\n    this.parent = parent;\n    /**\n     * @private\n     * @type {string}\n     * @description Source code string, only for root node\n     */\n\n    this._source = undefined;\n    /**\n     * @type {string}\n     * @description Text content, only for text node\n     */\n\n    this.content = undefined;\n    /**\n     * @type {Node[]}\n     * @description Child nodes, only for block node\n     */\n\n    this.children = [];\n    /**\n     * @type {string[]}\n     * @description node labels\n     */\n\n    this.labels = [];\n    /**\n     * @type {Object.<string,any>}\n     * @description Attributes, for root, tag, entity node\n     */\n\n    this.attributes = {};\n    /**\n     * @type {Object.<string,any>}\n     * @description Block metadata\n     */\n\n    this.metadata = {};\n    /**\n     * @type {string[]}\n     * @description Node labels\n     */\n\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n\n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n  /**\n   * Check if the node is tag\n   */\n\n\n  (0, _createClass2.default)(Node, [{\n    key: \"getRootNode\",\n\n    /**\n     * Property indicates if the root is root (which has no children)\n     */\n    value: function getRootNode() {\n      var node = this;\n\n      while (node.parent) {\n        node = node.parent;\n      }\n\n      if (node === this) {\n        return undefined;\n      }\n\n      return node;\n    }\n    /**\n     * Check node match the expression\n     * @example\n     * `BLOCK`: tag\n     * `@LOC`: entity\n     * @param expression \n     */\n\n  }, {\n    key: \"is\",\n    value: function is(expression) {\n      if (!_.isString(expression)) {\n        return false;\n      }\n\n      expression = expression.toUpperCase();\n\n      if (/^[A-Z]/.test(expression)) {\n        return this.type === NodeType.TAG && this.name === expression;\n      } else if (/^#/.test(expression)) {\n        return this.type === NodeType.TAG && this.labels.includes(expression.substr(1));\n      } else if (/^@[A-Z]/.test(expression)) {\n        return this.type === NodeType.ENTITY && this.name === expression.substr(1);\n      }\n\n      return false;\n    }\n    /**\n     * whether a node is a descendant of a given node\n     * @param node \n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      Node.validNode(node);\n\n      while (node) {\n        if (node === this) {\n          return true;\n        }\n\n        if (!node.parent) {\n          return false;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Get a list of ancestors\n     */\n\n  }, {\n    key: \"hasChild\",\n\n    /**\n     * Check if this node has any children\n     */\n    value: function hasChild() {\n      return !_.isEmpty(this.children);\n    }\n    /**\n     * Create a child node\n     * @param type \n     * @param [name]\n     * @param [options]\n     */\n\n  }, {\n    key: \"createChild\",\n    value: function createChild(type, name, options) {\n      var node = new Node(type, name, options);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Append a node to children list\n     * @param node \n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.insertAt(node, Infinity);\n    }\n    /**\n     * Append text node child\n     * @param text \n     * @param [options] \n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, options) {\n      return this.createChild(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, options, {\n        content: text\n      }));\n    }\n    /**\n     * Remove 1 or more children\n     * @param node\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      _.pull(this.children, node);\n\n      node.parent = undefined;\n      return node;\n    }\n    /**\n     * Insert a node at specified position\n     * @param node \n     * @param index \n     */\n\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(node, index) {\n      var _this = this;\n\n      if (node.type === NodeType.FRAGMENT) {\n        var _this$children;\n\n        (_this$children = this.children).splice.apply(_this$children, [index, 0].concat((0, _toConsumableArray2.default)(node.children)));\n\n        node.children.forEach(function (child) {\n          return child.parent = _this;\n        });\n        node.children = [];\n      } else {\n        this.children.splice(index, 0, node);\n        node.parent = this;\n      }\n\n      return node;\n    }\n    /**\n     * Insert a node before another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex);\n      return node;\n    }\n    /**\n     * Insert a node after another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex + 1);\n      return node;\n    }\n    /**\n     * Replace a child with another node, assuming current node is a parent\n     * @param newChild \n     * @param oldChild \n     * @returns The replaced child\n     */\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      Node.validParent(this);\n\n      if (newChild.contains(this)) {\n        throw new TypeError('the new child contains the parent');\n      }\n\n      if (oldChild.parent !== this) {\n        throw new TypeError('the old child is not a child of this node');\n      }\n\n      this.insertBefore(newChild, oldChild);\n      this.removeChild(oldChild);\n      return oldChild;\n    }\n    /**\n     * Replace current child node with another node, assuming current node is child\n     * @param node Node to be replaced with\n     */\n\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(node) {\n      Node.validChild(this);\n\n      if (!this.parent) {\n        throw new Error('can not replace isolated node');\n      }\n\n      this.parent.replaceChild(node, this);\n      return node;\n    }\n    /**\n     * Set single attribute value\n     * @param {string} key Attribute key\n     * @param {any} value Attribute value\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      _.set(this.attributes, key, value);\n    }\n    /**\n     * Set multiple attributes\n     * @param data Key-value pair\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(data) {\n      _.merge(this.attributes, data);\n    }\n    /**\n     * Get attribute value\n     * @param key \n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return _.get(this.attributes, key);\n    }\n    /**\n     * Check if a specified attribute key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return _.has(this.attributes, key);\n    }\n    /**\n     * Remove an attribute\n     * @param {string} key \n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      _.unset(this.attributes, key);\n    }\n    /**\n     * Remove all attributes\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes() {\n      this.attributes = {};\n    }\n    /**\n     * Set single metadata value\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(key, value) {\n      if (_.isObject(key)) {\n        _.merge(this.metadata, key);\n      } else {\n        _.set(this.metadata, key, value);\n      }\n    }\n    /**\n     * Get metadata value\n     * @param key \n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(key) {\n      return _.get(this.metadata, key);\n    }\n    /**\n     * Remove a metadata\n     * @param key \n     */\n\n  }, {\n    key: \"removeMetadata\",\n    value: function removeMetadata(key) {\n      _.unset(this.metadata, key);\n    }\n    /**\n     * Remove all metadata\n     */\n\n  }, {\n    key: \"clearMetadata\",\n    value: function clearMetadata() {\n      this.metadata = {};\n    }\n    /**\n     * Check if a specified metadata key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasMetadata\",\n    value: function hasMetadata(key) {\n      return _.has(this.metadata, key);\n    }\n    /**\n     * Add label to node\n     * @param label \n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(label) {\n      if (!_.isString(label)) {\n        throw new TypeError('label must be string');\n      }\n\n      if (!this.labels.includes(label)) {\n        this.labels.push(label);\n      }\n    }\n    /**\n     * Check if the node has specified label\n     * @param label \n     */\n\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(label) {\n      return this.labels.includes(label);\n    }\n    /**\n     * Remove label\n     * @param label \n     */\n\n  }, {\n    key: \"removeLabel\",\n    value: function removeLabel(label) {\n      _.pull(this.labels, label);\n    }\n    /**\n     * Remove all labels\n     */\n\n  }, {\n    key: \"clearLabels\",\n    value: function clearLabels() {\n      this.labels = [];\n    }\n    /**\n     * Rebuild text and source position, in case modification has been applied to node\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var source = this.toSource();\n\n      if (this.isRoot) {\n        this._source = source;\n      }\n\n      this.toString();\n    }\n    /**\n     * Find matched descendants recursively\n     * @param selector Node selector object\n     * @param [one] Find the first matched node or a list of node\n     */\n\n  }, {\n    key: \"findBy\",\n    value: function findBy() {\n      var _this2 = this;\n\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var type = selector.type,\n          name = selector.name,\n          text = selector.text,\n          source = selector.source,\n          label = selector.label;\n      var finder = one ? _findOne : _find;\n      return finder(this, function (node) {\n        var match = true;\n\n        if (type) {\n          match = match && type === node.type;\n        }\n\n        if (name) {\n          match = match && name === node.name;\n        }\n\n        if (text && node.type === NodeType.TEXT && node.content) {\n          if (_.isRegExp(text)) {\n            match = match && !!text.match(node.content);\n          } else if (_.isString(text)) {\n            match = match && node.content.includes(text);\n          } else {\n            throw new TypeError('text filter should be RegExp or string');\n          }\n        }\n\n        if (source && node._source) {\n          if (_.isRegExp(source)) {\n            match = match && !!source.match(node._source);\n          } else if (_.isString(source)) {\n            match = match && node._source.includes(source);\n          } else {\n            throw new TypeError('source filter should be RegExp or string');\n          }\n        }\n\n        if (label) {\n          if (_.isArray(label)) {\n            match = match && _.intersection(_this2.labels, label).length > 0;\n          } else {\n            match = match && _this2.labels.includes(label);\n          }\n        }\n\n        return match;\n      });\n      ;\n    }\n    /**\n     * Find nodes by selector recursively and return the first one\n     * @param selector \n     */\n\n  }, {\n    key: \"findOneBy\",\n    value: function findOneBy() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.findBy(selector, true);\n    }\n    /**\n     * Find matched text node by text source range\n     * @param start \n     * @param end \n     */\n\n  }, {\n    key: \"findTextByRange\",\n    value: function findTextByRange(start, end) {\n      if (this.textStart === undefined || this.textEnd === undefined) {\n        return undefined;\n      }\n\n      if (this.textStart <= start && this.textEnd >= end) {\n        if (this.type === NodeType.TEXT) {\n          return this;\n        } else if (this.hasChild()) {\n          for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            var match = child.findTextByRange(start, end);\n\n            if (match) {\n              return match;\n            }\n          }\n\n          ;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Find matched children recursively by callback\n     * @param callback\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback) {\n      return _find(this, callback);\n    }\n    /**\n     * Find matched children recursively and return the first one\n     * @param callback\n     */\n\n  }, {\n    key: \"findOne\",\n    value: function findOne(callback) {\n      return _findOne(this, callback);\n    }\n    /**\n     * Find all nodes by selector, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return _find(this, selector);\n    }\n    /**\n     * Find nodes by selector and return the first one, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return _findOne(this, selector);\n    }\n    /**\n     * Process text node in current node and parse entities\n     */\n\n  }, {\n    key: \"createEntities\",\n    value: function createEntities(items) {\n      if (this.type !== NodeType.TEXT) {\n        console.warn('extractEntity() should exec only on text node');\n      }\n\n      if (!this.content || _.isEmpty(items)) {\n        return;\n      }\n\n      var text = this.content;\n      items = _.sortBy(items, ['start']);\n      var fragment = Node.createFragment();\n      var lastPos = 0;\n      items.forEach(function (item) {\n        if (item.start >= item.end || item.start < lastPos) {\n          return;\n        }\n\n        if (item.start > lastPos) {\n          fragment.appendText(text.substring(lastPos, item.start));\n        }\n\n        var entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n          attributes: item.data\n        });\n        entityNode.appendText(text.substring(item.start, item.end));\n        lastPos = item.end;\n      });\n\n      if (lastPos < text.length) {\n        fragment.appendText(text.substr(lastPos));\n      }\n\n      this.replaceWith(fragment);\n    }\n    /**\n     * Create entity nodes based on text source position\n     * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n     */\n\n  }, {\n    key: \"createEntitiesFromText\",\n    value: function createEntitiesFromText(entities) {\n      var _this3 = this;\n\n      this.toString();\n      var cache = new Map();\n\n      _.each(entities, function (item) {\n        var textNode = _this3.findTextByRange(item.start, item.end);\n\n        if (textNode === undefined) {\n          return;\n        }\n\n        if (cache.has(textNode)) {\n          cache.get(textNode).push(item);\n        } else {\n          cache.set(textNode, [item]);\n        }\n      });\n\n      cache.forEach(function (items, textNode) {\n        textNode.createEntities(items.map(function (item) {\n          return (0, _objectSpread2.default)({}, item, {\n            start: item.start - (textNode.textStart || 0),\n            end: item.end - (textNode.textStart || 0)\n          });\n        }));\n      });\n    }\n    /**\n     * Extract entities from text node\n     */\n\n  }, {\n    key: \"extractEntities\",\n    value: function () {\n      var _extractEntities = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(extractor) {\n        var nodeList, textList, result;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nodeList = this.find(function (node) {\n                  return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n                });\n                textList = nodeList.map(function (node) {\n                  return node.content;\n                });\n\n                if (!_.isFunction(extractor)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                result = textList.map(function (text) {\n                  return extractor(text);\n                });\n                _context.next = 13;\n                break;\n\n              case 6:\n                if (!_.isFunction(extractor.extract)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 9;\n                return extractor.extract(textList);\n\n              case 9:\n                result = _context.sent;\n                _context.next = 13;\n                break;\n\n              case 12:\n                throw new TypeError('invalid extractor');\n\n              case 13:\n                nodeList.forEach(function (node, i) {\n                  var items = result[i];\n\n                  if (!_.isArray(items)) {\n                    throw new Error('invalid extraction result');\n                  }\n\n                  node.createEntities(items);\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function extractEntities(_x) {\n        return _extractEntities.apply(this, arguments);\n      };\n    }()\n    /**\n     * Build plain text of the node (stripping tags & entities)\n     * @param [options]\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      return (0, _util.stringify)(this, options);\n    }\n    /**\n     * Build source code of the node\n     * @param [options]\n     */\n\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _util.stringify)(this, (0, _objectSpread2.default)({}, options, {\n        toSource: true\n      }));\n    }\n    /**\n     * Convert node to JSON serializable object\n     * @param options \n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$position = options.position,\n          position = _options$position === void 0 ? false : _options$position,\n          _options$textPosition = options.textPosition,\n          textPosition = _options$textPosition === void 0 ? false : _options$textPosition;\n      return _.omitBy({\n        type: this.type,\n        name: this.name,\n        content: this.content,\n        attributes: toJsonMap(this.attributes),\n        metadata: toJsonMap(this.metadata),\n        labels: this.labels.length ? this.labels : undefined,\n        position: position ? {\n          start: this.start,\n          end: this.end\n        } : undefined,\n        textPosition: textPosition ? {\n          start: this.textStart,\n          end: this.textEnd\n        } : undefined,\n        children: _.isEmpty(this.children) ? undefined : this.children.map(function (child) {\n          return child.toJSON(options);\n        })\n      }, _.isUndefined);\n    }\n  }, {\n    key: \"isTag\",\n    get: function get() {\n      return this.type === NodeType.TAG;\n    }\n    /**\n     * Check if the node is wrapping tag\n     */\n\n  }, {\n    key: \"isWrappingTag\",\n    get: function get() {\n      return this.isTag && WrappingTags.includes(this.name);\n    }\n    /**\n     * Check if the node is block tag\n     */\n\n  }, {\n    key: \"isBlockTag\",\n    get: function get() {\n      return this.isTag && BlockTags.includes(this.name);\n    }\n    /**\n     * Check if the node is simple block or inline block\n     */\n\n  }, {\n    key: \"isSimpleTag\",\n    get: function get() {\n      return this.isTag && ['BLOCK', 'INLINE'].includes(this.name);\n    }\n    /**\n     * Property indicates if the node is a block (wrapping other nodes)\n     */\n\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      var type = this.type,\n          name = this.name;\n      return BlockNodeTypes.includes(type) || this.isBlockTag;\n    }\n    /**\n     * If node is inline block\n     */\n\n  }, {\n    key: \"isInlineBlock\",\n    get: function get() {\n      return this.isTag && !this.isBlockTag;\n    }\n    /**\n     * Get parent node, alias for node.parent\n     */\n\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    }\n    /**\n     * Get child nodes, alias for node.children\n     */\n\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    }\n    /**\n     * If the node is root\n     */\n\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.type === NodeType.ROOT;\n    }\n    /**\n     * Get source code of the node\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      if (this.type === NodeType.ROOT) {\n        return this._source || '';\n      }\n\n      var rootNode = this.getRootNode();\n\n      if (!rootNode) {\n        throw new Error('ROOT node not found');\n      }\n\n      return rootNode.source.substring(this.start || 0, this.end);\n    }\n    /**\n     * Get node inner text\n     */\n\n  }, {\n    key: \"innerText\",\n    get: function get() {\n      if (this.type === NodeType.TEXT) {\n        return this.content;\n      } else if (this.type === NodeType.ENTITY) {\n        var textNode = this.children[0];\n        return textNode ? textNode.content : '';\n      } else {\n        return this.toString();\n      }\n    }\n    /**\n     * Check if the node is the first child of its parent\n     */\n\n  }, {\n    key: \"isFirstChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.first(parent.children) === this;\n    }\n    /**\n     * Check if the node is the last child of its parent\n     */\n\n  }, {\n    key: \"isLastChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.last(parent.children) === this;\n    }\n    /**\n     * Siblings from same parent\n     */\n\n  }, {\n    key: \"siblings\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent || !parent.isBlock) {\n        return [];\n      }\n\n      return parent.children;\n    }\n    /**\n     * Get index of parent children\n     */\n\n  }, {\n    key: \"childIndex\",\n    get: function get() {\n      var siblings = this.siblings;\n      return siblings.indexOf(this);\n    }\n    /**\n     * Next sibling node\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex + 1] || undefined;\n    }\n    /**\n     * Previous sibling node\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex - 1] || undefined;\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      var list = [];\n      var node = this;\n\n      while (node) {\n        list.unshift(node);\n        node = node.parent;\n      }\n\n      return list;\n    }\n    /**\n     * Get the first child of current node\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.first(this.children);\n    }\n    /**\n     * Get the last child of current node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.last(this.children);\n    }\n  }]);\n  return Node;\n}();\n\n(0, _defineProperty2.default)(Node, \"Types\", NodeType);\nvar _default = Node;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextLine.default;\n  }\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextLine = _interopRequireDefault(require(\"./TextLine\"));\n\nvar _constants = require(\"./constants\"); // improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\n\n\nvar NOT_FOUND = -1;\nvar LINE_BREAKS = /\\r?\\n/g;\n/**\n * Stream like text string\n * @typicalname stream\n */\n\nvar TextStream =\n/*#__PURE__*/\nfunction () {\n  /** Current cursor position */\n\n  /** Original text */\n\n  /** Tab size */\n\n  /** Text lines */\n\n  /** Start position of each line */\n\n  /** Markers */\n\n  /** Cursor stack positions */\n\n  /** Last matched string of methods like eat() match() */\n  function TextStream(text) {\n    var tabSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    (0, _classCallCheck2.default)(this, TextStream);\n    (0, _defineProperty2.default)(this, \"pos\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"tabSize\", void 0);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"lineOffsetIndexes\", []);\n    (0, _defineProperty2.default)(this, \"markers\", void 0);\n    (0, _defineProperty2.default)(this, \"cursorStack\", void 0);\n    (0, _defineProperty2.default)(this, \"lastMatch\", '');\n    this.pos = 0;\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n\n    this.text = text;\n    /**\n     * @description Tab size\n     */\n\n    this.tabSize = tabSize;\n    /**\n     * @description Lines, separated by line breaks\n     */\n\n    this.lines = [];\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n\n    this.markers = [];\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n\n    this.cursorStack = [];\n    this.init();\n  }\n  /**\n   * Prepare line indexes\n   */\n\n\n  (0, _createClass2.default)(TextStream, [{\n    key: \"init\",\n    value: function init() {\n      var lines = [];\n      var matched;\n      var offset = 0;\n      var ln = 1;\n      LINE_BREAKS.lastIndex = 0;\n\n      do {\n        matched = LINE_BREAKS.exec(this.text);\n\n        if (matched) {\n          var length = matched.index - offset;\n\n          var _text = this.text.substr(offset, length);\n\n          lines.push(new _TextLine.default(lines, _text, ln, offset));\n          offset += length + matched[0].length;\n        } else {\n          var _length = this.text.length - offset; // process last line without line break symbol\n\n\n          if (_length > 0) {\n            var _text2 = this.text.substr(offset);\n\n            lines.push(new _TextLine.default(lines, _text2, ln, offset));\n          }\n        }\n\n        ln++;\n      } while (matched);\n\n      this.lines = lines;\n      this.lineOffsetIndexes = _.map(lines, 'offset');\n    }\n    /**\n     * Get line and column position of the cursor\n     * @param pos Cursor position of the text\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      var lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n      var line = this.lines[lineIndex];\n\n      if (!line) {\n        throw new Error('cursor position is invalid');\n      }\n\n      var ln = line.ln,\n          offset = line.offset;\n      var col = pos - offset + 1;\n      return {\n        ln: ln,\n        col: col,\n        pos: pos,\n        line: line\n      };\n    }\n    /**\n     * Check if cursor is at the start of a line\n     * @param [trimSpaces] Whether to trim starting spaces\n     */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition = this.getPosition(),\n          col = _this$getPosition.col,\n          line = _this$getPosition.line;\n\n      if (col - 1 === 0) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimStart = _.trimStart(line.text),\n          length = _$trimStart.length;\n\n      return col - 1 <= line.length - length;\n    }\n    /**\n     * Check if cursor is at the end of a line\n     * @param [trimSpaces] Whether to trim ending spaces\n     */\n\n  }, {\n    key: \"eol\",\n    value: function eol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition2 = this.getPosition(),\n          col = _this$getPosition2.col,\n          line = _this$getPosition2.line;\n\n      if (col - 1 === line.length) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimEnd = _.trimEnd(line.text),\n          length = _$trimEnd.length;\n\n      return col - 1 >= length;\n    }\n    /**\n     * Check if cursor is at the end of whole text\n     * @param {number} [pos] \n     */\n\n  }, {\n    key: \"eof\",\n    value: function eof(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      return pos >= this.text.length;\n    }\n    /**\n     * Get one next char, but keep the cursor position (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.text.charAt(this.pos);\n    }\n    /**\n     * Get one next char, and move cursor forward (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.text.length) {\n        return this.text.charAt(this.pos++);\n      }\n\n      return '';\n    }\n    /**\n     * Consumes one char if the next char fitting the pattern\n     * @param pattern \n     * @returns The char been eaten\n     */\n\n  }, {\n    key: \"eat\",\n    value: function eat(pattern) {\n      var ch = this.text.charAt(this.pos) || '';\n      var ok;\n\n      if (_.isUndefined(ch)) {\n        ok = false;\n      } else if (_.isString(pattern)) {\n        ok = ch === pattern;\n      } else if (_.isRegExp(pattern)) {\n        pattern.lastIndex = 0;\n        ok = pattern.test(ch);\n      } else if (_.isFunction(pattern)) {\n        ok = pattern(ch);\n      }\n\n      if (ok) {\n        this.lastMatch = ch;\n        ++this.pos;\n        return ch;\n      }\n\n      return '';\n    }\n    /**\n     * Consumes chars while fitting the pattern\n     * @param match \n     * @returns Eaten characters\n     */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(pattern) {\n      var start = this.pos;\n      var chr;\n      var string = '';\n\n      do {\n        chr = this.eat(pattern);\n\n        if (chr) {\n          string += chr;\n        }\n      } while (chr && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes chars until the first char not fitting the pattern\n     * @param pattern char or pattern\n     * @returns eaten characters\n     */\n\n  }, {\n    key: \"eatUntil\",\n    value: function eatUntil(pattern) {\n      var start = this.pos;\n      var ch;\n      var string = '';\n\n      do {\n        ch = this.eat(pattern);\n\n        if (!ch) {\n          string += this.peek();\n          this.pos++;\n        } else {\n          this.pos--;\n        }\n      } while (!ch && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes spaces\n     * @returns {boolean} If any space has been consumed\n     */\n\n  }, {\n    key: \"eatSpaces\",\n    value: function eatSpaces() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n        this.pos++;\n      }\n\n      return this.pos > start;\n    }\n    /**\n     * Find position of matched text to the pattern\n     * @param pattern \n     * @param options\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var caseInsensitive = options.caseInsensitive;\n      var index = NOT_FOUND;\n      var length = 0;\n      var matched = '';\n\n      if (typeof pattern === 'string') {\n        if (caseInsensitive) {\n          pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n        } else {\n          index = this.text.indexOf(pattern, this.pos);\n\n          if (index !== NOT_FOUND) {\n            matched = pattern;\n          }\n        }\n      }\n\n      if (pattern instanceof RegExp) {\n        pattern.lastIndex = this.pos;\n        var result = pattern.exec(this.text);\n\n        if (result) {\n          index = result.index;\n          matched = result[0];\n        } else {\n          index = NOT_FOUND;\n        }\n      }\n\n      var _matched = matched;\n      length = _matched.length;\n      return {\n        index: index,\n        length: length,\n        matched: matched\n      };\n    }\n    /**\n     * Read n chars after current cursor\n     * @param [n] Number of chars to read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var left = this.text.length - this.pos;\n\n      if (left <= 0) {\n        return '';\n      } else if (left < n) {\n        n = left;\n      }\n\n      var result = this.text.substr(this.pos, n);\n      this.pos += n;\n      return result;\n    }\n    /**\n     * Read to text or pattern\n     * @param pattern \n     * @param [options]\n     * @returns Sub-text after current cursor and before (or contains) matched text\n     */\n\n  }, {\n    key: \"readTo\",\n    value: function readTo(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$toEOL = options.toEOL,\n          toEOL = _options$toEOL === void 0 ? false : _options$toEOL,\n          _options$toEOF = options.toEOF,\n          toEOF = _options$toEOF === void 0 ? false : _options$toEOF,\n          _options$consume = options.consume,\n          consume = _options$consume === void 0 ? false : _options$consume,\n          _options$skipMatched = options.skipMatched,\n          skipMatched = _options$skipMatched === void 0 ? false : _options$skipMatched;\n      var start = this.pos;\n\n      var _this$search = this.search(pattern),\n          index = _this$search.index,\n          length = _this$search.length;\n\n      var match = '';\n      var end = -1;\n\n      if (toEOL) {\n        var _this$getPosition3 = this.getPosition(),\n            line = _this$getPosition3.line;\n\n        end = line.offset + line.length;\n      } else if (toEOF) {\n        end = this.text.length;\n      }\n\n      if (index !== NOT_FOUND) {\n        if (toEOL || toEOF) {\n          if (index < end) {\n            end = index;\n          } else {\n            length = 0;\n          }\n        } else {\n          end = index;\n        }\n      }\n\n      if (end !== -1) {\n        this.pos = end;\n\n        if (consume) {\n          end += length;\n          this.pos = end;\n        } else if (skipMatched) {\n          this.pos += length;\n        }\n\n        match = this.text.substring(start, end);\n      }\n\n      this.lastMatch = match;\n      return match;\n    }\n    /**\n     * Read to pattern (contains the matched text)\n     * @param {} pattern Text to find or pattern\n     * @param {object} options Match options\n     * @returns {string} Sub-text after current cursor and until the end of matched text\n     */\n\n  }, {\n    key: \"readOver\",\n    value: function readOver(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        consume: true\n      }));\n    }\n    /**\n     * Read one line\n     * @returns {string} Text containing one line (not including line break)\n     */\n\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var _this$getPosition4 = this.getPosition(),\n          line = _this$getPosition4.line;\n\n      var nextLine = line.next();\n\n      if (this.eof()) {\n        return '';\n      }\n\n      if (nextLine) {\n        this.pos = nextLine.offset;\n        return line.text;\n      } else {\n        var length = line.offset + line.length - this.pos;\n        return this.read(length);\n      }\n    }\n    /**\n     * Move cursor to end of text\n     */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.text.length;\n    }\n    /**\n     * Skip to the beginning of matched text\n     * @param pattern\n     * @param options\n     */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, options);\n      return start !== this.pos;\n    }\n    /**\n     * Skip to the end of matched text\n     * @param pattern\n     */\n\n  }, {\n    key: \"skipOver\",\n    value: function skipOver(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        skipMatched: true\n      }));\n      return start !== this.pos;\n    }\n    /**\n     * Move cursor back\n     * @param n Steps\n     */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.pos -= n;\n    }\n    /**\n     * Check if rest text begins with pattern\n     * @param pattern \n     * @param [options] \n     */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$consume2 = options.consume,\n          consume = _options$consume2 === void 0 ? true : _options$consume2,\n          caseInsensitive = options.caseInsensitive;\n\n      var _this$search2 = this.search(pattern, {\n        caseInsensitive: caseInsensitive\n      }),\n          index = _this$search2.index,\n          length = _this$search2.length,\n          matched = _this$search2.matched;\n\n      if (index !== this.pos) {\n        return '';\n      }\n\n      if (consume) {\n        this.pos += length;\n      }\n\n      this.lastMatch = matched;\n      return matched;\n    }\n    /**\n     * Reset the marker stack\n     */\n\n  }, {\n    key: \"resetMarker\",\n    value: function resetMarker() {\n      this.markers = [];\n    }\n    /**\n     * Add a marker to stack\n     * @param data\n     * @param start\n     */\n\n  }, {\n    key: \"pushMarker\",\n    value: function pushMarker(data, start) {\n      if (_.isUndefined(start)) {\n        start = this.pos;\n      }\n\n      this.markers.push({\n        data: data,\n        start: start\n      });\n    }\n    /**\n     * Set data for current marker\n     * @param data\n     */\n\n  }, {\n    key: \"setMarkerData\",\n    value: function setMarkerData(data) {\n      var marker = _.last(this.markers);\n\n      if (!marker) return;\n\n      _.extend(marker.data, data);\n    }\n    /**\n     * Get data of current markder\n     */\n\n  }, {\n    key: \"getMarkerData\",\n    value: function getMarkerData() {\n      var marker = _.last(this.markers);\n\n      if (!marker) return {};\n      return marker.data;\n    }\n    /**\n     * Return a combined structure of text and it's position according to the previously set start\n     * marker\n     * @param [data] Additional data\n     * @param [end] End marker, if not set, previous set value will be used\n     */\n\n  }, {\n    key: \"popMarker\",\n    value: function popMarker() {\n      var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!_.isPlainObject(_data)) {\n        throw new TypeError('invalid data parameter');\n      }\n\n      if (_.isUndefined(end)) {\n        end = this.pos;\n      }\n\n      var marker = this.markers.pop();\n\n      if (!marker) {\n        return undefined;\n      }\n\n      var data = marker.data,\n          start = marker.start;\n      return {\n        text: this.text.substring(marker.start || 0, end),\n        position: {\n          start: start,\n          end: end\n        },\n        data: (0, _objectSpread2.default)({}, data, _data)\n      };\n    }\n  }, {\n    key: \"findLine\",\n    value: function findLine(text) {\n      return _.find(this.lines, function (line) {\n        return _.trim(line.text) === text;\n      });\n    }\n    /**\n     * Push current cursor to cursor stack, if new position provided, set current cursor to it\n     * @param [pos] \n     */\n\n  }, {\n    key: \"pushCursor\",\n    value: function pushCursor(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      this.cursorStack.push(this.pos);\n      this.pos = pos;\n    }\n    /**\n     * Pop last from cursor stack and set it to current cursor\n     */\n\n  }, {\n    key: \"popCursor\",\n    value: function popCursor() {\n      if (this.cursorStack.length === 0) {\n        throw new Error('out of cursor stack!');\n      }\n\n      this.pos = this.cursorStack.pop();\n      return this.pos;\n    }\n    /**\n     * Debug a single line\n     * @param line \n     * @param numWidth \n     * @param col \n     */\n\n  }, {\n    key: \"debugLine\",\n    value: function debugLine(line, numWidth, col) {\n      var ln = line.ln,\n          text = line.text;\n\n      if (_.isUndefined(numWidth)) {\n        numWidth = (ln + '').length;\n      }\n\n      if (col) {\n        text = text.substring(0, col - 1) + _chalk.default.bgBlue(text.charAt(col - 1)) + text.substring(col);\n      }\n\n      console.log(\"\".concat(_chalk.default.blueBright(\"\".concat(col ? '>' : ' ', \" \").concat(_.padStart(ln + '', numWidth), \" |\")), \" \").concat(text));\n    }\n    /**\n     * Debug cursor column position\n     * @param text Text of the line\n     * @param col Cursor position\n     * @param numWidth fixed line number width\n     */\n\n  }, {\n    key: \"debugCursor\",\n    value: function debugCursor(text, col, numWidth) {\n      var pos = text.substr(0, col - 1).replace(_constants.P_FULL_WIDTH_CHARACTER, 'XX').length;\n      console.log(_chalk.default.blueBright(\"  \".concat(_.repeat(' ', numWidth), \" | \").concat(_.repeat(' ', pos), \"^ \").concat(col)));\n    }\n    /**\n     * Debug current position state, with previous and following lines set by range\n     * @param range \n     */\n\n  }, {\n    key: \"debugState\",\n    value: function debugState() {\n      var _this = this;\n\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$getPosition5 = this.getPosition(),\n          ln = _this$getPosition5.ln,\n          col = _this$getPosition5.col;\n\n      var lineIndex = ln - 1;\n\n      var lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n\n      var numWidth = _.max(lines.map(function (l) {\n        return (l.ln + '').length;\n      }));\n\n      lines.forEach(function (line) {\n        var isCurrent = line.ln === ln;\n\n        _this.debugLine(line, numWidth, isCurrent ? col : 0);\n\n        if (isCurrent) {\n          _this.debugCursor(line.text, col, numWidth);\n        }\n      });\n      console.log();\n    }\n  }]);\n  return TextStream;\n}();\n\nvar _default = TextStream;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextStream = _interopRequireDefault(require(\"./TextStream\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _constants = require(\"./constants\");\n\nvar State;\n\n(function (State) {\n  State[State[\"METADATA\"] = 0] = \"METADATA\";\n  State[State[\"NORMAL\"] = 1] = \"NORMAL\";\n  State[State[\"SINGLE_COMMENT\"] = 2] = \"SINGLE_COMMENT\";\n  State[State[\"MULTIPLE_COMMENT\"] = 3] = \"MULTIPLE_COMMENT\";\n  State[State[\"START\"] = 4] = \"START\";\n  State[State[\"TAG_START\"] = 5] = \"TAG_START\";\n  State[State[\"TAG_NAME\"] = 6] = \"TAG_NAME\";\n  State[State[\"ATTRIBUTE_LIST\"] = 7] = \"ATTRIBUTE_LIST\";\n  State[State[\"ATTRIBUTE_NAME\"] = 8] = \"ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_ASSIGN\"] = 9] = \"ATTRIBUTE_ASSIGN\";\n  State[State[\"ATTRIBUTE_VALUE\"] = 10] = \"ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_FINISH\"] = 11] = \"ATTRIBUTE_FINISH\";\n  State[State[\"TAG_END\"] = 12] = \"TAG_END\";\n  State[State[\"LABEL_START\"] = 13] = \"LABEL_START\";\n  State[State[\"ENTITY_START\"] = 14] = \"ENTITY_START\";\n  State[State[\"ENTITY_BODY\"] = 15] = \"ENTITY_BODY\";\n  State[State[\"ENTITY_END\"] = 16] = \"ENTITY_END\";\n  State[State[\"END\"] = 17] = \"END\";\n  State[State[\"FINISH\"] = 18] = \"FINISH\";\n})(State || (State = {}));\n\n;\nvar stateNames = ['METADATA', 'NORMAL', 'SINGLE_COMMENT', 'MULTIPLE_COMMENT', 'START', 'TAG_START', 'TAG_NAME', 'ATTRIBUTE_LIST', 'ATTRIBUTE_NAME', 'ATTRIBUTE_ASSIGN', 'ATTRIBUTE_VALUE', 'ATTRIBUTE_FINISH', 'TAG_END', 'LABEL_START', 'ENTITY_START', 'ENTITY_BODY', 'ENTITY_END', 'END', 'FINISH'];\n\nvar getStateName = function getStateName(state) {\n  return stateNames[state];\n};\n\nvar countLineBreaks = function countLineBreaks(text) {\n  var result = text.match(_constants.P_LINE_BREAK);\n  return result ? result.length : 0;\n};\n\n;\n/**\n * Tokenizer class\n * @class\n */\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Tokenizer, null, [{\n    key: \"from\",\n    value: function from(text, options) {\n      return new Tokenizer(text, options);\n    }\n  }]);\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n\n  function Tokenizer(text, options) {\n    (0, _classCallCheck2.default)(this, Tokenizer);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"stream\", void 0);\n    (0, _defineProperty2.default)(this, \"options\", void 0);\n    (0, _defineProperty2.default)(this, \"parsed\", void 0);\n    this.text = text;\n    this.stream = new _TextStream.default(text);\n    var defaultOptions = {\n      verbose: process && process.env.DEBUG === 'verbose'\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  (0, _createClass2.default)(Tokenizer, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n    /**\n     * Process a text and parse to AST\n     * @returns Root node of parsed AST\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this = this;\n\n      var text = this.text,\n          stream = this.stream;\n      var timeStart = Date.now();\n      var state = State.METADATA;\n      var start = 0;\n      var lastState = 0;\n      var lastPos = -1;\n      var states = {\n        unwrapped: false,\n        inline: false,\n        embedded: false,\n        isClosing: false,\n        key: undefined,\n        value: undefined\n      };\n\n      var root = _Node.default.create(_Node.NodeType.ROOT, undefined, {\n        source: text\n      });\n\n      var nodeStack = [];\n      var node = root;\n\n      var getNodeString = function getNodeString(node) {\n        return \"\".concat(node.type).concat(node.name ? \":\".concat(node.name) : '');\n      };\n\n      var debugStack = function debugStack(lastNode) {\n        if (!_this.options.verbose) {\n          return;\n        }\n\n        var separator = ' > ';\n        var stack = nodeStack.concat([node]);\n        var list = stack.map(function (n, i) {\n          var text = getNodeString(n);\n\n          if (i === stack.length - 1) {\n            text = _chalk.default.cyanBright(text);\n          } else {\n            text = _chalk.default.green(text);\n          }\n\n          return text;\n        });\n        var result = list.join(_chalk.default.redBright(separator));\n\n        if (lastNode) {\n          result += _chalk.default.grey(\"\".concat(separator).concat(getNodeString(lastNode)));\n        }\n\n        return result;\n      };\n\n      var pushNode = function pushNode(n) {\n        if (node.start === -1) {\n          node.start = stream.pos;\n        }\n\n        nodeStack.push(node);\n        node = n;\n\n        _this.debug(\"push: \".concat(debugStack(), \"\\n\"));\n      };\n\n      var popNode = function popNode(error) {\n        var lastNode = node;\n        node.end = stream.pos;\n\n        if (node.start === node.end || node.type === _Node.NodeType.PARAGRAPH && !node.hasChild() && node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node = nodeStack.pop();\n\n        _this.debug(\"pop : \".concat(debugStack(lastNode), \"\\n\"));\n\n        if (!node) {\n          throw createError(error || 'unexpected closing node');\n        }\n      }; // replace wrapping paragraph with current block tag\n\n\n      var levelUpBlock = function levelUpBlock() {\n        if (node.parent && node.parent.type === _Node.NodeType.PARAGRAPH) {\n          var blockNode = node;\n          popNode();\n          node.removeChild(blockNode);\n          popNode();\n          node.appendChild(blockNode);\n          pushNode(blockNode);\n        }\n      };\n\n      var createError = function createError(message) {\n        _this.debug(\"error: '\".concat(message, \"'\"));\n\n        _this.debug('current node:');\n\n        _this.debug(node.toJSON());\n\n        _this.debug('current parsing state:');\n\n        _this.debug(JSON.stringify(root, null, 2));\n\n        return new _ParseError.default(message, text, stream.pos);\n      };\n\n      while (state !== State.FINISH) {\n        // parse failure watcher\n        if (Date.now() - timeStart >= _constants.PROCESSING_TIMEOUT) {\n          this.debug('parsing timeout!');\n          state = State.FINISH;\n        }\n\n        if (state === lastState && lastPos === stream.pos) {\n          throw new Error('Parser fall into infinite loop!');\n        }\n\n        lastState = state;\n        lastPos = stream.pos;\n        this.debug(_chalk.default.magenta(\"# \".concat(getStateName(state), \", pos = \").concat(stream.pos)));\n\n        if (this.options.verbose) {\n          stream.debugState();\n        }\n\n        switch (state) {\n          case State.METADATA:\n            {\n              stream.eatWhile(_constants.P_WHITE_SPACES_EXT);\n\n              if (stream.match(_constants.T_METADATA_MARKER) || stream.match(_constants.P_ATTRIBUTE_LIST, {\n                consume: false\n              })) {\n                node.states.metadata = true;\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.NORMAL:\n            {\n              if (stream.sol(true) || stream.eol(true)) {\n                stream.eatWhile(_constants.P_WHITE_SPACE);\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK)) {\n                popNode();\n\n                if (node.states.unwrapped) {\n                  popNode();\n                }\n\n                break;\n              }\n\n              start = stream.pos;\n\n              if (node.type !== _Node.NodeType.PARAGRAPH && !node.isInlineBlock && stream.sol(true)) {\n                var child = node.createChild(_Node.NodeType.PARAGRAPH, undefined, {\n                  start: start\n                });\n                pushNode(child);\n              }\n\n              var originalText = stream.readTo(_constants.P_MARKER, {\n                toEOF: true\n              });\n              var _text = originalText;\n\n              if (_text) {\n                if (node.children.length === 0) {\n                  _text = _.trimStart(_text);\n                }\n\n                _text = _text.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, _constants.T_LINE_BREAK);\n                _text = _.trimEnd(_text, _constants.T_LINE_BREAKS);\n\n                if (_text) {\n                  node.appendText(_text, {\n                    start: start,\n                    end: stream.pos\n                  });\n                }\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK, {\n                consume: false\n              })) {\n                state = State.NORMAL;\n              } else {\n                state = State.START;\n              }\n\n              break;\n            }\n\n          case State.START:\n            {\n              start = stream.pos;\n              var ch = stream.eat(_constants.P_MARKER);\n              _constants.P_LABEL_START.lastIndex = 0;\n\n              if (ch === _constants.T_SINGLE_LINE_COMMENT) {\n                var rest = stream.eatWhile(_constants.T_SINGLE_LINE_COMMENT);\n\n                if (rest.length === 0) {\n                  state = State.SINGLE_COMMENT;\n                } else {\n                  state = State.MULTIPLE_COMMENT;\n                }\n              } else if (ch === _constants.T_TAG_START) {\n                state = State.TAG_START;\n              } else if (_constants.P_LABEL_START.test(ch)) {\n                states.unwrapped = true;\n                state = State.TAG_START;\n              } else if (ch === _constants.T_TAG_END) {\n                states.isClosing = true;\n                state = State.TAG_END;\n              } else if (ch === _constants.T_ENTITY_START) {\n                state = State.ENTITY_START;\n              } else if (stream.eof()) {\n                state = State.END;\n              } else {\n                throw createError('empty start');\n              }\n\n              break;\n            }\n\n          case State.SINGLE_COMMENT:\n          case State.MULTIPLE_COMMENT:\n            {\n              start = stream.pos;\n              var content = void 0;\n\n              if (state === State.SINGLE_COMMENT) {\n                content = stream.readTo(_constants.P_LINE_BREAK);\n              } else {\n                content = stream.readTo(_constants.P_MULTIPLE_LINE_COMMENT, {\n                  skipMatched: true\n                });\n              }\n\n              if (content) {\n                if (state === State.MULTIPLE_COMMENT) {\n                  content = content.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n                }\n\n                content = _.trim(content);\n              }\n\n              if (content) {\n                node.createChild(_Node.NodeType.COMMENT, undefined, {\n                  start: start,\n                  end: stream.pos,\n                  content: content\n                });\n              }\n\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.TAG_START:\n            {\n              if (stream.eat(_constants.T_TAG_CLOSING)) {\n                states.isClosing = true;\n                state = State.TAG_NAME;\n              } else if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (node.type !== _Node.NodeType.ENTITY && (states.unwrapped || stream.eat(_constants.P_LABEL_START))) {\n                state = State.LABEL_START;\n              } else {\n                var _child = _Node.default.create(_Node.NodeType.TAG, '', {\n                  start: start\n                });\n\n                if (states.embedded) {\n                  _child.states.embedded = true;\n                  _child.states.metaKey = states.key;\n                  states.embedded = false;\n                } else {\n                  node.appendChild(_child);\n                }\n\n                pushNode(_child);\n                state = State.TAG_NAME;\n              }\n\n              if (state === State.NORMAL || state === State.LABEL_START) {\n                stream.pushCursor(start);\n                var tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n                stream.popCursor();\n\n                if (node.type === _Node.NodeType.PARAGRAPH && tagName === 'BLOCK') {\n                  popNode();\n                }\n\n                var _child2 = node.createChild(_Node.NodeType.TAG, tagName, {\n                  start: start,\n                  states: {\n                    simpleBlock: true,\n                    unwrapped: states.unwrapped\n                  }\n                });\n\n                states.unwrapped = false;\n                pushNode(_child2);\n              }\n\n              break;\n            }\n\n          case State.TAG_NAME:\n            {\n              var name = stream.match(_constants.P_TAG_NAME);\n\n              if (!name) {\n                throw createError('expected tag name');\n              }\n\n              states.inline = name === 'INLINE';\n\n              if (states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  stream.pushCursor(start);\n                  popNode();\n                  stream.popCursor();\n                }\n\n                if (name !== node.name) {\n                  throw createError('unexpected closing tag');\n                }\n\n                var _ch = stream.eat(_constants.T_TAG_END);\n\n                if (!_ch) {\n                  throw createError('invalid closing tag');\n                }\n\n                if (!states.inline && !stream.eol()) {\n                  throw createError('closing block tag must take the whole line');\n                }\n\n                state = State.TAG_END;\n              } else {\n                node.name = name;\n\n                if (node.isWrappingTag) {\n                  stream.pushCursor(node.start || 0);\n\n                  if (node.name === 'BLOCK' && !stream.sol(true)) {\n                    throw createError('unexpected start of block inline');\n                  }\n\n                  stream.popCursor();\n\n                  if (node.isBlock) {\n                    levelUpBlock();\n                  }\n                }\n\n                state = State.ATTRIBUTE_LIST;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_LIST:\n            {\n              var spacePattern = node.states.simpleBlock || node.states.unwrapped ? _constants.P_WHITE_SPACE : _constants.P_WHITE_SPACES_EXT;\n              var spaces = stream.eatWhile(spacePattern);\n              var isParsingMetadata = node.states.metadata;\n\n              if (isParsingMetadata) {\n                var endOfFrontMatter = false;\n\n                if (stream.match(_constants.T_METADATA_MARKER)) {\n                  if (!stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('expected new line after metadata closed');\n                  }\n\n                  endOfFrontMatter = true;\n                }\n\n                var lineBreaks = countLineBreaks(spaces);\n\n                if (lineBreaks > 1) {\n                  endOfFrontMatter = true;\n                }\n\n                if (endOfFrontMatter) {\n                  state = State.NORMAL;\n                  node.states.metadata = false;\n                  break;\n                } // deal with simple block at the beginning\n\n\n                if (node.type === _Node.NodeType.ROOT && !stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                }) && lineBreaks === 1) {\n                  var _child3 = node.createChild(_Node.NodeType.TAG, 'BLOCK', {\n                    labels: node.labels,\n                    states: {\n                      unwrapped: true\n                    },\n                    metadata: node.metadata\n                  });\n\n                  node.clearLabels();\n                  node.clearMetadata();\n                  pushNode(_child3);\n                  state = State.NORMAL;\n                  break;\n                }\n              }\n\n              if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (stream.eat(_constants.T_TAG_END)) {\n                state = State.TAG_END;\n              } else if (stream.match(_constants.P_LABEL_START)) {\n                state = State.LABEL_START;\n              } else {\n                if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n                  if (_.isEmpty(node.attributes) && _constants.P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                    states.key = node.name;\n                    node.name = 'BLOCK';\n                    node.states.simpleBlock = true;\n                    levelUpBlock();\n                    state = State.ATTRIBUTE_ASSIGN;\n                    break;\n                  } else {\n                    throw createError('expecting end of tag \"}\" or attribute list');\n                  }\n                }\n\n                state = State.ATTRIBUTE_NAME;\n\n                if (stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                })) {\n                  state = State.ATTRIBUTE_NAME;\n                } else {\n                  state = State.NORMAL;\n                }\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_NAME:\n            {\n              var _key = stream.match(_constants.P_ATTRIBUTE_NAME);\n\n              if (!_key) {\n                throw createError('expecting attribute name');\n              }\n\n              states.key = _key;\n              state = State.ATTRIBUTE_ASSIGN;\n              break;\n            }\n\n          case State.ATTRIBUTE_ASSIGN:\n            {\n              var _ch2 = stream.peek();\n\n              if (_ch2 === _constants.T_TAG_END) {\n                state = State.ATTRIBUTE_FINISH;\n              } else {\n                _ch2 = stream.eat(_constants.P_ATTRIBUTE_ASSIGN);\n\n                if (!_ch2) {\n                  throw createError('expecting assignment \"=\" or \":\"');\n                }\n\n                if (_constants.P_ASSIGN_YAML.test(_ch2)) {\n                  stream.eatSpaces();\n                }\n\n                state = State.ATTRIBUTE_VALUE;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_VALUE:\n            {\n              var _ch3 = stream.peek();\n\n              var _value = void 0;\n\n              if (_ch3 === _constants.T_TAG_START || _ch3 === _constants.T_ENTITY_START) {\n                states.embedded = true;\n                state = State.START;\n                break;\n              } else if (_ch3 === _constants.T_STRING_START) {\n                _value = stream.match(_constants.P_STRING_LITERAL_QUOTED);\n                _value = JSON.parse(_value);\n              } else if (stream.match(_constants.P_DATE_LITERAL)) {\n                _value = stream.lastMatch;\n                _value = new Date(_value);\n              } else if (_constants.P_NUMBER_START.test(_ch3)) {\n                _value = stream.match(_constants.P_NUMBER_LITERAL);\n                _value = parseFloat(_value);\n              } else if (stream.match(_constants.P_BOOLEAN_TRUE)) {\n                _value = true;\n              } else if (stream.match(_constants.P_BOOLEAN_FALSE)) {\n                _value = false;\n              } else {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n\n                if (_.isNull(_value)) {\n                  throw createError('unrecognized attribute value');\n                }\n              }\n\n              if (_.isNull(_value)) {\n                throw createError('invalid attribute value');\n              }\n\n              states.value = _value;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n\n          case State.ATTRIBUTE_FINISH:\n            {\n              var _key2 = states.key,\n                  _value2 = states.value;\n              states.key = undefined;\n              states.value = undefined;\n\n              if (_.isUndefined(_value2)) {\n                _value2 = true;\n              }\n\n              if (node.states.metadata) {\n                node.setMetadata(_key2, _value2);\n              } else {\n                node.setAttribute(_key2, _value2);\n              }\n\n              this.debug(\"# \".concat(node.states.metadata ? 'metadata' : 'attribute', \" \").concat(_key2, \"=\").concat(JSON.stringify(_value2)));\n              this.debug();\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.TAG_END:\n            {\n              var parseMetadata = node.isBlockTag && !states.isClosing;\n              var tagNode = node;\n              states.inline = tagNode.isInlineBlock;\n\n              if (!node.isWrappingTag || states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  popNode();\n                }\n\n                popNode();\n\n                if (node.type === _Node.NodeType.ENTITY) {\n                  // copy tag properties to entity and remove temporary tag node\n                  node.setAttributes(tagNode.attributes);\n                  node.name = tagNode.name;\n                  node.removeChild(tagNode);\n                  state = State.ENTITY_END;\n                  tagNode = node;\n                  popNode();\n                }\n\n                if (tagNode.states.embedded) {\n                  if (node.states.metadata) {\n                    node.setMetadata(tagNode.states.metaKey, tagNode);\n                  } else {\n                    node.setAttribute(tagNode.states.metaKey, tagNode);\n                  }\n                }\n              }\n\n              if (states.isClosing && !states.inline) {\n                stream.skipOver(_constants.P_LINE_BREAK);\n              }\n\n              states.isClosing = false;\n              states.inline = false;\n\n              if (parseMetadata) {\n                state = State.METADATA;\n              } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.LABEL_START:\n            {\n              var label = stream.match(_constants.P_LABEL_NAME);\n\n              if (!label) {\n                throw createError('expected label name');\n              }\n\n              node.addLabel(label);\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.ENTITY_START:\n            {\n              var _child4 = _Node.default.create(_Node.NodeType.ENTITY, '', {\n                start: start\n              });\n\n              if (states.embedded) {\n                _child4.states.embedded = true;\n                _child4.states.metaKey = states.key;\n                states.embedded = false;\n              } else {\n                node.appendChild(_child4);\n              }\n\n              pushNode(_child4);\n              state = State.ENTITY_BODY;\n              break;\n            }\n\n          case State.ENTITY_BODY:\n            {\n              start = stream.pos;\n\n              var _text2 = stream.readTo(_constants.T_ENTITY_END, {\n                skipMatched: true\n              });\n\n              if (!_text2) {\n                throw createError('empty entity');\n              } else if (_text2.search(_constants.P_LINE_BREAK) !== -1) {\n                throw createError('unexpected line break of entity');\n              }\n\n              node.appendText(_text2, {\n                start: start,\n                end: start + _text2.length\n              });\n\n              var _ch4 = stream.eat(_constants.T_TAG_START);\n\n              if (_ch4) {\n                state = State.TAG_START;\n              } else {\n                state = State.ENTITY_END;\n              }\n\n              break;\n            }\n\n          case State.ENTITY_END:\n            {\n              popNode();\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.END:\n            {\n              if (node.type !== _Node.NodeType.ROOT) {\n                popNode();\n              }\n\n              state = State.FINISH;\n              break;\n            }\n\n          case State.FINISH:\n            {\n              break;\n            }\n        }\n      }\n\n      root.toString();\n      this.parsed = true;\n      this.debug('parsed result:');\n      this.debug(JSON.stringify(root.toJSON(), null, 2));\n      return root;\n    }\n  }]);\n  return Tokenizer;\n}();\n\nvar _default = Tokenizer;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Class holding text line data\n */\n\n\nvar TextLine =\n/*#__PURE__*/\nfunction () {\n  function TextLine(lines, text, ln, offset) {\n    (0, _classCallCheck2.default)(this, TextLine);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"ln\", void 0);\n    (0, _defineProperty2.default)(this, \"offset\", void 0);\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n  /**\n   * Get the previous line\n   */\n\n\n  (0, _createClass2.default)(TextLine, [{\n    key: \"prev\",\n    value: function prev() {\n      return this.lines[this.ln - 2];\n    }\n    /**\n     * Get the next line\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.lines[this.ln];\n    }\n    /**\n     * Get text length of the line\n     */\n\n  }, {\n    key: \"toJSON\",\n\n    /**\n     * Convert to JSON serializable object\n     */\n    value: function toJSON() {\n      return {\n        ln: this.ln,\n        start: this.start,\n        end: this.end,\n        text: this.text\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n    /**\n     * Start position of the line, alias of `offset`\n     */\n\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.offset;\n    }\n    /**\n     * End position of the line\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n  }]);\n  return TextLine;\n}();\n\nvar _default = TextLine;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n\n  function ParseError(message, text, pos) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"message\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"text\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"pos\", void 0);\n    _this.message = message;\n    _this.text = text;\n    _this.pos = pos;\n    return _this;\n  }\n\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.default = ParseError;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatValue = formatValue;\nexports.parseValue = parseValue;\nexports.spacer = spacer;\nexports.stringify = stringify;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n/**\n * Stringify attribute value\n * @param value \n */\n\nfunction formatValue(value) {\n  if (_.isDate(value)) {\n    return value.toISOString().replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString) {\n    return _constants.P_STRING_LITERAL_UNQUOTED_TESTER.test(value) ? value : JSON.stringify(value);\n  } else if (_.isBoolean(value)) {\n    return JSON.stringify(value);\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n/**\n * Parse attribute value\n * @param value \n */\n\n\nfunction parseValue(value) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\n\n\nfunction spacer(space, indent) {\n  if (indent <= 0) return '';\n  return _.repeat(_constants.T_SPACE, space * indent);\n}\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\n\n\nfunction stringify(node, options) {\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var text = '';\n\n  if (_.isNumber(options)) {\n    options = {\n      space: options\n    };\n  }\n\n  options = _.defaults(options, {\n    space: _constants.DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false\n  });\n  var simpleTag = options.simple && node.isSimpleTag;\n\n  if (options.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n\n  if (node.type === _Node.NodeType.TEXT) {\n    text += node.content;\n  } else {\n    if (options.toSource && !_.isEmpty(node.metadata)) {\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n\n      _.each(node.metadata, function (value, key) {\n        text += \"\".concat(key, \": \");\n\n        if (value instanceof _Node.default) {\n          text += stringify(value, options, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n\n        text += _constants.T_LINE_BREAK;\n      });\n\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n    }\n\n    if (node.type === _Node.NodeType.ENTITY) {\n      var child = _.first(node.children);\n\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_START;\n      }\n\n      text += stringify(child, options, indent, pos + text.length);\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_END;\n      }\n    }\n\n    if (options.toSource && (node.type === _Node.NodeType.TAG || node.type === _Node.NodeType.ENTITY)) {\n      if (node.isBlock) {\n        text += spacer(options.space, indent);\n      }\n\n      if (!(simpleTag && node.children.length === 1)) {\n        text += _constants.T_TAG_START;\n      }\n\n      if (!simpleTag) {\n        text += node.name;\n      }\n\n      var listCount = 0;\n\n      _.keys(node.attributes).forEach(function (key, i) {\n        var value = node.attributes[key];\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        if (_.isBoolean(value) && value) {\n          text += key;\n        } else if (value instanceof _Node.default) {\n          text += stringify(node, options, 0, pos + text.length);\n        } else {\n          text += \"\".concat(key, \"=\").concat(formatValue(value));\n        }\n      });\n\n      _.each(node.labels, function (label, i) {\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        text += \"#\".concat(label);\n      });\n\n      text += simpleTag ? _constants.T_SPACE : _constants.T_TAG_END;\n\n      if (node.isBlock) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.type === _Node.NodeType.PARAGRAPH) {\n      text += spacer(options.space, indent);\n    }\n\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(function (child) {\n        var subText = stringify(child, options, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n\n    var next = node.nextSibling;\n\n    if (node.isBlock) {\n      if (options.toSource) {\n        text = _.trimEnd(text, _constants.T_LINE_BREAK);\n      }\n\n      text += _constants.T_LINE_BREAK;\n\n      if (node.type === _Node.NodeType.PARAGRAPH && !node.isLastChild) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(options.space, indent);\n      }\n\n      if (simpleTag) {\n        if (node.children.length > 1) {\n          text += _constants.T_TAG_END;\n        }\n      } else {\n        text += _constants.T_TAG_START + _constants.T_TAG_CLOSING + node.name + _constants.T_TAG_END;\n      }\n\n      if (node.isBlockTag) {\n        text += _constants.T_LINE_BREAK;\n\n        if (next && next.isBlock) {\n          text += _constants.T_LINE_BREAK;\n        }\n      }\n    }\n  }\n\n  if (options.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.parse = parse;\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _Tokenizer.default;\n  }\n});\nObject.defineProperty(exports, \"TextStream\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.default;\n  }\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.TextLine;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.default;\n  }\n});\nObject.defineProperty(exports, \"NodeType\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.NodeType;\n  }\n});\nexports.default = void 0;\n\nvar _Tokenizer = _interopRequireDefault(require(\"./Tokenizer\"));\n\nvar _TextStream = _interopRequireWildcard(require(\"./TextStream\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n/**\n * @module @zaml/parser\n * @typicalname parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\n\n\nfunction parse(text, options) {\n  var tokenizer = new _Tokenizer.default(text, options);\n  return tokenizer.process();\n}\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\n\n\nfunction tokenize(text, options) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nvar _default = {\n  Tokenizer: _Tokenizer.default,\n  TextStream: _TextStream.default,\n  TextLine: _TextStream.TextLine,\n  Node: _Node.default,\n  NodeType: _Node.NodeType,\n  tokenize: tokenize,\n  parse: parse\n};\nexports.default = _default;"],"sourceRoot":""}