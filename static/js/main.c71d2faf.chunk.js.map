{"version":3,"sources":["../../zaml-parser/lib/util.js","../../zaml-parser/lib/index.js","Editor/Pane.tsx","SourceEditor/codemirror-mode.ts","SourceEditor/SourceEditor.tsx","VisualEditor/VisualNode.tsx","VisualEditor/VisualEditor.tsx","Editor/logo.svg","TreeView/TreeNode.tsx","TreeView/TreePathItem.tsx","TreeView/TreePath.tsx","TreeView/TreeToolbar.tsx","TreeView/TreePropEditor.tsx","Common/TabView.tsx","TreeView/TreeView.tsx","Editor/Editor.tsx","sample/contract.ts","App.tsx","serviceWorker.ts","index.tsx","../../zaml-parser/lib/constants.js","../../zaml-parser/lib/Node.js","../../zaml-parser/lib/TextStream.js","../../zaml-parser/lib/ParseError.js","../../zaml-parser/lib/Tokenizer.js","../../zaml-parser/lib/TextLine.js"],"names":["_interopRequireWildcard","__webpack_require__","Object","defineProperty","exports","value","formatValue","parseValue","P_DATE_FORMAT","test","Date","spacer","stringify","node","options","indent","arguments","length","undefined","pos","text","_","isNumber","space","defaults","_constants","DEFAULT_INDENT_SPACES","simple","toSource","simpleTag","isSimpleTag","start","textStart","type","_Node","NodeType","TEXT","content","isEmpty","metadata","T_METADATA_MARKER","T_LINE_BREAK","each","key","concat","default","ENTITY","child","first","children","Error","T_ENTITY_START","T_ENTITY_END","TAG","isBlock","T_TAG_START","name","listCount","keys","attributes","forEach","i","T_SPACE","isBoolean","labels","label","T_TAG_END","PARAGRAPH","isWrappingTag","subText","next","nextSibling","trimEnd","isLastChild","isBlockTag","T_TAG_CLOSING","end","textEnd","replace","isDate","toISOString","isString","P_STRING_LITERAL_UNQUOTED_TESTER","JSON","isNaN","Infinity","repeat","_interopRequireDefault","tokenize","parse","enumerable","get","_Tokenizer","_TextStream","TextLine","_ParseError","process","console","warn","_default","ParseError","Tokenizer","TextStream","Node","Pane","props","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_this$props","title","className","react_default","a","createElement","classNames","React","Component","defaultProps","CodeMirror","defineSimpleMode","regex","token","dedent","comment","meta","dontIndentStates","lineComment","codeMirrorOptions","mode","lineNumbers","lineWrapping","SourceEditor","_this","state","nextProps","editor","height","setSize","setValue","_this2","onChange","react_codemirror2","onBeforeChange","data","setState","_onChange","_x","_x2","_x3","apply","toString","editorDidMount","zaml","VisualNode","element","selectedNode","selected","ROOT","node-name","node-id","id","href","url","assign","push","map","block","toLowerCase","VisualEditor","ContextMenuTarget","handleContextMenu","event","currentNode","selection","window","getSelection","rangeCount","range","getRangeAt","domNode","startContainer","textContent","preventDefault","stopPropagation","punctuationPattern","startPos","endPos","exec","lastIndex","startOffset","setStart","setEnd","root","commonNode","getNodeByElement","commonAncestorContainer","startNode","endNode","endContainer","createBlockByRange","endOffset","removeAllRanges","_this$props2","flatten","target","_this$props3","anchorNode","focusNode","createEntities","alert","_this$props4","removeEntity","onSelect","nodeType","TEXT_NODE","classList","contains","parentElement","getAttribute","getNodeById","_this$props5","onDoubleClick","handleDoubleClick","VisualNode_VisualNode","e","_this3","commonEntityNames","parent","wrapperNode","menu","menuItem","disabled","descriptor","menuDivider","onClick","handleCreateBlock","handleRemoveBlock","handleCreateEntity","prompt","handleRemoveEntity","handleInspect","_extends","source","prototype","hasOwnProperty","NodePart","_ref","_ref2","fill","d","_ref3","_ref4","cx","cy","r","_ref5","_ref6","x","y","width","rx","ry","_ref7","_ref8","points","logo_SvgComponent","data-name","viewBox","p","nil","TreeNode","_selectedPart","selectedPart","expandedNodes","onSelectPart","onExpansionChange","onMouseEnter","onMouseOut","expanded","indexOf","isRoot","Whole","Header","commonProps","_onMouseEnter","_onMouseOut","react","onlyText","isEntity","isTag","firstChild","nameStart","nameEnd","node-selected","truncate","Footer","TreePathItem","TreePath","nodeList","buildNodeList","includes","list","unshift","n","TreePathItem_TreePathItem","TreeToolbar","Tab","TabView","tabs","selectedTab","onTabChange","tab","values","defaultTab","defaultEditingIndex","TreePropEditor","editingIndex","inlineError","editingElement","renderEmptyTip","Labels","renderLabelEditor","Attributes","renderAttributeEditor","Metadata","focus","select","index","focusEditingElement","originalLabel","addLabel","removeLabel","cancelLabelEditing","_this$state","toConsumableArray","error","ref","defaultValue","onBlur","handleLabelUpdate","currentTarget","onKeyDown","handleLabelEdit","_this4","sort","renderValue","_this5","TabView_TabView","renderTabContent","TreeView","without","nodeIds","path","union","onHover","index_esm","split","defaultSize","minSize","TreeToolbar_TreeToolbar","TreeNode_TreeNode","handleExpansionChange","TreePath_TreePath","TreePropEditor_TreePropEditor","create","err","message","from","ln","col","to","sourceBlock","querySelector","dir","line","sourceText","findOneBy","createEntitiesFromText","Editor","defaultSource","sourcePaneHeight","onResize","throttle","bind","assertThisInitialized","preventSourceChange","addEventListener","passive","removeEventListener","nextState","log","innerHeight","hoveredNode","Pane_Pane","SourceEditor_SourceEditor_SourceEditor","handleSourceChange","VisualEditor_VisualEditor_VisualEditor","handleNodeChange","TreeView_TreeView_TreeView","App","Editor_Editor_Editor","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","PROCESSING_TIMEOUT","P_MARKER","END_MARKERS","START_MARKERS","P_FULL_WIDTH_CHARACTER","P_BOOLEAN_FALSE","P_BOOLEAN_TRUE","P_STRING_LITERAL_UNQUOTED","P_STRING_LITERAL_QUOTED","P_NUMBER_LITERAL","P_NUMBER_START","P_DATE_LITERAL","T_STRING_START","P_TAG_NAME","P_ATTRIBUTE_LIST","P_ATTRIBUTE_NAME","P_ATTRIBUTE_ASSIGN","P_LABEL_NAME","P_LABEL_START","P_LIST_SEPARATOR","P_WHITE_SPACES_EXT","P_WHITE_SPACE","P_PARAGRAPH_BREAK","P_SPACE_WRAPPED_LINE_BREAK","P_LINE_BREAK","P_ASSIGN_YAML","T_TAG_ATTRIBUTE_FAVORED_ASSIGN","T_METADATA_FAVORED_ASSIGN","T_PARAGRAPH_BREAK","T_LINE_BREAKS","T_ASSIGN_YAML","T_ASSIGN_XML","P_MULTIPLE_LINE_COMMENT","T_SINGLE_LINE_COMMENT","T_TAB","createPattern","combinePatterns","isRegExp","escapeRegExp","join","flags","RegExp","find","_find","WrappingTags","BlockTags","BlockNodeTypes","NodeTypes","_regenerator","_asyncToGenerator2","_toConsumableArray2","_slicedToArray2","_objectSpread2","_classCallCheck2","_createClass2","_defineProperty2","_util","_2","nanoid","defaultFinderCallback","testNode","pattern","isFunction","is","TypeError","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","return","_findOne","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","parseJson","json","parseJsonMap","childData","appendChild","normalize","toJsonMap","mapValues","toJSON","isPlainObject","_props$source","_props$start","_props$end","states","_props$attributes","_props$metadata","_props$labels","_props$content","_props$text","_source","appendText","FRAGMENT","COMMENT","isArray","n1","n2","ancestor","path1","path2","shift","paths","isText","RangeError","_parent","fragment","createFragment","createInlineBlock","substring","insertBefore","removeChild","findCommonAncestor","_paths","baseStartNode","baseEndNode","_startIndex","_sort","_sort2","startIndex","endIndex","_fragment","extractNodes","isStartSided","isSidedDescendantOf","isEndSided","foundBlock","findOne","_block2","createBlock","insertAt","inserting","startText","_block","endText","expression","toUpperCase","substr","validNode","side","lastChild","prependChild","pull","pullAt","_this$children","splice","validParent","refIndex","newChild","oldChild","validChild","replaceChild","set","merge","has","unset","isObject","selector","one","intersection","findBy","hasChild","findTextByRange","callback","stack","childLength","merged","textNode","createText","slice","mergeText","items","entityNodes","sortBy","lastPos","item","entityNode","createChild","replaceWith","entities","cache","Map","_extractEntities","mark","_callee","extractor","textList","wrap","_context","prev","extract","sent","stop","previousSibling","_options$position","position","_options$textPosition","textPosition","omitBy","isUndefined","rootNode","getRootNode","last","siblings","childIndex","_TextLine","_chalk","LINE_BREAKS","tabSize","lines","markers","cursorStack","init","matched","offset","_text","_text2","lineOffsetIndexes","lineIndex","sortedLastIndex","trimSpaces","_this$getPosition","getPosition","trimStart","_this$getPosition2","charAt","ok","ch","lastMatch","chr","string","eat","eof","peek","caseInsensitive","left","_options$toEOL","toEOL","_options$toEOF","toEOF","_options$consume","consume","_options$skipMatched","skipMatched","_this$search","search","_line","readTo","nextLine","read","_options$consume2","_this$search2","marker","extend","_data","pop","trim","numWidth","bgBlue","blueBright","padStart","_this$getPosition5","max","min","l","isCurrent","debugLine","debugCursor","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_assertThisInitialized2","_wrapNativeSuper2","_Error","State","stateNames","getStateName","countLineBreaks","stream","defaultOptions","verbose","NODE_ENV","PUBLIC_URL","DEBUG","parsed","_console","timeStart","now","METADATA","lastState","unwrapped","inline","embedded","isClosing","nodeStack","getNodeString","debugStack","lastNode","cyanBright","green","redBright","grey","pushNode","debug","popNode","createError","levelUpBlock","blockNode","FINISH","magenta","debugState","eatWhile","ATTRIBUTE_LIST","NORMAL","sol","eol","isInlineBlock","START","SINGLE_COMMENT","MULTIPLE_COMMENT","TAG_START","TAG_END","ENTITY_START","END","TAG_NAME","LABEL_START","_child","metaKey","pushCursor","tagName","popCursor","_child2","simpleBlock","spacePattern","spaces","isParsingMetadata","endOfFrontMatter","lineBreaks","_child3","clearLabels","clearMetadata","ATTRIBUTE_ASSIGN","ATTRIBUTE_NAME","_key","_ch2","ATTRIBUTE_FINISH","eatSpaces","ATTRIBUTE_VALUE","_ch3","_value","parseFloat","isNull","_key2","_value2","setMetadata","setAttribute","parseMetadata","tagNode","setAttributes","ENTITY_END","skipOver","_child4","ENTITY_BODY"],"mappings":"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","file":"static/js/main.c71d2faf.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatValue = formatValue;\nexports.parseValue = parseValue;\nexports.spacer = spacer;\nexports.stringify = stringify;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar P_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z$/;\n/**\n * Stringify attribute value\n * @param value \n */\n\nfunction formatValue(value) {\n  if (_.isDate(value)) {\n    return value.toISOString().replace(/T00:00:00\\.000Z$/, '');\n  } else if (_.isString) {\n    return _constants.P_STRING_LITERAL_UNQUOTED_TESTER.test(value) ? value : JSON.stringify(value);\n  } else if (_.isBoolean(value)) {\n    return JSON.stringify(value);\n  } else if (_.isNumber(value) && !_.isNaN(value) && value !== Infinity || value !== -Infinity) {\n    return JSON.stringify(value);\n  } else {\n    return null;\n  }\n}\n/**\n * Parse attribute value\n * @param value \n */\n\n\nfunction parseValue(value) {\n  if (P_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * Generate indent spaces\n * @param space \n * @param indent \n */\n\n\nfunction spacer(space, indent) {\n  if (indent <= 0) return '';\n  return _.repeat(_constants.T_SPACE, space * indent);\n}\n/**\n * Stringify node\n * @param node \n * @param [options]\n * @param [options.space] White spaces each indent\n * @param [options.simple] Enable simple block when suitable\n * @param [options.toSource] To ZAML source code\n * @param [indent] Initial indent, increases 1 each block\n * @param Initial position\n */\n\n\nfunction stringify(node, options) {\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var text = '';\n\n  if (_.isNumber(options)) {\n    options = {\n      space: options\n    };\n  }\n\n  options = _.defaults(options, {\n    space: _constants.DEFAULT_INDENT_SPACES,\n    simple: false,\n    toSource: false\n  });\n  var simpleTag = options.simple && node.isSimpleTag;\n\n  if (options.toSource) {\n    node.start = pos;\n  } else {\n    node.textStart = pos;\n  }\n\n  if (node.type === _Node.NodeType.TEXT) {\n    text += node.content;\n  } else {\n    if (options.toSource && !_.isEmpty(node.metadata)) {\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n\n      _.each(node.metadata, function (value, key) {\n        text += \"\".concat(key, \": \");\n\n        if (value instanceof _Node.default) {\n          text += stringify(value, options, 0, pos + text.length);\n        } else {\n          text += formatValue(value);\n        }\n\n        text += _constants.T_LINE_BREAK;\n      });\n\n      text += _constants.T_METADATA_MARKER + _constants.T_LINE_BREAK;\n    }\n\n    if (node.type === _Node.NodeType.ENTITY) {\n      var child = _.first(node.children);\n\n      if (!child) {\n        throw new Error('missing text node of entity');\n      }\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_START;\n      }\n\n      text += stringify(child, options, indent, pos + text.length);\n\n      if (options.toSource) {\n        text += _constants.T_ENTITY_END;\n      }\n    }\n\n    if (options.toSource && (node.type === _Node.NodeType.TAG || node.type === _Node.NodeType.ENTITY)) {\n      if (node.isBlock) {\n        text += spacer(options.space, indent);\n      }\n\n      if (!(simpleTag && node.children.length === 1)) {\n        text += _constants.T_TAG_START;\n      }\n\n      if (!simpleTag) {\n        text += node.name;\n      }\n\n      var listCount = 0;\n\n      _.keys(node.attributes).forEach(function (key, i) {\n        var value = node.attributes[key];\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        if (_.isBoolean(value) && value) {\n          text += key;\n        } else if (value instanceof _Node.default) {\n          text += stringify(node, options, 0, pos + text.length);\n        } else {\n          text += \"\".concat(key, \"=\").concat(formatValue(value));\n        }\n      });\n\n      _.each(node.labels, function (label, i) {\n        listCount++;\n\n        if (!simpleTag || listCount > 1) {\n          text += _constants.T_SPACE;\n        }\n\n        text += \"#\".concat(label);\n      });\n\n      text += simpleTag ? _constants.T_SPACE : _constants.T_TAG_END;\n\n      if (node.isBlock) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.type === _Node.NodeType.PARAGRAPH) {\n      text += spacer(options.space, indent);\n    }\n\n    if (node.isBlock || node.isWrappingTag && !_.isEmpty(node.children)) {\n      node.children.forEach(function (child) {\n        var subText = stringify(child, options, indent + 1, pos + text.length);\n        text += subText;\n      });\n    }\n\n    var next = node.nextSibling;\n\n    if (node.isBlock) {\n      if (options.toSource) {\n        text = _.trimEnd(text, _constants.T_LINE_BREAK);\n      }\n\n      text += _constants.T_LINE_BREAK;\n\n      if (node.type === _Node.NodeType.PARAGRAPH && !node.isLastChild) {\n        text += _constants.T_LINE_BREAK;\n      }\n    }\n\n    if (options.toSource && node.isWrappingTag) {\n      if (node.isBlockTag) {\n        text += spacer(options.space, indent);\n      }\n\n      if (simpleTag) {\n        if (node.children.length > 1) {\n          text += _constants.T_TAG_END;\n        }\n      } else {\n        text += _constants.T_TAG_START + _constants.T_TAG_CLOSING + node.name + _constants.T_TAG_END;\n      }\n\n      if (node.isBlockTag) {\n        text += _constants.T_LINE_BREAK;\n\n        if (next && next.isBlock) {\n          text += _constants.T_LINE_BREAK;\n        }\n      }\n    }\n  }\n\n  if (options.toSource) {\n    node.end = node.start + text.length;\n  } else {\n    node.textEnd = node.textStart + text.length;\n  }\n\n  return text.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\n}","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.parse = parse;\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _Tokenizer.default;\n  }\n});\nObject.defineProperty(exports, \"TextStream\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.default;\n  }\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextStream.TextLine;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.default;\n  }\n});\nObject.defineProperty(exports, \"NodeType\", {\n  enumerable: true,\n  get: function get() {\n    return _Node.NodeType;\n  }\n});\nObject.defineProperty(exports, \"ParseError\", {\n  enumerable: true,\n  get: function get() {\n    return _ParseError.default;\n  }\n});\nexports.default = void 0;\n\nvar _Tokenizer = _interopRequireDefault(require(\"./Tokenizer\"));\n\nvar _TextStream = _interopRequireWildcard(require(\"./TextStream\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/**\n * @module @zaml/parser\n * @typicalname parser\n */\n\n/**\n * Parse ZAML source into node\n * @param text ZAML source string\n */\n\n\nfunction parse(text, options) {\n  var tokenizer = new _Tokenizer.default(text, options);\n  return tokenizer.process();\n}\n/**\n * Parse ZAML source into node\n * @deprecated Please use zaml.parse() instead\n * @param {string} text Source string\n */\n\n\nfunction tokenize(text, options) {\n  console.warn('zaml.tokenize() is deprecated, please use zaml.parse() instead');\n  return parse(text, options);\n}\n\nvar _default = {\n  ParseError: _ParseError.default,\n  Tokenizer: _Tokenizer.default,\n  TextStream: _TextStream.default,\n  TextLine: _TextStream.TextLine,\n  Node: _Node.default,\n  NodeType: _Node.NodeType,\n  tokenize: tokenize,\n  parse: parse\n};\nexports.default = _default;","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\ninterface Props {\n  title: string;\n  className: string;\n}\n\nexport default class Pane extends React.Component<Props> {\n\n  static propTypes = {\n    title: PropTypes.string,\n    className: PropTypes.string,\n  }\n\n  static defaultProps: Props = {\n    title: 'pane',\n    className: '',\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { title, className, children } = this.props;\n    return (\n      <div className={classNames('pane', className)}>\n        <div className=\"pane-title\"><h2>{title}</h2></div>\n        <div className=\"pane-content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import CodeMirror from 'codemirror';\nimport 'codemirror/addon/mode/simple';\n\n// https://codemirror.net/demo/simplemode.html\n// TODO support error linting\n\n(CodeMirror as any).defineSimpleMode(\"zaml\", {\n  // The start state contains the rules that are initially used\n  start: [\n    // Block labels\n    {regex: /#[^#\\s\\n}]+/, token: 'variable-3'},\n    // Entity tag & block tag without attributes\n    {regex: /{\\/?([^\\s}]+)}/, token: 'keyword'},\n    // attribute names\n    {regex: /[^\\s{\\n]+(?=[:=][^\\n])/, token: 'variable-2'},\n    // Block brackets\n    {regex: /{|}/, token: 'def'},\n    // Block starting tag\n    {regex: /(?={)[^\\s}]+/, token: 'keyword'},\n    // Entity text content\n    {regex: /\\[[^\\]]+\\]/, token: \"string\"},\n    // Block tag\n    {regex: /(?:BLOCK|INLINE)\\b/, token: \"keyword\"},\n    // Special values\n    {regex: /true|false|null|undefined/, token: \"atom\"},\n    // Numbers\n    {regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\"},\n    // Single line comment\n    {regex: /~[^~].*/, token: \"comment\"},\n    // Multi-line comment start\n    {regex: /~~~/, token: \"comment\", next: \"comment\"},\n    // ?\n    {regex: /\\/(?:[^\\\\]|\\\\.)*?\\//, token: \"variable-3\"},\n    // Intends\n    {regex: /[\\{]/, indent: true},\n    {regex: /[\\}]/, dedent: true},\n    // {regex: /[a-z$][\\w$]*/, token: \"variable\"},\n    // {regex: /<</, token: \"meta\", mode: {spec: \"xml\", end: />>/}}\n  ],\n  // The multi-line comment state.\n  comment: [\n    // Multi-line comment ends\n    {regex: /.*?~~~/, token: \"comment\", next: \"start\"},\n    // Multi-line comment continues\n    {regex: /.*/, token: \"comment\"}\n  ],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    dontIndentStates: [\"comment\"],\n    lineComment: \"~\"\n  }\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport codemirror from 'codemirror';\nimport { Controlled as CodeMirror } from 'react-codemirror2'\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport './SourceEditor.scss';\nimport './codemirror-mode';\n\ninterface Props {\n  value: string;\n  height: number;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  value: string;\n}\n\nconst codeMirrorOptions: codemirror.EditorConfiguration = {\n  mode: 'zaml',\n  lineNumbers: true,\n  lineWrapping: true,\n};\n\nexport default class SourceEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    value: PropTypes.string,\n    height: PropTypes.number,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    value: '',\n    height: -1,\n    onChange: () => {},\n  }\n\n  public editor?: CodeMirror.Editor;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      value: props.value,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (this.editor) {\n      if (nextProps.height !== this.props.height && this.editor) {\n        this.editor.setSize(null, nextProps.height);\n      }\n      if (nextProps.value !== this.props.value) {\n        this.editor.setValue(nextProps.value);\n      }\n    }\n  }\n\n  render() {\n    const { onChange } = this.props;\n    const { value } = this.state;\n    return (\n      <div className=\"zaml-source\">\n        <CodeMirror\n          value={value}\n          options={codeMirrorOptions}\n          onBeforeChange={(editor, data, value) => this.setState({ value })}\n          onChange={(editor, data, value) => onChange(value)}\n          editorDidMount={editor => this.editor = editor}\n        />\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './VisualNode.scss';\n\nconst { NodeType } = zaml;\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  selectedNode?: zaml.Node;\n}\n\nexport default class VisualNode extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const { node, selectedNode } = this.props;\n    let element: string | null;\n    if (!node) return null;\n    const selected = node === selectedNode;\n    let children: any = [];\n    if (node.type === NodeType.ROOT) {\n      element = 'div';\n    } else if (node.type === NodeType.PARAGRAPH) {\n      element = 'p';\n    } else if (node.type === NodeType.TEXT) {\n      element = 'span';\n    } else if (node.type === NodeType.ENTITY) {\n      if (node.name === 'LINK') {\n        return (\n          <a\n            className=\"zaml-entity\"\n            node-name=\"link\"\n            node-id={node.id}\n            href={node.attributes.url}\n          >\n            <VisualNode\n              node-id={node.children[0].id}\n              {...this.props}\n              node={node.children[0]}\n            />\n          </a>\n        );\n      } else {\n        element = 'span';\n      }\n    } else if (node.type === NodeType.TAG) {\n      // children.push(\n      //   <span key=\"attributes\" className=\"attributes\">{node.name}</span>\n      // );\n      if (node.isBlock) {\n        element = 'div';\n      } else {\n        element = 'span';\n      }\n    } else {\n      element = null;\n    }\n    if (!element) {\n      return null;\n    }\n    if (!_.isEmpty(node.children)) {\n      children.push(\n        <span key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => (\n            <VisualNode {...this.props} key={i} node={child} />\n          ))}\n        </span>\n      );\n    } else if (node.type === 'text') {\n      children.push(\n        node.content\n      );\n    }\n    return React.createElement(element, {\n      className: classNames('zaml-node', `${node.type}`, { block: node.isBlock, selected }),\n      'node-name': node.name && node.name.toLowerCase(),\n      'node-id': node.id,\n    }, children);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport { ContextMenuTarget, Menu, MenuItem, MenuDivider } from \"@blueprintjs/core\"\nimport VisualNode from './VisualNode';\nimport './VisualEditor.scss';\nimport 'react-contexify/dist/ReactContexify.min.css';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  commonEntityNames?: string[];\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node?: zaml.Node) => void;\n  onChange: (node?: zaml.Node, selected?: zaml.Node) => void;\n}\n\ninterface State {\n}\n\n@ContextMenuTarget\nexport default class VisualEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    commonEntityNames: PropTypes.arrayOf(PropTypes.string),\n    root: PropTypes.shape({}),\n    selectedNode: PropTypes.shape({}),\n    onSelect: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    commonEntityNames: ['PER', 'ORG', 'LOC', 'DATE'],\n    onSelect: () => {},\n    onChange: () => {},\n  }\n\n  public currentNode?: zaml.Node;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleContextMenu = (event: React.MouseEvent, node?: zaml.Node) => {\n    this.currentNode = node;\n    this.setState({ node });\n  }\n\n  handleDoubleClick(event: React.MouseEvent) {\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const domNode = range.startContainer;\n    const text = domNode.textContent;\n    if (!text) return;\n    event.preventDefault();\n    event.stopPropagation();\n    const punctuationPattern = /[!?:;]/g;\n    let startPos = 0;\n    let endPos = text.length;\n    let pos = 0;\n    while (punctuationPattern.exec(text)) {\n      startPos = pos;\n      pos = punctuationPattern.lastIndex;\n      punctuationPattern.lastIndex++;\n      if (pos > range.startOffset) {\n        endPos = pos;\n        break;\n      }\n    }\n    range.setStart(domNode, startPos);\n    range.setEnd(domNode, endPos);\n  }\n\n  handleCreateBlock() {\n    const { root, onChange } = this.props;\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const commonNode = this.getNodeByElement(range.commonAncestorContainer as HTMLElement);\n    let startNode = this.getNodeByElement(range.startContainer as HTMLElement);\n    let endNode = this.getNodeByElement(range.endContainer as HTMLElement);\n    if (!commonNode || !startNode || !endNode) {\n      return;\n    }\n    const block = zaml.Node.createBlockByRange({\n      startNode,\n      startOffset: range.startOffset,\n      endNode,\n      endOffset: range.endOffset,\n    });\n    selection.removeAllRanges();\n    onChange(root, block);\n  }\n\n  handleRemoveBlock(node?: zaml.Node) {\n    if (!node) {\n      return;\n    }\n    const { root, onChange } = this.props;\n    const parent = node.flatten();\n    onChange(root, parent);\n  }\n\n  handleCreateEntity(target: zaml.Node, name: string | null) {\n    const { root, onChange } = this.props;\n    if (!name) return;\n    const selection = window.getSelection();\n    if (selection.anchorNode !== selection.focusNode) {\n      alert('Entity is only allowed in pure text!');\n      return;\n    }\n    if (selection.rangeCount === 0) return;\n    const range = selection.getRangeAt(0);\n    const entityNodes = target.createEntities([{\n      type: name,\n      start: range.startOffset,\n      end: range.endOffset,\n    }]);\n    onChange(root, entityNodes[0]);\n  }\n\n  handleRemoveEntity(node?: zaml.Node) {\n    const { root, onChange } = this.props;\n    if (!node) return;\n    const textNode = node.removeEntity();\n    onChange(root, textNode);\n  }\n\n  handleInspect(node: zaml.Node) {\n    const { onSelect } = this.props;\n    onSelect(node);\n  }\n\n  getNodeByElement(element: HTMLElement) {\n    const { root: root } = this.props;\n    if (!root) return undefined;\n    if (element.nodeType === element.TEXT_NODE || element.classList.contains('children')) {\n      if (!element.parentElement) {\n        return undefined;\n      }\n      element = element.parentElement;\n    }\n    const id = element.getAttribute('node-id');\n    if (!id) return undefined;\n    return root.getNodeById(id);\n  }\n\n  render() {\n    const { root: node, selectedNode } = this.props;\n    return (\n      <div\n        className=\"zaml-visual-editor\"\n        onDoubleClick={(event: React.MouseEvent) => this.handleDoubleClick(event)}\n      >\n        <VisualNode\n          node={node}\n          selectedNode={selectedNode}\n        />\n      </div>\n    )\n  }\n\n  renderContextMenu(e: React.MouseEvent<HTMLElement>) {\n    const { commonEntityNames } = this.props;\n    const target = this.getNodeByElement(e.target as HTMLElement);\n    let node = target;\n    if (!target) return;\n    if (target.type === NodeType.TEXT) {\n      node = target.parent;\n    }\n    if (!node) return;\n    const wrapperNode = node;\n    return (\n      <Menu id=\"menu\">\n        <MenuItem disabled text={node.descriptor} />\n        <MenuDivider />\n        <MenuItem\n          text=\"Create Block\"\n          onClick={() => this.handleCreateBlock()}\n        />\n        {node.isWrappingTag &&\n          <MenuItem\n            text=\"Remove Block\"\n            onClick={() => this.handleRemoveBlock(node)}\n          />\n        }\n        {target.type === NodeType.TEXT && target.parent && target.parent.type !== NodeType.ENTITY &&\n          <MenuItem text=\"Create Entity\">\n            {commonEntityNames && commonEntityNames.map(name => (\n              <MenuItem\n                key={name}\n                text={name}\n                onClick={() => this.handleCreateEntity(target, name)}\n              />\n            ))}\n            <MenuItem\n              text=\"other...\"\n              onClick={() => this.handleCreateEntity(target, prompt('Please input entity type', 'PER'))}\n            />\n          </MenuItem>\n        }\n        {node.type === NodeType.ENTITY &&\n          <MenuItem\n            text=\"Remove Entity\"\n            onClick={() => this.handleRemoveEntity(node)}\n          />\n        }\n        <MenuDivider />\n        <MenuItem\n          text=\"Inspect\"\n          onClick={() => this.handleInspect(wrapperNode)}\n        />\n      </Menu>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\n\nvar _ref =\n/*#__PURE__*/\nReact.createElement(\"title\", null, \"ZAML-logo\");\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M132.27,162.53,182.46,35.88h10.68L242.7,162.53h-9.83L216.64,122H158.11l-16.23,40.58Zm81.16-48.7L187.38,45.7l-26.7,68.13Z\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M404.81,35.88h8.54V154.42h68.14v8.12H404.81Z\"\n});\n\nvar _ref4 =\n/*#__PURE__*/\nReact.createElement(\"circle\", {\n  fill: \"#fff\",\n  cx: 91,\n  cy: 44.5,\n  r: 4\n});\n\nvar _ref5 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"#fff\",\n  d: \"M115.47,35.5h-5a54.66,54.66,0,0,0-1-10.36c-1.07-4.28-6.09-10.34-6.3-10.6l-1.5-1.8-5.3,11.14-1-2c-2.21-4.43-10.89-7.42-11.87-7.75l-2.19-.73L83.4,35.5H36v0c-7.77.27-14,11.14-14,19s6.23,9.71,14,10v0H89.75L22.31,154.42v8.12h92.32l4.23.11S121,159.5,121,153.5s-3.4-15-12.5-15c-6.78,0-14.5,5-23.5,7S60,147.3,54.63,147c5.75-5.44,12.61-12,19.66-19H92.56l.42-.37c1-.87,24.31-21.36,30.37-34.5s7.1-54.83,7.14-56.59l0-1.59ZM49.84,147.41c-3.23-.24-7.53-.76-9.84-1.91a10.79,10.79,0,0,1-4.46-3.93l9.58-12.91,22.46,1.73C61.06,136.77,54.88,142.66,49.84,147.41ZM95,63.5s-1.76-7.52-1-10c1-3.4,7.94-10.83,12-15h8.53c0,.53,0,1.17,0,1.9l-.1.41C109,43.74,97.93,51.53,97,53.5S96.52,61,99.31,64.66c-1.35-.1-2.72-.27-4-.44l-.09-.06A4.8,4.8,0,0,0,95,63.5ZM109,76a79.27,79.27,0,0,1-9,2.49c-5,1-13,0-13,0l3-8s11,0,15-1a22.68,22.68,0,0,0,6.55-3.2C110.86,69.46,110,72.72,109,76ZM100,55.5c1.27-4.12,11.13-10.58,14.13-12.46l.28,1.1c-.09,2-.25,4.37-.5,7-4.19,1.21-7.81,2.49-8.57,3.26-1.53,1.54-2.77,6.17-1.83,10.35a22.78,22.78,0,0,1-2.67,0C100.42,62.8,99.38,57.51,100,55.5Zm12.46,6.2a52.93,52.93,0,0,1-7,2.68c.39-2.42,1.09-5.83,2-7.11s3.41-2.62,6.16-3.69C113.36,56.12,113,58.85,112.46,61.7ZM93.9,103.48l-2.23,2.41c-2.73.33-7.34.94-10.66,1.61-5,1-14-1-14-1l5-7s10,2,15,2a46.82,46.82,0,0,0,9.79-1.43Q95.42,101.83,93.9,103.48Zm-18,18.63c-2.09.61-8.46,2.39-10.95,2.39-3,0-11-2-11-2l6-7s10,1,14,1c2.58,0,7.21-1.62,10.2-2.77C81.48,116.53,78.72,119.34,75.95,122.11Zm20.16-16.6.2-.23v0l13.94,1c-1.5,1.69-3,3.36-4.58,5L92.86,109C94,107.83,95,106.67,96.1,105.52Zm3.83-4.64c.83-1.11,1.63-2.24,2.39-3.39l15.58-.87a80.42,80.42,0,0,1-5,6.6Zm2.14-8.73c-2.72.92-7.36,2.36-10.07,2.36-4,0-14-2-14-2l4-7s12,1,17,0a29.42,29.42,0,0,0,7.62-2.87A78.48,78.48,0,0,1,102.07,92.14Zm8.3-10.92,13.49-1.45c-.29,1.68-.6,3.27-.94,4.76L109,84.78Q109.71,83,110.37,81.23Zm1.71-5q.37-1.21.71-2.4l12.31-2.66c-.18,1.52-.38,3-.59,4.49Zm13.51-9.45-11.44,1.84q.49-2.1.88-4.1l11-2.33C125.89,63.65,125.75,65.19,125.59,66.73Zm.8-9-10.45,1.6c.27-1.72.49-3.39.68-5L126.78,52C126.67,53.82,126.54,55.73,126.39,57.69Zm.64-10-9.91,1.46c.11-1.41.2-2.73.26-3.94l9.86-1.83C127.19,44.71,127.12,46.16,127,47.72Zm.35-7.55-9.85,1.1c0-.86,0-1.62,0-2.27l.54-2.71,9.36,1.76C127.44,38.62,127.41,39.35,127.38,40.17ZM103,22.5c1.6,2.16,2.45,2.8,3,5a38,38,0,0,1,1.48,7.5L95,34.5Zm-16-1c2.86,1.2,5.92,2.84,7,5l.57,1.12L91.15,34.8,86.36,35Zm-14.15,40c2.93-3.55,7-9.51,6.15-11s-9.88-8.63-14.57-12h5c3.95,2.86,15,11.13,16.6,15,.66,1.62-2.73,5.58-5,8Zm-8.69,0c2.51-3.93,6.93-11.56,5.59-14.49-1.2-2.61-7.5-6.27-11.75-8.51h4.38C65.77,41,74.46,47.72,76,51.5c.7,1.73-3,7.1-5.09,10ZM58.29,44.86c-1.17-2.24-4.34-4.68-6.84-6.36h5c3.41,2.86,9.22,8,9.44,10s-1.62,9.22-2.66,13H53.83C55.92,57,59.82,47.78,58.29,44.86ZM49.73,38.5c1.57,2.07,3.73,5.17,4,6.9.34,2.07-.46,11.5-.89,16.1H44.16c2.25-4,6.89-12.79,5.84-16a25.41,25.41,0,0,0-4.36-7ZM38,38.5h6.64c1.16,2.25,2.5,5.21,2.5,6.8,0,2.17-2.5,11.94-3.61,16.2H38a33,33,0,0,0,2-11A43.6,43.6,0,0,0,38,38.5Zm45.1,23c3.13-3,7.22-8,6.58-9.11-1.23-2.1-11.76-9.83-18.09-13.89h33.72C100.81,42.24,93.63,48.44,92.43,51c-1.05,2.24-1.78,8.57,1.36,12.27L91,61.5ZM91.43,125H77.3c3.76-3.75,7.52-7.58,11.15-11.36l13.63,1.29C97.09,119.91,92.76,123.82,91.43,125Zm28.4-31.54-14.58-.89q.75-1.37,1.44-2.76l15.15-1.15a26.58,26.58,0,0,1-1.19,3.21C120.4,92.39,120.12,92.92,119.83,93.46Z\"\n});\n\nvar _ref6 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 255,\n  y: 36.5,\n  width: 14.69,\n  height: 15,\n  rx: 1.5,\n  ry: 1.5\n});\n\nvar _ref7 =\n/*#__PURE__*/\nReact.createElement(\"rect\", {\n  fill: \"#fff\",\n  x: 258.07,\n  y: 55.56,\n  width: 8.54,\n  height: 106.97\n});\n\nvar _ref8 =\n/*#__PURE__*/\nReact.createElement(\"polygon\", {\n  fill: \"#fff\",\n  points: \"364.01 35.88 317.88 151.85 274.33 42.9 274.33 64.8 313.82 162.53 321.72 162.53 368.93 45.7 368.93 162.53 377.47 162.53 377.47 35.88 364.01 35.88\"\n});\n\nvar SvgComponent = function SvgComponent(props) {\n  return React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    viewBox: \"0 0 500 180\"\n  }, props), _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n};\n\nexport default __webpack_public_path__ + \"static/media/logo.b94cec94.svg\";\nexport { SvgComponent as ReactComponent };","import _ from 'lodash';\nimport * as React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport classNames from 'classnames';\nimport './TreeNode.scss';\n\nconst { NodeType } = zaml;\n\nexport enum NodePart {\n  Header = 'header',\n  Footer = 'footer',\n  Whole = 'whole',\n}\n\nconst nil = () => {};\n\ninterface Props {\n  node?: zaml.Node;\n  expandedNodes: string[];\n  selectedNode?: zaml.Node;\n  selectedPart?: NodePart;\n  onSelect: (node: zaml.Node) => void;\n  onSelectPart: (selectedPart: NodePart) => void;\n  onExpansionChange: (node: zaml.Node, expanded: boolean) => void;\n  onMouseEnter: (node:zaml.Node) => void;\n  onMouseOut: (node:zaml.Node) => void;\n}\n\ninterface State {\n}\n\nexport default class TreeNode extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    node: undefined,\n    expandedNodes: [],\n    selectedNode: undefined,\n    selectedPart: NodePart.Whole,\n    onSelect: nil,\n    onSelectPart: nil,\n    onExpansionChange: nil,\n    onMouseEnter: nil,\n    onMouseOut: nil,\n  }\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  render() {\n    const {\n      node,\n      selectedNode,\n      selectedPart: _selectedPart,\n      expandedNodes,\n      onSelect,\n      onSelectPart,\n      onExpansionChange,\n      onMouseEnter,\n      onMouseOut,\n    } = this.props;\n    if (!node) return null;\n    let selectedPart = _selectedPart;\n    const expanded = expandedNodes.indexOf(node.id) > -1 || node.isRoot;\n    if (expanded && selectedPart === NodePart.Whole) {\n      selectedPart = NodePart.Header;\n    }\n    const selected = selectedNode === node;\n    const onClick = (selectedPart: NodePart) => (event: React.MouseEvent) => {\n      event.stopPropagation();\n      onSelect(node);\n      onSelectPart(selectedPart);\n    };\n    const commonProps = {\n      onMouseEnter: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseEnter(node);\n      },\n      onMouseOut: (event: React.MouseEvent) => {\n        event.stopPropagation();\n        onMouseOut(node);\n      },\n    }\n    let children: any = null;\n    if (!_.isEmpty(node.children)) {\n      children = (\n        <div key=\"children\" className=\"children\">\n          {_.map(node.children, (child, i) => <TreeNode {...this.props} key={i} node={child} />)}\n        </div>\n      );\n    } else if (node.type === 'text') {\n      children = node.content;\n    }\n    if (node.type === NodeType.TEXT) {\n      return (\n        <div\n          className={classNames('text', { selected })}\n          onClick={onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          \"{node.content}\"\n        </div>\n      )\n    } else if (node.type === NodeType.ENTITY || node.isBlock || node.isWrappingTag) {\n      const isEntity = node.type === NodeType.ENTITY;\n      const isTag = node.type === NodeType.TAG;\n      let onlyText: string | undefined;\n      if (node.children.length === 1 && (node.firstChild as zaml.Node).type === NodeType.TEXT) {\n        onlyText = (node.firstChild as zaml.Node).content;\n      }\n      const nameStart = isEntity ? '[' : isTag ? '{' : '<';\n      const nameEnd = isEntity ? ']' : isTag ? '}' : '>';\n      let name = (isTag || isEntity) ? node.name : node.type;\n      return (\n        <div\n          className={classNames('block', {\n            expanded,\n            selected: selected && selectedPart === NodePart.Whole,\n            'node-selected': selected,\n          })}\n          onClick={expanded ? undefined : onClick(NodePart.Whole)}\n          {...commonProps}\n        >\n          {node.type !== NodeType.ROOT && (\n            <span\n              className=\"indicator\"\n              onClick={(event) => {\n                event.stopPropagation();\n                onExpansionChange(node, !expanded);\n              }}\n            ></span>\n          )}\n          <span\n            className={classNames('header', { selected: selected && selectedPart === NodePart.Header })}\n            onClick={expanded ? onClick(NodePart.Header) : undefined}\n          >\n            {nameStart}\n            {name}\n            {node.labels.map(label => (\n              <span key={label} className=\"prop label\">#{label}</span>\n            ))}\n            {_.keys(node.attributes).map(key => {\n              const value = node.attributes[key];\n              return (\n                <span key={key} className=\"prop attribute\">\n                  <span className=\"key\">{key}</span>\n                  <span className=\"assignment\">=</span>\n                  <span className=\"value\">{JSON.stringify(value)}</span>\n                </span>\n              );\n            })}\n            {nameEnd}\n          </span>\n          {expanded ? children : (\n            <span className=\"ellipsis\">{_.truncate(onlyText, { length: 10 }) || '...'}</span>\n          )}\n          <span\n            className={classNames('footer', { selected: selected && selectedPart === NodePart.Footer })}\n            onClick={expanded ? onClick(NodePart.Footer) : undefined}\n          >\n            {nameStart}\n            /\n            {name}\n            {nameEnd}\n          </span>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport * as zaml from '@zaml/parser';\nimport { NodePart } from './TreeNode';\n\nconst { NodeType } = zaml;\n\ninterface Props {\n  selected: boolean;\n  node?: zaml.Node;\n  onClick: () => void;\n}\n\nexport default class TreePathItem extends React.Component<Props> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selected: false,\n    node: undefined,\n    onClick: () => {},\n  }\n\n  render() {\n    const { selected, node, onClick } = this.props;\n    if (!node) {\n      return null;\n    }\n    return (\n      <span\n        className={classNames('zaml-tree-path-item', node.type, { selected })}\n        onClick={onClick}\n      >\n        {node.descriptor}\n      </span>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePathItem from './TreePathItem';\n\ninterface Props {\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n}\n\ninterface State {\n  nodeList: zaml.Node[];\n}\n\nexport default class TreePath extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    selectedNode: undefined,\n    onSelect: () => {},\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeList: this.buildNodeList(props.selectedNode),\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { nodeList } = this.state;\n    const node = nextProps.selectedNode;\n    if (!node) {\n      this.setState({\n        nodeList: [],\n      });\n    } else if (!_.includes(nodeList, node)) {\n      this.setState({\n        nodeList: this.buildNodeList(node),\n      });\n    }\n  }\n\n  buildNodeList(node: zaml.Node | undefined) {\n    let list: zaml.Node[] = [];\n    while (node) {\n      list.unshift(node);\n      node = node.parent;\n    }\n    return list;\n  }\n\n  render() {\n    const { selectedNode, onSelect } = this.props;\n    const { nodeList } = this.state;\n    return (\n      <div className=\"zaml-tree-path\">\n        {nodeList.map(n => (\n          <TreePathItem\n            key={n.id}\n            selected={n === selectedNode}\n            node={n}\n            onClick={() => onSelect(n)}\n          />\n        ))}\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\n\ninterface Props {\n}\n\nexport default class TreeToolbar extends React.Component<Props> {\n\n  static propTypes = {\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n  };\n\n  render() {\n    return (\n      <div className=\"zaml-tree-toolbar\">\n        toolbar\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport './TreePropEditor.scss';\nimport TabView from '../Common/TabView';\nimport { KeyValueMap } from '@zaml/parser/typings/Node';\n\ninterface Props {\n  node?: zaml.Node;\n}\n\ninterface State {\n  selectedTab?: string;\n  editingIndex: number;\n  inlineError: string;\n}\n\nenum Tab {\n  Labels = 'Labels',\n  Attributes = 'Attributes',\n  Metadata = 'Metadata',\n}\n\nconst tabs = _.values(Tab);\nconst defaultTab = tabs[0];\nconst defaultEditingIndex = -1;\n\nexport default class TreePropEditor extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.instanceOf(zaml.Node),\n  }\n\n  static defaultProps: Props = {\n  }\n\n  state = {\n    selectedTab: defaultTab,\n    editingIndex: defaultEditingIndex,\n    inlineError: '',\n  };\n\n  editingElement: HTMLInputElement | null = null;\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (nextProps.node !== this.props.node) {\n      this.setState({\n        selectedTab: defaultTab,\n        editingIndex: defaultEditingIndex,\n      });\n    }\n  }\n\n  renderValue(value: any) {\n    if (value instanceof zaml.Node) {\n      return value.toSource();\n    } else {\n      return JSON.stringify(value);\n    }\n  }\n\n  renderEmptyTip() {\n    return (\n      <div className=\"select-tip\">Please select a node</div>\n    )\n  }\n\n  renderTabContent() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    if (!node) {\n      return this.renderEmptyTip();\n    }\n    switch(selectedTab) {\n      case Tab.Labels:\n        return this.renderLabelEditor(node);\n      case Tab.Attributes:\n        return this.renderAttributeEditor(node, node.attributes);\n      case Tab.Metadata:\n        return this.renderAttributeEditor(node, node.metadata);\n    }\n  }\n\n  focusEditingElement() {\n    if (this.editingElement) {\n      this.editingElement.focus();\n      this.editingElement.select();\n    }\n  }\n\n  handleLabelEdit(index: number) {\n    this.setState({ editingIndex: index }, () => {\n      this.focusEditingElement();\n    });\n  }\n\n  handleLabelUpdate(label: string) {\n    const { node } = this.props;\n    const { editingIndex } = this.state;\n    if (!node) return;\n    const originalLabel = node.labels[editingIndex] || '';\n    if (label !== originalLabel) {\n      try {\n        zaml.parse(`{INLINE #${label}}TESTING{/INLINE}`);\n      } catch (e) {\n        this.setState({ inlineError: 'Invalid label'});\n        return;\n      }\n      if (editingIndex === node.labels.length) {\n        node.addLabel(label);\n      } else {\n        if (label === '' || node.labels.indexOf(label) >= 0) {\n          node.removeLabel(originalLabel);\n        } else {\n          node.labels[editingIndex] = label;\n        }\n      }\n    }\n    this.cancelLabelEditing();\n  }\n\n  cancelLabelEditing() {\n    this.setState({\n      editingIndex: defaultEditingIndex,\n      inlineError: '',\n    });\n  }\n  renderLabelEditor(node: zaml.Node) {\n    const { editingIndex, inlineError } = this.state;\n    const labels = [...node.labels, ''];\n    return (\n      <div className=\"label-editor\">\n        <table>\n          <tbody>\n          {labels.map((label, i) => (\n            <tr\n              key={label}\n              className={classNames({ error: i === editingIndex && inlineError })}\n            >\n              <td className=\"marker\">{label || i === editingIndex ? '#': ''}</td>\n              {i === editingIndex ?\n                <td>\n                  <input\n                    ref={ref => this.editingElement = ref}\n                    defaultValue={label}\n                    onBlur={(event: React.FocusEvent<HTMLInputElement>) => {\n                      this.handleLabelUpdate(event.currentTarget.value);\n                    }}\n                    onKeyDown={(event: React.KeyboardEvent<HTMLInputElement>) => {\n                      if (event.key === 'Enter') {\n                        this.handleLabelUpdate(event.currentTarget.value);\n                      } else if (event.key === 'Escape') {\n                        this.cancelLabelEditing();\n                      }\n                    }}\n                  />\n                </td>\n              :\n                <td\n                  className=\"editable\"\n                  onClick={() => this.handleLabelEdit(i)}\n                >\n                  {label}\n                </td>\n              }\n            </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderAttributeEditor(node: zaml.Node, props: KeyValueMap) {\n    const keys = Object.keys(props).sort();\n    return (\n      <div className=\"attribute-editor\">\n        <table>\n          <tbody>\n            {keys.map(key => (\n              <tr key={key}>\n                <th>{key}</th>\n                <td>{this.renderValue(props[key])}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  render() {\n    const { node } = this.props;\n    const { selectedTab } = this.state;\n    return (\n      <div className=\"zaml-prop-editor\">\n        <TabView\n          tabs={tabs}\n          selectedTab={selectedTab}\n          onTabChange={(tab: string) => this.setState({ selectedTab: tab })}\n        >\n          {this.renderTabContent()}\n        </TabView>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport './TabView.scss';\n\ninterface Props {\n  tabs: string[];\n  selectedTab: string;\n  onTabChange: (tab: string) => void;\n}\n\nexport default class TabView extends React.Component<Props> {\n\n  render() {\n    const { tabs, selectedTab, onTabChange, children } = this.props\n    return (\n      <div className=\"tab-view\">\n        <ul className=\"tabs\">\n          {tabs.map(tab => (\n            <li\n              key={tab}\n              className={classNames('tab', { selected: tab === selectedTab })}\n              onClick={() => onTabChange(tab)}\n            >\n              <span className=\"label\">{tab}</span>\n            </li>\n          ))}\n        </ul>\n        <div className=\"content\">\n          {children}\n        </div>\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport TreeNode, { NodePart } from './TreeNode';\nimport TreePath from './TreePath';\nimport TreeToolbar from './TreeToolbar';\nimport TreePropEditor from './TreePropEditor';\nimport './TreeView.scss';\n\ninterface Props {\n  root?: zaml.Node;\n  selectedNode?: zaml.Node;\n  onSelect: (node: zaml.Node) => void;\n  onHover: (node?: zaml.Node) => void;\n}\n\ninterface State {\n  selectedPart: NodePart,\n  expandedNodes: string[];\n}\n\nconst nil = () => {}\n\nexport default class TreeView extends React.Component<Props, State> {\n\n  static propTypes = {\n    node: PropTypes.shape({})\n  }\n\n  static defaultProps: Props = {\n    onSelect: nil,\n    onHover: nil,\n  }\n\n  state = {\n    selectedPart: NodePart.Header,\n    expandedNodes: [],\n  };\n\n  handleExpansionChange(node: zaml.Node, expanded: boolean) {\n    const { selectedNode } = this.props;\n    const { expandedNodes } = this.state;\n    if (selectedNode === node) {\n      this.setState({\n        selectedPart: expanded ? NodePart.Header : NodePart.Whole,\n      });\n    }\n    if (expanded && !_.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: [...expandedNodes, node.id],\n      });\n    } else if (!expanded && _.includes(expandedNodes, node.id)) {\n      this.setState({\n        expandedNodes: _.without(expandedNodes, node.id),\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    const { selectedNode } = nextProps;\n    if (selectedNode && selectedNode !== this.props.selectedNode) {\n      const { expandedNodes } = this.state;\n      const nodeIds = selectedNode.path.map(n => n.id);\n      this.setState({\n        expandedNodes: _.union(expandedNodes, nodeIds),\n      });\n    }\n  }\n\n  render() {\n    const { root: node, selectedNode, onSelect, onHover } = this.props;\n    const { expandedNodes, selectedPart } = this.state;\n    return (\n      <div className=\"zaml-tree-view\">\n        <SplitPane\n          split=\"horizontal\"\n          defaultSize=\"60%\"\n          minSize={200}\n        >\n          <div className=\"tree-container\">\n            <TreeToolbar />\n            <div className=\"tree\">\n              <TreeNode\n                node={node}\n                selectedNode={selectedNode}\n                selectedPart={selectedPart}\n                expandedNodes={expandedNodes}\n                onSelect={onSelect}\n                onSelectPart={p => this.setState({ selectedPart: p })}\n                onMouseEnter={onHover}\n                onMouseOut={() => onHover()}\n                onExpansionChange={(n: zaml.Node, expanded: boolean) => this.handleExpansionChange(n, expanded)}\n              />\n            </div>\n            <TreePath\n              selectedNode={selectedNode}\n              onSelect={onSelect}\n            />\n          </div>\n          <TreePropEditor\n            node={selectedNode}\n          />\n        </SplitPane>\n      </div>\n    )\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport PropTypes, { node } from 'prop-types';\nimport * as zaml from '@zaml/parser';\nimport SplitPane from 'react-split-pane';\nimport Pane from './Pane';\nimport SourceEditor from '../SourceEditor/SourceEditor';\nimport VisualEditor from '../VisualEditor/VisualEditor';\nimport '@blueprintjs/core/lib/css/blueprint.css';\nimport 'normalize.css/normalize.css';\nimport './Editor.scss';\nimport { ReactComponent as Logo } from './logo.svg';\nimport TreeView from '../TreeView/TreeView';\n\nconst { Node, NodeType } = zaml;\n\ninterface Props {\n  defaultSource: string;\n  className: string;\n  onChange: (value: string) => void;\n}\n\ninterface State {\n  source: string\n  root: zaml.Node;\n  sourcePaneHeight: number;\n  selectedNode?: zaml.Node;\n  hoveredNode?: zaml.Node;\n}\n\nconst parse = (source: string) => {\n  let node = Node.create(NodeType.ROOT);\n  try {\n    node = zaml.parse(source);\n  } catch(err) {\n    if (err instanceof zaml.ParseError) {\n      const message = `\n        [ParseError]{ERROR.TYPE}: {#MESSAGE ${err.message}}\n\n        #SOURCE\n        content\n\n        from {#POS.START ${err.from.ln}:${err.from.col}} to {#POS.END ${err.to.ln}:${err.to.col}}\n      `;\n      node = zaml.parse(message);\n      const sourceBlock = node.querySelector('#SOURCE');\n      console.dir(err);\n      const { text } = err.from.line;\n      if (!sourceBlock) return node;\n      const sourceText = sourceBlock.findOneBy({type: NodeType.TEXT});\n      if (!sourceText) return node;\n      sourceText.content = `${text} `;\n      sourceText.createEntitiesFromText([{\n        type: 'ERROR',\n        start: err.from.col - 1,\n        end: err.to.col - 1,\n      }]);\n    } else {\n      node = zaml.parse(`Error: [${err.message}]{MESSAGE}`);\n      console.error(err);\n    }\n  }\n  return node;\n}\n\nexport default class Editor extends React.Component<Props, State> {\n\n  static propTypes = {\n    defaultSource: PropTypes.string,\n    onChange: PropTypes.func,\n  }\n\n  static defaultProps: Props = {\n    defaultSource: '',\n    className: '',\n    onChange: () => {},\n  }\n\n  public preventSourceChange: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      source: props.defaultSource,\n      root: parse(props.defaultSource),\n      sourcePaneHeight: -1,\n    };\n    this.onResize = _.throttle(this.onResize.bind(this), 500);\n    this.preventSourceChange = false;\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.onResize, { passive: true });\n    this.onResize();\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n  }\n\n  componentWillUpdate(nextProps: Props, nextState: State) {\n    if (nextState.selectedNode !== this.state.selectedNode) {\n      console.log('selected node:', nextState.selectedNode);\n    }\n    if (nextState.root !== this.state.root) {\n      console.log('new node:', nextState.root);\n    }\n  }\n\n  onResize() {\n    const height = window.innerHeight - 60;\n    this.setState({\n      sourcePaneHeight: height,\n    });\n  }\n\n  handleSourceChange(source: string) {\n    if (this.preventSourceChange) return;\n    this.setState({\n      root: parse(source),\n    });\n  }\n\n  handleNodeChange(root?: zaml.Node, selected?: zaml.Node) {\n    if (!root) return;\n    this.preventSourceChange = true;\n    this.setState({\n      source: root.toSource({ simple: true }),\n      selectedNode: selected,\n    }, () => {\n      this.preventSourceChange = false;\n    });\n  }\n\n  render() {\n    const { source } = this.state;\n    const { root, sourcePaneHeight, selectedNode, hoveredNode } = this.state;\n    return (\n      <div className=\"zaml-editor\">\n        <header>\n          <a className=\"project-link\" href=\"https://github.com/nexushubs/zaml-lang/tree/master/packages/zaml-editor\"><Logo className=\"logo\" /> Editor</a>\n          <a className=\"github-link\" href=\"https://github.com/nexushubs/zaml-lang\">View on Github</a>\n        </header>\n        <section className=\"editor-panes\">\n          <SplitPane\n            split=\"vertical\"\n            defaultSize=\"33.33%\"\n            minSize={200}\n          >\n            <Pane title=\"Source\">\n              <SourceEditor\n                value={source}\n                height={sourcePaneHeight - 40}\n                onChange={(value: string) => this.handleSourceChange(value)}\n              />\n            </Pane>\n            <SplitPane split=\"vertical\" defaultSize=\"50%\">\n              <Pane title=\"Visual\">\n                <VisualEditor\n                  root={root}\n                  selectedNode={hoveredNode || selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onChange={(r?: zaml.Node, n?: zaml.Node) => this.handleNodeChange(r, n)}\n                />\n              </Pane>\n              <Pane title=\"AST\">\n                <TreeView\n                  root={root}\n                  selectedNode={selectedNode}\n                  onSelect={n => this.setState({ selectedNode: n })}\n                  onHover={n => this.setState({ hoveredNode: n })}\n                />\n              </Pane>\n            </SplitPane>\n          </SplitPane>\n        </section>\n      </div>\n    );\n  }\n}\n","export default \n`#\n[]{ORG}\n[345976348]{SOC}\n[]{PER}\n[D2806]{LOC}\n[]{PER}\n[230101197701018888]{ID}\n[13945018888]{MOBILE}\n---\n\n\n\n#. #\n{#. #. #. [37]{LOC}[]{QT}}{#. [105]{AREA}}{#.. [201911]{DATE}[20191231]{DATE}}{#.. []{MONEY value=100000}}\n\n#..\n\n\n#.. #...\n{#... []{DATE}}\n\n#... #.\n[]{DUE}[]{MONEY}\n\n#... #...\n\n\n#\n{#... []{DUE}[]{MONEY}}{#.. #. #. []{DUE}}\n\n{#. #\n  \n\n  #. #.. #.. #....\n  1. []{PERIOD}[1%]{RATE}\n\n  #. #... #.... #..\n  2. []{PERIOD}[100]{DATE}\n  \n}\n\n{#. #.\n  \n\n  #...\n  1. \n\n  #..\n  2. \n\n}\n\n# #.. #..\n\n`;\n","import React, { Component } from 'react';\nimport './App.scss';\nimport Editor from './Editor/Editor';\nimport contract from './sample/contract';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Editor defaultSource={contract} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROCESSING_TIMEOUT = exports.P_MARKER = exports.END_MARKERS = exports.START_MARKERS = exports.P_FULL_WIDTH_CHARACTER = exports.P_BOOLEAN_FALSE = exports.P_BOOLEAN_TRUE = exports.P_STRING_LITERAL_UNQUOTED_TESTER = exports.P_STRING_LITERAL_UNQUOTED = exports.P_STRING_LITERAL_QUOTED = exports.P_NUMBER_LITERAL = exports.P_NUMBER_START = exports.P_DATE_LITERAL = exports.T_STRING_START = exports.P_TAG_NAME = exports.P_ATTRIBUTE_LIST = exports.P_ATTRIBUTE_NAME = exports.P_ATTRIBUTE_ASSIGN = exports.P_LABEL_NAME = exports.P_LABEL_START = exports.P_LIST_SEPARATOR = exports.P_WHITE_SPACES_EXT = exports.P_WHITE_SPACE = exports.P_PARAGRAPH_BREAK = exports.P_SPACE_WRAPPED_LINE_BREAK = exports.P_LINE_BREAK = exports.P_ASSIGN_YAML = exports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = exports.T_METADATA_FAVORED_ASSIGN = exports.T_PARAGRAPH_BREAK = exports.T_LINE_BREAKS = exports.T_LINE_BREAK = exports.T_ASSIGN_YAML = exports.T_ASSIGN_XML = exports.T_TAG_END = exports.T_TAG_CLOSING = exports.T_TAG_START = exports.T_ENTITY_END = exports.T_ENTITY_START = exports.P_MULTIPLE_LINE_COMMENT = exports.T_SINGLE_LINE_COMMENT = exports.T_METADATA_MARKER = exports.T_TAB = exports.T_SPACE = exports.DEFAULT_INDENT_SPACES = exports.createPattern = exports.combinePatterns = void 0;\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar combinePatterns = function combinePatterns(list) {\n  return list.map(function (p) {\n    return _.isRegExp(p) ? p.source : _.escapeRegExp(p);\n  }).join('|');\n};\n\nexports.combinePatterns = combinePatterns;\n\nvar createPattern = function createPattern(source) {\n  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'g';\n  return new RegExp(source, flags);\n};\n\nexports.createPattern = createPattern;\nvar DEFAULT_INDENT_SPACES = 2;\nexports.DEFAULT_INDENT_SPACES = DEFAULT_INDENT_SPACES;\nvar T_SPACE = ' ';\nexports.T_SPACE = T_SPACE;\nvar T_TAB = '\\t';\nexports.T_TAB = T_TAB;\nvar T_METADATA_MARKER = \"---\";\nexports.T_METADATA_MARKER = T_METADATA_MARKER;\nvar T_SINGLE_LINE_COMMENT = '~';\nexports.T_SINGLE_LINE_COMMENT = T_SINGLE_LINE_COMMENT;\nvar P_MULTIPLE_LINE_COMMENT = '~{3,}';\nexports.P_MULTIPLE_LINE_COMMENT = P_MULTIPLE_LINE_COMMENT;\nvar T_ENTITY_START = '[';\nexports.T_ENTITY_START = T_ENTITY_START;\nvar T_ENTITY_END = ']';\nexports.T_ENTITY_END = T_ENTITY_END;\nvar T_TAG_START = '{';\nexports.T_TAG_START = T_TAG_START;\nvar T_TAG_CLOSING = '/';\nexports.T_TAG_CLOSING = T_TAG_CLOSING;\nvar T_TAG_END = '}';\nexports.T_TAG_END = T_TAG_END;\nvar T_ASSIGN_XML = '=';\nexports.T_ASSIGN_XML = T_ASSIGN_XML;\nvar T_ASSIGN_YAML = ':';\nexports.T_ASSIGN_YAML = T_ASSIGN_YAML;\nvar T_LINE_BREAK = '\\n';\nexports.T_LINE_BREAK = T_LINE_BREAK;\nvar T_LINE_BREAKS = '\\r\\n';\nexports.T_LINE_BREAKS = T_LINE_BREAKS;\nvar T_PARAGRAPH_BREAK = '\\n\\n';\nexports.T_PARAGRAPH_BREAK = T_PARAGRAPH_BREAK;\nvar T_METADATA_FAVORED_ASSIGN = T_ASSIGN_YAML;\nexports.T_METADATA_FAVORED_ASSIGN = T_METADATA_FAVORED_ASSIGN;\nvar T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_ASSIGN_XML;\nexports.T_TAG_ATTRIBUTE_FAVORED_ASSIGN = T_TAG_ATTRIBUTE_FAVORED_ASSIGN;\nvar P_ASSIGN_YAML = /[:]/;\nexports.P_ASSIGN_YAML = P_ASSIGN_YAML;\nvar P_LINE_BREAK = /\\r?\\n/g;\nexports.P_LINE_BREAK = P_LINE_BREAK;\nvar P_SPACE_WRAPPED_LINE_BREAK = /\\s*\\n\\s*/g;\nexports.P_SPACE_WRAPPED_LINE_BREAK = P_SPACE_WRAPPED_LINE_BREAK;\nvar P_PARAGRAPH_BREAK = createPattern(\"\".concat(P_LINE_BREAK.source, \"\\\\s*\").concat(P_LINE_BREAK.source));\nexports.P_PARAGRAPH_BREAK = P_PARAGRAPH_BREAK;\nvar P_WHITE_SPACE = /[ \\t]/g;\nexports.P_WHITE_SPACE = P_WHITE_SPACE;\nvar P_WHITE_SPACES_EXT = /[\\s\\r\\n]/g;\nexports.P_WHITE_SPACES_EXT = P_WHITE_SPACES_EXT;\nvar P_LIST_SEPARATOR = /[,]/g;\nexports.P_LIST_SEPARATOR = P_LIST_SEPARATOR;\nvar P_LABEL_START = /[#]/g;\nexports.P_LABEL_START = P_LABEL_START;\nvar P_LABEL_NAME = /(?:[A-Za-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\.0-9A-Z_a-z\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3005\\u3007\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])*/g;\nexports.P_LABEL_NAME = P_LABEL_NAME;\nvar P_ATTRIBUTE_ASSIGN = createPattern(\"[\".concat([T_ASSIGN_XML, T_ASSIGN_YAML].join(''), \"]\"), '');\nexports.P_ATTRIBUTE_ASSIGN = P_ATTRIBUTE_ASSIGN;\nvar P_ATTRIBUTE_NAME = createPattern(\"(?:\".concat(P_LABEL_NAME.source, \")(?=\").concat(combinePatterns([P_WHITE_SPACE, P_ATTRIBUTE_ASSIGN, T_TAG_END]), \")\"), 'gu');\nexports.P_ATTRIBUTE_NAME = P_ATTRIBUTE_NAME;\nvar P_ATTRIBUTE_LIST = createPattern(\"(\".concat(P_LABEL_NAME.source).concat(P_ATTRIBUTE_ASSIGN.source, \"|\").concat(P_LABEL_START.source).concat(P_LABEL_NAME.source, \")\"));\nexports.P_ATTRIBUTE_LIST = P_ATTRIBUTE_LIST;\nvar P_TAG_NAME = P_ATTRIBUTE_NAME;\nexports.P_TAG_NAME = P_TAG_NAME;\nvar T_STRING_START = '\"';\nexports.T_STRING_START = T_STRING_START;\nvar P_DATE_LITERAL = /\\d{4}-[01]\\d-[0-3]\\d(?:T[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))?/g;\nexports.P_DATE_LITERAL = P_DATE_LITERAL;\nvar P_NUMBER_START = /[\\d\\.]/;\nexports.P_NUMBER_START = P_NUMBER_START;\nvar P_NUMBER_LITERAL = /(\\d+|\\d*\\.\\d+|\\d+\\.\\d*)(e\\d+)?/g;\nexports.P_NUMBER_LITERAL = P_NUMBER_LITERAL;\nvar P_STRING_LITERAL_QUOTED = /\"([^\"\\\\]|\\\\\")*\"/g;\nexports.P_STRING_LITERAL_QUOTED = P_STRING_LITERAL_QUOTED;\nvar P_STRING_LITERAL_UNQUOTED = /[^\\s}\"'\\\\\\n]+/g;\nexports.P_STRING_LITERAL_UNQUOTED = P_STRING_LITERAL_UNQUOTED;\nvar P_STRING_LITERAL_UNQUOTED_TESTER = new RegExp(\"^\".concat(P_STRING_LITERAL_UNQUOTED.source, \"$\"));\nexports.P_STRING_LITERAL_UNQUOTED_TESTER = P_STRING_LITERAL_UNQUOTED_TESTER;\nvar P_BOOLEAN_TRUE = /(TRUE|True|true)/g;\nexports.P_BOOLEAN_TRUE = P_BOOLEAN_TRUE;\nvar P_BOOLEAN_FALSE = /(FALSE|False|false)/g;\nexports.P_BOOLEAN_FALSE = P_BOOLEAN_FALSE;\nvar P_FULL_WIDTH_CHARACTER = /(?:[\\xD7\\u2014\\u2026\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u3001\\u3002\\u3005\\u3007\\u300A-\\u300D\\u3010\\u3011\\u3021-\\u3029\\u3038-\\u303B\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFF01\\uFF03\\uFF05\\uFF06\\uFF08\\uFF09\\uFF0B-\\uFF0D\\uFF1A\\uFF1B\\uFF1D\\uFF1F\\uFF20\\uFFE5]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D])/g;\nexports.P_FULL_WIDTH_CHARACTER = P_FULL_WIDTH_CHARACTER;\nvar START_MARKERS = [T_TAG_START, T_ENTITY_START, P_LABEL_START];\nexports.START_MARKERS = START_MARKERS;\nvar END_MARKERS = [T_TAG_END, T_ENTITY_END];\nexports.END_MARKERS = END_MARKERS;\nvar P_MARKER = createPattern(\"(\".concat(combinePatterns([P_PARAGRAPH_BREAK].concat(START_MARKERS, [T_TAG_END, P_MULTIPLE_LINE_COMMENT, T_SINGLE_LINE_COMMENT])), \")\"));\nexports.P_MARKER = P_MARKER;\nvar PROCESSING_TIMEOUT = Infinity;\nexports.PROCESSING_TIMEOUT = PROCESSING_TIMEOUT;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = _find;\nexports.default = exports.WrappingTags = exports.BlockTags = exports.BlockNodeTypes = exports.NodeTypes = exports.NodeType = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _util = require(\"./util\");\n\nvar _2 = require(\".\");\n\nvar nanoid = require('nanoid');\n\nvar NodeType;\nexports.NodeType = NodeType;\n\n(function (NodeType) {\n  NodeType[\"FRAGMENT\"] = \"fragment\";\n  NodeType[\"ROOT\"] = \"root\";\n  NodeType[\"PARAGRAPH\"] = \"paragraph\";\n  NodeType[\"TAG\"] = \"tag\";\n  NodeType[\"ENTITY\"] = \"entity\";\n  NodeType[\"TEXT\"] = \"text\";\n  NodeType[\"COMMENT\"] = \"comment\";\n})(NodeType || (exports.NodeType = NodeType = {}));\n\nvar NodeTypes = _.values(NodeType);\n\nexports.NodeTypes = NodeTypes;\nvar BlockNodeTypes = [NodeType.ROOT, NodeType.PARAGRAPH];\nexports.BlockNodeTypes = BlockNodeTypes;\nvar BlockTags = ['BLOCK', 'QUOTE', 'SECTION', 'HEADER', 'FOOTER'];\nexports.BlockTags = BlockTags;\nvar WrappingTags = BlockTags.concat(['INLINE', 'NUM', 'HEADING']);\nexports.WrappingTags = WrappingTags;\n\nvar defaultFinderCallback = function defaultFinderCallback(node) {\n  return true;\n};\n\nfunction testNode(pattern, node) {\n  if (_.isFunction(pattern)) {\n    return pattern(node);\n  } else if (_.isString(pattern)) {\n    return node.is(pattern);\n  } else {\n    throw new TypeError('invalid finding pattern');\n  }\n}\n/**\n * Recursive node finder\n * @param node Node to find \n * @param pattern Searching pattern\n * @param Node List\n */\n\n\nfunction _find(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (testNode(pattern, node)) {\n    result.push(node);\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        _find(childNode, pattern, result);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive node finder\n * @param node \n * @param pattern \n */\n\n\nfunction _findOne(node) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFinderCallback;\n\n  if (testNode(pattern, node)) {\n    return node;\n  }\n\n  if (!_.isEmpty(node.children)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var childNode = _step2.value;\n\n        var result = _findOne(childNode, pattern);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    ;\n  }\n\n  return undefined;\n}\n\nfunction parseJson(json) {\n  var node = Node.create(json.type, json.name, {\n    attributes: parseJsonMap(json.attributes),\n    metadata: parseJsonMap(json.metadata),\n    content: json.content\n  });\n\n  if (json.children) {\n    _.each(json.children, function (childData) {\n      node.appendChild(parseJson(childData));\n    });\n  }\n\n  node.normalize();\n  return node;\n}\n/**\n * Map metadata & attributes to JSON\n * @param  map \n */\n\n\nfunction toJsonMap(map) {\n  if (_.isEmpty(map)) {\n    return undefined;\n  }\n\n  return _.mapValues(map, function (value) {\n    if (value instanceof Node) {\n      return value.toJSON();\n    }\n\n    return value;\n  });\n}\n\nfunction parseJsonMap(json) {\n  if (_.isEmpty(json)) {\n    return undefined;\n  }\n\n  return _.mapValues(json, function (value) {\n    if (_.isPlainObject(value)) {\n      return parseJson(value);\n    }\n\n    return (0, _util.parseValue)(value);\n  });\n}\n/**\n * AST node class\n * @class\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Node, null, [{\n    key: \"create\",\n\n    /**\n     * Create node, shortcut for constructor \n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n    value: function create(type, name, props) {\n      return new Node(type, name, props);\n    }\n    /**\n     * Create text tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(content, props) {\n      return new Node(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n        content: content\n      }));\n    }\n    /**\n     * Create block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(props) {\n      return new Node(NodeType.TAG, 'BLOCK', props);\n    }\n    /**\n     * Create inline block tag\n     * @param [props]\n     */\n\n  }, {\n    key: \"createInlineBlock\",\n    value: function createInlineBlock(props) {\n      return new Node(NodeType.TAG, 'INLINE', props);\n    }\n    /**\n     * Create node instance from ZAML source\n     * @param source \n     */\n\n  }, {\n    key: \"fromSource\",\n    value: function fromSource(source) {\n      return (0, _2.parse)(source);\n    }\n    /**\n     * Create node from json serializable data\n     * @param {object} json \n     * @returns {Node}\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return parseJson(json);\n    }\n    /**\n     * Creating fragment node\n     * @returns {Node}\n     */\n\n  }, {\n    key: \"createFragment\",\n    value: function createFragment() {\n      return Node.create(NodeType.FRAGMENT);\n    }\n    /**\n     * Check if a node is valid\n     * @param node \n     */\n\n  }, {\n    key: \"validNode\",\n    value: function validNode(node) {\n      if (!(node instanceof Node)) {\n        throw new TypeError('invalid node');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validParent\",\n    value: function validParent(node) {\n      if (!_.isArray(node.children)) {\n        throw new Error('node is not a valid parent');\n      }\n    }\n    /**\n     * Check if a node could be parent\n     * @param node \n     */\n\n  }, {\n    key: \"validChild\",\n    value: function validChild(node) {\n      if (!node.parent) {\n        throw new Error('node is not a valid child');\n      }\n    }\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(n1, n2) {\n      var path1 = n1.path;\n      var path2 = n2.path;\n      var ancestor;\n\n      while (path1.length > 0 && path2.length > 0) {\n        if (_.first(path1) !== _.first(path2)) {\n          break;\n        }\n\n        ancestor = path1.shift();\n        path2.shift();\n      }\n\n      if (!ancestor) {\n        return undefined;\n      }\n\n      return {\n        ancestor: ancestor,\n        paths: [path1, path2]\n      };\n    }\n    /**\n     * Create a block and move nodes or text within the range into it\n     * @param range \n     * @param props \n     */\n\n  }, {\n    key: \"createBlockByRange\",\n    value: function createBlockByRange(range, props) {\n      var startNode = range.startNode,\n          startOffset = range.startOffset,\n          endNode = range.endNode,\n          endOffset = range.endOffset;\n\n      if (!_.isNumber(startOffset) || !_.isNumber(endOffset)) {\n        throw new TypeError('range offset must be number');\n      }\n\n      if (!startNode.isText || !endNode.isText) {\n        throw new TypeError('range node must be text');\n      }\n\n      if (!startNode.content || !endNode.content) {\n        throw new Error('invalid text node');\n      }\n\n      if (startNode === endNode) {\n        if (startOffset < 0 || startOffset > startNode.content.length || endOffset < 0 || endOffset > startNode.content.length) {\n          throw new RangeError('sub text out of range');\n        }\n\n        if (!startNode.parent) {\n          throw new Error('can not create block on isolated text node');\n        }\n\n        var _parent = startNode.parent;\n        var fragment = Node.createFragment();\n        var block = Node.createInlineBlock((0, _objectSpread2.default)({}, props, {\n          text: startNode.content.substring(startOffset, endOffset)\n        }));\n\n        if (startOffset > 0) {\n          fragment.appendText(startNode.content.substring(0, startOffset));\n        }\n\n        fragment.appendChild(block);\n\n        if (endOffset < startNode.content.length) {\n          fragment.appendText(startNode.content.substring(endOffset));\n        }\n\n        _parent.insertBefore(fragment, startNode);\n\n        _parent.removeChild(startNode);\n\n        return block;\n      } else {\n        var result = Node.findCommonAncestor(startNode, endNode);\n        if (!result || !result.ancestor) return undefined;\n        var ancestor = result.ancestor,\n            _paths = result.paths;\n        var baseStartNode = _paths[0][0];\n        var baseEndNode = _paths[1][0];\n\n        var _startIndex = ancestor.children.indexOf(baseStartNode);\n\n        var _endIndex = ancestor.children.indexOf(baseEndNode);\n\n        var _sort = [_startIndex, _endIndex].sort(),\n            _sort2 = (0, _slicedToArray2.default)(_sort, 2),\n            startIndex = _sort2[0],\n            endIndex = _sort2[1];\n\n        if (_startIndex !== startIndex) {\n          var _ref = [baseEndNode, baseStartNode];\n          baseStartNode = _ref[0];\n          baseEndNode = _ref[1];\n        }\n\n        var _fragment = ancestor.extractNodes(startIndex, endIndex + 1);\n\n        var isStartSided = startNode.isSidedDescendantOf(baseStartNode, 'start') && startOffset === 0;\n        var isEndSided = endNode.isSidedDescendantOf(baseEndNode, 'end') && endOffset === endNode.content.length;\n        var foundBlock = ancestor.findOne(function (n) {\n          return n.isBlock;\n        });\n        var hasBlock = foundBlock && foundBlock !== ancestor;\n\n        if (!hasBlock && (_paths[0].length === 1 || isStartSided || _paths[1].length === 1 || isEndSided)) {\n          var inserting = Node.createFragment();\n          var startText = startNode.content;\n\n          if (startOffset > 0) {\n            baseStartNode.content = startText.substring(startOffset);\n            inserting.appendText(startText.substring(0, startOffset));\n          }\n\n          var _block = Node.createInlineBlock(props);\n\n          _block.appendChild(_fragment);\n\n          inserting.appendChild(_block);\n          var endText = endNode.content;\n\n          if (endOffset < endNode.content.length) {\n            baseEndNode.content = endText.substring(0, endOffset);\n            inserting.appendText(startText.substring(endOffset));\n          }\n\n          ancestor.insertAt(inserting, startIndex);\n          return _block;\n        } else {\n          var _block2 = Node.createBlock(props);\n\n          ancestor.insertAt(_block2, startIndex);\n\n          _block2.appendChild(_fragment);\n\n          return _block2;\n        }\n      }\n    }\n  }]);\n  /**\n   * @constructor\n   * @param type \n   * @param [name]\n   * @param [props]\n   */\n\n  function Node(type, name) {\n    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Node);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", '');\n    (0, _defineProperty2.default)(this, \"type\", void 0);\n    (0, _defineProperty2.default)(this, \"name\", void 0);\n    (0, _defineProperty2.default)(this, \"start\", -1);\n    (0, _defineProperty2.default)(this, \"end\", -1);\n    (0, _defineProperty2.default)(this, \"textStart\", -1);\n    (0, _defineProperty2.default)(this, \"textEnd\", -1);\n    (0, _defineProperty2.default)(this, \"states\", void 0);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"labels\", void 0);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"content\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", '');\n    (0, _defineProperty2.default)(this, \"children\", void 0);\n    var _props$source = props.source,\n        source = _props$source === void 0 ? '' : _props$source,\n        _props$start = props.start,\n        start = _props$start === void 0 ? -1 : _props$start,\n        _props$end = props.end,\n        end = _props$end === void 0 ? -1 : _props$end,\n        states = props.states,\n        _props$attributes = props.attributes,\n        attributes = _props$attributes === void 0 ? {} : _props$attributes,\n        _props$metadata = props.metadata,\n        metadata = _props$metadata === void 0 ? {} : _props$metadata,\n        _props$labels = props.labels,\n        labels = _props$labels === void 0 ? [] : _props$labels,\n        parent = props.parent,\n        _props$content = props.content,\n        content = _props$content === void 0 ? '' : _props$content,\n        _props$text = props.text,\n        text = _props$text === void 0 ? '' : _props$text;\n\n    if (type && !NodeTypes.includes(type)) {\n      throw new TypeError(\"invalid node type \".concat(type));\n    }\n\n    this.id = nanoid();\n    /**\n     * Parser states\n     * @type {Object<string,any>}\n     */\n\n    this.states = states || {};\n    /**\n     * @type {NodeType}\n     * @description Node type\n     */\n\n    this.type = type;\n    /**\n     * @type {string}\n     * @description Node name, for tag, entity\n     */\n\n    this.name = undefined;\n    /**\n     * @type {number}\n     * @description Start source position to root node\n     */\n\n    this.start = start;\n    /**\n     * @type {number}\n     * @description End source position to root node\n     */\n\n    this.end = end;\n    /**\n     * @type {number}\n     * @description Start text source position to root node\n     */\n\n    this.textStart = -1;\n    /**\n     * @type {number}\n     * @description End text source position to root node\n     */\n\n    this.textEnd = -1;\n    /**\n     * @private\n     * @type {Node}\n     * @description Parent node\n     */\n\n    this.parent = parent;\n    /**\n     * @private\n     * @type {string}\n     * @description Source code string, only for root node\n     */\n\n    this._source = undefined;\n    /**\n     * @type {string}\n     * @description Text content, only for text node\n     */\n\n    this.content = undefined;\n    /**\n     * @type {Node[]}\n     * @description Child nodes, only for block node\n     */\n\n    this.children = [];\n    /**\n     * @type {string[]}\n     * @description node labels\n     */\n\n    this.labels = [];\n    /**\n     * @type {Object.<string,any>}\n     * @description Attributes, for root, tag, entity node\n     */\n\n    this.attributes = {};\n    /**\n     * @type {Object.<string,any>}\n     * @description Block metadata\n     */\n\n    this.metadata = {};\n    /**\n     * @type {string[]}\n     * @description Node labels\n     */\n\n    this.labels = [];\n\n    if (type === NodeType.ROOT) {\n      this.start = 0;\n      this.end = source.length;\n      this._source = source;\n    }\n\n    if (text) {\n      this.appendText(text);\n    }\n\n    if (BlockNodeTypes.includes(type) || [NodeType.ENTITY, NodeType.TAG, NodeType.FRAGMENT].includes(type)) {\n      if (type !== NodeType.PARAGRAPH) {\n        this.name = name;\n        this.attributes = attributes;\n        this.metadata = metadata;\n        this.labels = labels;\n      }\n    } else if (type === NodeType.TEXT || type === NodeType.COMMENT) {\n      this.content = content;\n    }\n  }\n  /**\n   * Get a short descriptor to identify node's type and basic information\n   */\n\n\n  (0, _createClass2.default)(Node, [{\n    key: \"getRootNode\",\n\n    /**\n     * Property indicates if the root is root (which has no children)\n     */\n    value: function getRootNode() {\n      var node = this;\n\n      while (node.parent) {\n        node = node.parent;\n      }\n\n      if (node === this) {\n        return undefined;\n      }\n\n      return node;\n    }\n    /**\n     * Check node match the expression\n     * @example\n     * `BLOCK`: tag\n     * `@LOC`: entity\n     * @param expression \n     */\n\n  }, {\n    key: \"is\",\n    value: function is(expression) {\n      if (!_.isString(expression)) {\n        return false;\n      }\n\n      expression = expression.toUpperCase();\n\n      if (/^[A-Z]/.test(expression)) {\n        return this.type === NodeType.TAG && this.name === expression;\n      } else if (/^#/.test(expression)) {\n        return this.type === NodeType.TAG && this.labels.includes(expression.substr(1));\n      } else if (/^@[A-Z]/.test(expression)) {\n        return this.type === NodeType.ENTITY && this.name === expression.substr(1);\n      }\n\n      return false;\n    }\n    /**\n     * whether a node is a descendant of a given node\n     * @param node \n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      Node.validNode(node);\n\n      while (node) {\n        if (node === this) {\n          return true;\n        }\n\n        if (!node.parent) {\n          return false;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Get a list of ancestors\n     */\n\n  }, {\n    key: \"hasChild\",\n\n    /**\n     * Check if this node has any children\n     */\n    value: function hasChild() {\n      return this.children.length > 0;\n    }\n    /**\n     * Check if this node is the only child of its parent\n     */\n\n  }, {\n    key: \"isOnlyDescendantOf\",\n\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n    value: function isOnlyDescendantOf(ancestor) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length !== 1) {\n          return false;\n        }\n\n        node = node.children[0];\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n\n  }, {\n    key: \"isSidedDescendantOf\",\n    value: function isSidedDescendantOf(ancestor, side) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        node = side === 'start' ? node.firstChild : node.lastChild;\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if the node is only descendant of another node;\n     * @param ancestor \n     */\n\n  }, {\n    key: \"isRightAlignedDescendantOf\",\n    value: function isRightAlignedDescendantOf(ancestor) {\n      var node = ancestor;\n\n      while (node) {\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        node = node.lastChild;\n\n        if (node === this) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Create a child node\n     * @param type \n     * @param [name]\n     * @param [props]\n     */\n\n  }, {\n    key: \"createChild\",\n    value: function createChild(type, name, props) {\n      var node = new Node(type, name, props);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Insert a node at the beginning of the children\n     * @param node \n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(node) {\n      return this.insertAt(node, 0);\n    }\n    /**\n     * Append a node to children list\n     * @param node \n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.insertAt(node, Infinity);\n    }\n    /**\n     * Append text node child\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = this.content || '';\n        this.content += text;\n        return this;\n      } else {\n        if (this.lastChild && this.lastChild.isText) {\n          this.lastChild.content += text;\n        } else {\n          var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n            content: text\n          }));\n          this.appendChild(child);\n        }\n      }\n    }\n    /**\n     * Add text node child at the beginning\n     * @param text \n     * @param [props] \n     */\n\n  }, {\n    key: \"prependText\",\n    value: function prependText(text, props) {\n      if (this.type === NodeType.TEXT) {\n        this.content = \"\".concat(text).concat(this.content || '');\n        return this;\n      } else {\n        var child = Node.create(NodeType.TEXT, undefined, (0, _objectSpread2.default)({}, props, {\n          content: text\n        }));\n        this.prependChild(child);\n      }\n    }\n    /**\n     * Remove one child\n     * @param node\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      _.pull(this.children, child);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Remove one child by index\n     * @param index\n     */\n\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var child = this.children[index];\n\n      _.pullAt(this.children, index);\n\n      child.parent = undefined;\n      return child;\n    }\n    /**\n     * Insert a node at specified position\n     * @param node \n     * @param index \n     */\n\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(node, index) {\n      var _this = this;\n\n      if (node.type === NodeType.FRAGMENT) {\n        var _this$children;\n\n        (_this$children = this.children).splice.apply(_this$children, [index, 0].concat((0, _toConsumableArray2.default)(node.children)));\n\n        node.children.forEach(function (child) {\n          child.parent = _this;\n        });\n        node.children = [];\n      } else {\n        this.children.splice(index, 0, node);\n\n        if (node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node.parent = this;\n      }\n\n      return node;\n    }\n    /**\n     * Insert a node before another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex);\n      return node;\n    }\n    /**\n     * Insert a node after another\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/insertAfter\n     * @param node Node to be inserted\n     * @param ref A child node to be referenced\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, ref) {\n      Node.validParent(this);\n      var refIndex = this.children.indexOf(ref);\n      this.insertAt(node, refIndex + 1);\n      return node;\n    }\n    /**\n     * Replace a child with another node, assuming current node is a parent\n     * @param newChild \n     * @param oldChild \n     * @returns The replaced child\n     */\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      Node.validParent(this);\n\n      if (newChild.contains(this)) {\n        throw new TypeError('the new child contains the parent');\n      }\n\n      if (oldChild.parent !== this) {\n        throw new TypeError('the old child is not a child of this node');\n      }\n\n      this.insertBefore(newChild, oldChild);\n      this.removeChild(oldChild);\n      return oldChild;\n    }\n    /**\n     * Replace current child node with another node, assuming current node is child\n     * @param node Node to be replaced with\n     */\n\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(node) {\n      Node.validChild(this);\n\n      if (!this.parent) {\n        throw new Error('can not replace isolated node');\n      }\n\n      this.parent.replaceChild(node, this);\n      return node;\n    }\n    /**\n     * Set single attribute value\n     * @param {string} key Attribute key\n     * @param {any} value Attribute value\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      _.set(this.attributes, key, value);\n    }\n    /**\n     * Set multiple attributes\n     * @param data Key-value pair\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(data) {\n      _.merge(this.attributes, data);\n    }\n    /**\n     * Get attribute value\n     * @param key \n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return _.get(this.attributes, key);\n    }\n    /**\n     * Check if a specified attribute key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return _.has(this.attributes, key);\n    }\n    /**\n     * Remove an attribute\n     * @param {string} key \n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      _.unset(this.attributes, key);\n    }\n    /**\n     * Remove all attributes\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes() {\n      this.attributes = {};\n    }\n    /**\n     * Set single metadata value\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(key, value) {\n      if (_.isObject(key)) {\n        _.merge(this.metadata, key);\n      } else {\n        _.set(this.metadata, key, value);\n      }\n    }\n    /**\n     * Get metadata value\n     * @param key \n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(key) {\n      return _.get(this.metadata, key);\n    }\n    /**\n     * Remove a metadata\n     * @param key \n     */\n\n  }, {\n    key: \"removeMetadata\",\n    value: function removeMetadata(key) {\n      _.unset(this.metadata, key);\n    }\n    /**\n     * Remove all metadata\n     */\n\n  }, {\n    key: \"clearMetadata\",\n    value: function clearMetadata() {\n      this.metadata = {};\n    }\n    /**\n     * Check if a specified metadata key exists\n     * @param key \n     */\n\n  }, {\n    key: \"hasMetadata\",\n    value: function hasMetadata(key) {\n      return _.has(this.metadata, key);\n    }\n    /**\n     * Add label to node\n     * @param label \n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(label) {\n      if (!_.isString(label)) {\n        throw new TypeError('label must be string');\n      }\n\n      if (!this.labels.includes(label)) {\n        this.labels.push(label);\n      }\n    }\n    /**\n     * Check if the node has specified label\n     * @param label \n     */\n\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(label) {\n      return this.labels.includes(label);\n    }\n    /**\n     * Remove label\n     * @param label \n     */\n\n  }, {\n    key: \"removeLabel\",\n    value: function removeLabel(label) {\n      _.pull(this.labels, label);\n    }\n    /**\n     * Remove all labels\n     */\n\n  }, {\n    key: \"clearLabels\",\n    value: function clearLabels() {\n      this.labels = [];\n    }\n    /**\n     * Rebuild text and source position, in case modification has been applied to node\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var source = this.toSource();\n\n      if (this.isRoot) {\n        this._source = source;\n      }\n\n      this.toString();\n    }\n    /**\n     * Get node by id\n     * @param id \n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      return _findOne(this, function (node) {\n        return node.id === id;\n      });\n    }\n    /**\n     * Find matched descendants recursively\n     * @param selector Node selector object\n     * @param [one] Find the first matched node or a list of node\n     */\n\n  }, {\n    key: \"findBy\",\n    value: function findBy() {\n      var _this2 = this;\n\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var type = selector.type,\n          name = selector.name,\n          text = selector.text,\n          source = selector.source,\n          label = selector.label;\n      var finder = one ? _findOne : _find;\n      return finder(this, function (node) {\n        var match = true;\n\n        if (type) {\n          match = match && type === node.type;\n        }\n\n        if (name) {\n          match = match && name === node.name;\n        }\n\n        if (text && node.type === NodeType.TEXT && node.content) {\n          if (_.isRegExp(text)) {\n            match = match && !!text.match(node.content);\n          } else if (_.isString(text)) {\n            match = match && node.content.includes(text);\n          } else {\n            throw new TypeError('text filter should be RegExp or string');\n          }\n        }\n\n        if (source && node._source) {\n          if (_.isRegExp(source)) {\n            match = match && !!source.match(node._source);\n          } else if (_.isString(source)) {\n            match = match && node._source.includes(source);\n          } else {\n            throw new TypeError('source filter should be RegExp or string');\n          }\n        }\n\n        if (label) {\n          if (_.isArray(label)) {\n            match = match && _.intersection(_this2.labels, label).length > 0;\n          } else {\n            match = match && _this2.labels.includes(label);\n          }\n        }\n\n        return match;\n      });\n      ;\n    }\n    /**\n     * Find nodes by selector recursively and return the first one\n     * @param selector \n     */\n\n  }, {\n    key: \"findOneBy\",\n    value: function findOneBy() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.findBy(selector, true);\n    }\n    /**\n     * Find matched text node by text source range\n     * @param start \n     * @param end \n     */\n\n  }, {\n    key: \"findTextByRange\",\n    value: function findTextByRange(start, end) {\n      if (this.textStart === undefined || this.textEnd === undefined) {\n        return undefined;\n      }\n\n      if (this.textStart <= start && this.textEnd >= end) {\n        if (this.type === NodeType.TEXT) {\n          return this;\n        } else if (this.hasChild()) {\n          for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            var match = child.findTextByRange(start, end);\n\n            if (match) {\n              return match;\n            }\n          }\n\n          ;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Find matched children recursively by callback\n     * @param callback\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback) {\n      return _find(this, callback);\n    }\n    /**\n     * Find matched children recursively and return the first one\n     * @param callback\n     */\n\n  }, {\n    key: \"findOne\",\n    value: function findOne(callback) {\n      return _findOne(this, callback);\n    }\n    /**\n     * Find all nodes by selector, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return _find(this, selector);\n    }\n    /**\n     * Find nodes by selector and return the first one, compared by is()\n     * @param selector \n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return _findOne(this, selector);\n    }\n    /**\n     * Merge neighbor text nodes\n     */\n\n  }, {\n    key: \"mergeText\",\n    value: function mergeText() {\n      var _this3 = this;\n\n      var stack = [];\n      var childLength = this.children.length;\n      this.children.forEach(function (child, i) {\n        if (child.isText) {\n          stack.push(child);\n        }\n\n        if (!child.isText || i === childLength - 1) {\n          if (stack.length > 1) {\n            var merged = stack.map(function (child) {\n              return child.content;\n            }).join('');\n            var textNode = Node.createText(merged);\n\n            _this3.insertBefore(textNode, stack[0]);\n\n            var n;\n\n            while (n = stack.shift()) {\n              _this3.removeChild(n);\n            }\n          }\n\n          stack = [];\n        }\n      });\n    }\n  }, {\n    key: \"extractNodes\",\n    value: function extractNodes(startIndex, endIndex) {\n      var fragment = Node.createFragment();\n\n      if (startIndex < 0 || startIndex >= this.children.length || endIndex < 0 || endIndex > this.children.length) {\n        throw new RangeError('invalid range of children');\n      }\n\n      var nodes = this.children.slice(startIndex, endIndex);\n      nodes.forEach(function (child) {\n        fragment.appendChild(child);\n      });\n      return fragment;\n    }\n    /**\n     * Remove a element and move its children to its parent\n     */\n\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      if (!this.parent) {\n        return;\n      }\n\n      var parent = this.parent;\n      var fragment = this.extractNodes(0, this.children.length);\n      parent.insertBefore(fragment, this);\n      parent.removeChild(this);\n      parent.mergeText();\n      return parent;\n    }\n    /**\n     * Process text node in current node and parse entities\n     */\n\n  }, {\n    key: \"createEntities\",\n    value: function createEntities(items) {\n      var entityNodes = [];\n\n      if (this.type !== NodeType.TEXT) {\n        console.warn('extractEntity() should exec only on text node');\n      }\n\n      if (!this.content || _.isEmpty(items)) {\n        return entityNodes;\n      }\n\n      var text = this.content;\n      items = _.sortBy(items, ['start']);\n      var fragment = Node.createFragment();\n      var lastPos = 0;\n      items.forEach(function (item) {\n        if (item.start >= item.end || item.start < lastPos) {\n          return;\n        }\n\n        if (item.start > lastPos) {\n          fragment.appendText(text.substring(lastPos, item.start));\n        }\n\n        var entityNode = fragment.createChild(NodeType.ENTITY, item.type, {\n          attributes: item.data\n        });\n        entityNode.appendText(text.substring(item.start, item.end));\n        entityNodes.push(entityNode);\n        lastPos = item.end;\n      });\n\n      if (lastPos < text.length) {\n        fragment.appendText(text.substr(lastPos));\n      }\n\n      this.replaceWith(fragment);\n      return entityNodes;\n    }\n    /**\n     * Create entity nodes based on text source position\n     * @param {Array.<{start:number,end:number,type:string,data:any}>} entities \n     */\n\n  }, {\n    key: \"createEntitiesFromText\",\n    value: function createEntitiesFromText(entities) {\n      var _this4 = this;\n\n      this.toString();\n      var cache = new Map();\n\n      _.each(entities, function (item) {\n        var textNode = _this4.findTextByRange(item.start, item.end);\n\n        if (textNode === undefined) {\n          return;\n        }\n\n        if (cache.has(textNode)) {\n          cache.get(textNode).push(item);\n        } else {\n          cache.set(textNode, [item]);\n        }\n      });\n\n      cache.forEach(function (items, textNode) {\n        textNode.createEntities(items.map(function (item) {\n          return (0, _objectSpread2.default)({}, item, {\n            start: item.start - (textNode.textStart || 0),\n            end: item.end - (textNode.textStart || 0)\n          });\n        }));\n      });\n    }\n    /**\n     * Extract entities from text node\n     */\n\n  }, {\n    key: \"extractEntities\",\n    value: function () {\n      var _extractEntities = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(extractor) {\n        var nodeList, textList, result;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nodeList = this.find(function (node) {\n                  return node.type === NodeType.TEXT && !!node.parent && node.parent.type !== NodeType.ENTITY && !!node.content;\n                });\n                textList = nodeList.map(function (node) {\n                  return node.content;\n                });\n\n                if (!_.isFunction(extractor)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                result = textList.map(function (text) {\n                  return extractor(text);\n                });\n                _context.next = 13;\n                break;\n\n              case 6:\n                if (!_.isFunction(extractor.extract)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 9;\n                return extractor.extract(textList);\n\n              case 9:\n                result = _context.sent;\n                _context.next = 13;\n                break;\n\n              case 12:\n                throw new TypeError('invalid extractor');\n\n              case 13:\n                nodeList.forEach(function (node, i) {\n                  var items = result[i];\n\n                  if (!_.isArray(items)) {\n                    throw new Error('invalid extraction result');\n                  }\n\n                  node.createEntities(items);\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function extractEntities(_x) {\n        return _extractEntities.apply(this, arguments);\n      };\n    }()\n    /**\n     * Remove wrapping entity and put text back\n     */\n\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity() {\n      if (this.type !== NodeType.ENTITY || !this.firstChild || this.firstChild.type !== NodeType.TEXT) {\n        throw new Error('invalid entity');\n      }\n\n      ;\n\n      if (!this.parent) {\n        throw new Error('can not remove isolated entity');\n      }\n\n      var text = this.firstChild.content || '';\n      var textNode;\n      var parent = this.parent,\n          previousSibling = this.previousSibling,\n          nextSibling = this.nextSibling;\n\n      if (previousSibling && previousSibling.isText) {\n        textNode = previousSibling;\n      }\n\n      if (textNode) {\n        textNode.appendText(text);\n      } else {\n        textNode = Node.create(NodeType.TEXT, undefined, {\n          content: text\n        });\n        parent.insertBefore(textNode, this);\n      }\n\n      if (nextSibling && nextSibling.isText) {\n        textNode.appendText(nextSibling.content || '');\n        parent.removeChild(nextSibling);\n      }\n\n      parent.removeChild(this);\n      return textNode;\n    }\n    /**\n     * Build plain text of the node (stripping tags & entities)\n     * @param [options]\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      return (0, _util.stringify)(this, options);\n    }\n    /**\n     * Build source code of the node\n     * @param [options]\n     */\n\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return (0, _util.stringify)(this, (0, _objectSpread2.default)({}, options, {\n        toSource: true\n      }));\n    }\n    /**\n     * Convert node to JSON serializable object\n     * @param options \n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$position = options.position,\n          position = _options$position === void 0 ? false : _options$position,\n          _options$textPosition = options.textPosition,\n          textPosition = _options$textPosition === void 0 ? false : _options$textPosition;\n      return _.omitBy({\n        type: this.type,\n        name: this.name,\n        content: this.content,\n        attributes: toJsonMap(this.attributes),\n        metadata: toJsonMap(this.metadata),\n        labels: this.labels.length ? this.labels : undefined,\n        position: position ? {\n          start: this.start,\n          end: this.end\n        } : undefined,\n        textPosition: textPosition ? {\n          start: this.textStart,\n          end: this.textEnd\n        } : undefined,\n        children: _.isEmpty(this.children) ? undefined : this.children.map(function (child) {\n          return child.toJSON(options);\n        })\n      }, _.isUndefined);\n    }\n  }, {\n    key: \"descriptor\",\n    get: function get() {\n      switch (this.type) {\n        case NodeType.ENTITY:\n          return \"[\".concat(this.name, \"]\");\n\n        case NodeType.TAG:\n          return \"{\".concat(this.name, \"}\");\n\n        case NodeType.TEXT:\n          return \"(text)\";\n\n        default:\n          return this.type;\n      }\n    }\n    /**\n     * Check if the node is root\n     */\n\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.type === NodeType.ROOT;\n    }\n    /**\n     * Check if the node is tag\n     */\n\n  }, {\n    key: \"isTag\",\n    get: function get() {\n      return this.type === NodeType.TAG;\n    }\n    /**\n     * Check if the node is entity\n     */\n\n  }, {\n    key: \"isEntity\",\n    get: function get() {\n      return this.type === NodeType.ENTITY;\n    }\n    /**\n     * Check if the node is text\n     */\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type === NodeType.TEXT;\n    }\n    /**\n     * Check if the node is text and not wrapping by entity\n     */\n\n  }, {\n    key: \"isPlainText\",\n    get: function get() {\n      return this.type === NodeType.TEXT && (!this.parent || this.parent.type !== NodeType.ENTITY);\n    }\n    /**\n     * Check if the node is wrapping tag\n     */\n\n  }, {\n    key: \"isWrappingTag\",\n    get: function get() {\n      return this.isTag && WrappingTags.includes(this.name);\n    }\n    /**\n     * Check if the node is block tag\n     */\n\n  }, {\n    key: \"isBlockTag\",\n    get: function get() {\n      return this.isTag && BlockTags.includes(this.name);\n    }\n    /**\n     * Check if the node is simple block or inline block\n     */\n\n  }, {\n    key: \"isSimpleTag\",\n    get: function get() {\n      return this.isTag && ['BLOCK', 'INLINE'].includes(this.name);\n    }\n    /**\n     * Property indicates if the node is a block (wrapping other nodes)\n     */\n\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      var type = this.type,\n          name = this.name;\n      return BlockNodeTypes.includes(type) || this.isBlockTag;\n    }\n    /**\n     * If node is inline block\n     */\n\n  }, {\n    key: \"isInlineBlock\",\n    get: function get() {\n      return this.isTag && !this.isBlockTag;\n    }\n    /**\n     * Get parent node, alias for node.parent\n     */\n\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    }\n    /**\n     * Get child nodes, alias for node.children\n     */\n\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    }\n    /**\n     * Get source code of the node\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      if (this.type === NodeType.ROOT) {\n        return this._source || '';\n      }\n\n      var rootNode = this.getRootNode();\n\n      if (!rootNode) {\n        throw new Error('ROOT node not found');\n      }\n\n      return rootNode.source.substring(this.start || 0, this.end);\n    }\n    /**\n     * Get node inner text\n     */\n\n  }, {\n    key: \"innerText\",\n    get: function get() {\n      if (this.type === NodeType.TEXT) {\n        return this.content;\n      } else if (this.type === NodeType.ENTITY) {\n        var textNode = this.children[0];\n        return textNode ? textNode.content : '';\n      } else {\n        return this.toString();\n      }\n    }\n    /**\n     * Check if the node is the first child of its parent\n     */\n\n  }, {\n    key: \"isFirstChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.first(parent.children) === this;\n    }\n    /**\n     * Check if the node is the last child of its parent\n     */\n\n  }, {\n    key: \"isLastChild\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      return _.last(parent.children) === this;\n    }\n    /**\n     * Siblings from same parent\n     */\n\n  }, {\n    key: \"siblings\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (!parent) {\n        return [this];\n      }\n\n      return parent.children;\n    }\n    /**\n     * Get index of parent children\n     */\n\n  }, {\n    key: \"childIndex\",\n    get: function get() {\n      var siblings = this.siblings;\n      return siblings.indexOf(this);\n    }\n    /**\n     * Next sibling node\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex + 1] || undefined;\n    }\n    /**\n     * Previous sibling node\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      if (!this.parent) return undefined;\n      var childIndex = this.childIndex,\n          siblings = this.siblings;\n      return siblings[childIndex - 1] || undefined;\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      var list = [];\n      var node = this;\n\n      while (node) {\n        list.unshift(node);\n        node = node.parent;\n      }\n\n      return list;\n    }\n    /**\n     * Get the first child of current node\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.first(this.children);\n    }\n    /**\n     * Get the last child of current node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      Node.validParent(this);\n      return _.last(this.children);\n    }\n  }, {\n    key: \"isOnlyChild\",\n    get: function get() {\n      if (!this.parent) {\n        return false;\n      }\n\n      return this.parent.children.length === 1;\n    }\n  }]);\n  return Node;\n}();\n\n(0, _defineProperty2.default)(Node, \"Types\", NodeType);\nvar _default = Node;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TextLine\", {\n  enumerable: true,\n  get: function get() {\n    return _TextLine.default;\n  }\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextLine = _interopRequireDefault(require(\"./TextLine\"));\n\nvar _constants = require(\"./constants\"); // improved from https://github.com/codemirror/CodeMirror/blob/master/src/util/StringStream.js\n\n\nvar NOT_FOUND = -1;\nvar LINE_BREAKS = /\\r?\\n/g;\n/**\n * Stream like text string\n * @typicalname stream\n */\n\nvar TextStream =\n/*#__PURE__*/\nfunction () {\n  /** Current cursor position */\n\n  /** Original text */\n\n  /** Tab size */\n\n  /** Text lines */\n\n  /** Start position of each line */\n\n  /** Markers */\n\n  /** Cursor stack positions */\n\n  /** Last matched string of methods like eat() match() */\n  function TextStream(text) {\n    var tabSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    (0, _classCallCheck2.default)(this, TextStream);\n    (0, _defineProperty2.default)(this, \"pos\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"tabSize\", void 0);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"lineOffsetIndexes\", []);\n    (0, _defineProperty2.default)(this, \"markers\", void 0);\n    (0, _defineProperty2.default)(this, \"cursorStack\", void 0);\n    (0, _defineProperty2.default)(this, \"lastMatch\", '');\n    this.pos = 0;\n    /**\n     * @readonly\n     * @type {string}\n     * @description Original text\n     */\n\n    this.text = text;\n    /**\n     * @description Tab size\n     */\n\n    this.tabSize = tabSize;\n    /**\n     * @description Lines, separated by line breaks\n     */\n\n    this.lines = [];\n    /**\n     * @description Stream markers, used by `pushMarker()`, `popMarker()`, `setMarkerData()`\n     */\n\n    this.markers = [];\n    /**\n     * @description Cursor stack, used by `pushCursor()` and `popCursor`\n     */\n\n    this.cursorStack = [];\n    this.init();\n  }\n  /**\n   * Prepare line indexes\n   */\n\n\n  (0, _createClass2.default)(TextStream, [{\n    key: \"init\",\n    value: function init() {\n      var lines = [];\n      var matched;\n      var offset = 0;\n      var ln = 1;\n      LINE_BREAKS.lastIndex = 0;\n\n      do {\n        matched = LINE_BREAKS.exec(this.text);\n\n        if (matched) {\n          var length = matched.index - offset;\n\n          var _text = this.text.substr(offset, length);\n\n          lines.push(new _TextLine.default(lines, _text, ln, offset));\n          offset += length + matched[0].length;\n        } else {\n          var _length = this.text.length - offset; // process last line without line break symbol\n\n\n          if (_length > 0) {\n            var _text2 = this.text.substr(offset);\n\n            lines.push(new _TextLine.default(lines, _text2, ln, offset));\n          }\n        }\n\n        ln++;\n      } while (matched);\n\n      this.lines = lines;\n      this.lineOffsetIndexes = _.map(lines, 'offset');\n    }\n    /**\n     * Get line and column position of the cursor\n     * @param pos Cursor position of the text\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      var lineIndex = _.sortedLastIndex(this.lineOffsetIndexes, pos) - 1;\n      var line = this.lines[lineIndex];\n\n      if (!line) {\n        throw new Error('cursor position is invalid');\n      }\n\n      var ln = line.ln,\n          offset = line.offset;\n      var col = pos - offset + 1;\n      return {\n        ln: ln,\n        col: col,\n        pos: pos,\n        line: line\n      };\n    }\n    /**\n     * Check if cursor is at the start of a line\n     * @param [trimSpaces] Whether to trim starting spaces\n     */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition = this.getPosition(),\n          col = _this$getPosition.col,\n          line = _this$getPosition.line;\n\n      if (col - 1 === 0) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimStart = _.trimStart(line.text),\n          length = _$trimStart.length;\n\n      return col - 1 <= line.length - length;\n    }\n    /**\n     * Check if cursor is at the end of a line\n     * @param [trimSpaces] Whether to trim ending spaces\n     */\n\n  }, {\n    key: \"eol\",\n    value: function eol() {\n      var trimSpaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var _this$getPosition2 = this.getPosition(),\n          col = _this$getPosition2.col,\n          line = _this$getPosition2.line;\n\n      if (col - 1 === line.length) {\n        return true;\n      }\n\n      if (!trimSpaces) {\n        return false;\n      }\n\n      var _$trimEnd = _.trimEnd(line.text),\n          length = _$trimEnd.length;\n\n      return col - 1 >= length;\n    }\n    /**\n     * Check if cursor is at the end of whole text\n     * @param {number} [pos] \n     */\n\n  }, {\n    key: \"eof\",\n    value: function eof(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      return pos >= this.text.length;\n    }\n    /**\n     * Get one next char, but keep the cursor position (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.text.charAt(this.pos);\n    }\n    /**\n     * Get one next char, and move cursor forward (if available)\n     * @returns The next char\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.text.length) {\n        return this.text.charAt(this.pos++);\n      }\n\n      return '';\n    }\n    /**\n     * Consumes one char if the next char fitting the pattern\n     * @param pattern \n     * @returns The char been eaten\n     */\n\n  }, {\n    key: \"eat\",\n    value: function eat(pattern) {\n      var ch = this.text.charAt(this.pos) || '';\n      var ok;\n\n      if (_.isUndefined(ch)) {\n        ok = false;\n      } else if (_.isString(pattern)) {\n        ok = ch === pattern;\n      } else if (_.isRegExp(pattern)) {\n        pattern.lastIndex = 0;\n        ok = pattern.test(ch);\n      } else if (_.isFunction(pattern)) {\n        ok = pattern(ch);\n      }\n\n      if (ok) {\n        this.lastMatch = ch;\n        ++this.pos;\n        return ch;\n      }\n\n      return '';\n    }\n    /**\n     * Consumes chars while fitting the pattern\n     * @param match \n     * @returns Eaten characters\n     */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(pattern) {\n      var start = this.pos;\n      var chr;\n      var string = '';\n\n      do {\n        chr = this.eat(pattern);\n\n        if (chr) {\n          string += chr;\n        }\n      } while (chr && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes chars until the first char not fitting the pattern\n     * @param pattern char or pattern\n     * @returns eaten characters\n     */\n\n  }, {\n    key: \"eatUntil\",\n    value: function eatUntil(pattern) {\n      var start = this.pos;\n      var ch;\n      var string = '';\n\n      do {\n        ch = this.eat(pattern);\n\n        if (!ch) {\n          string += this.peek();\n          this.pos++;\n        } else {\n          this.pos--;\n        }\n      } while (!ch && !this.eof());\n\n      return string;\n    }\n    /**\n     * Consumes spaces\n     * @returns {boolean} If any space has been consumed\n     */\n\n  }, {\n    key: \"eatSpaces\",\n    value: function eatSpaces() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.text.charAt(this.pos))) {\n        this.pos++;\n      }\n\n      return this.pos > start;\n    }\n    /**\n     * Find position of matched text to the pattern\n     * @param pattern \n     * @param options\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var caseInsensitive = options.caseInsensitive;\n      var index = NOT_FOUND;\n      var length = 0;\n      var matched = '';\n\n      if (typeof pattern === 'string') {\n        if (caseInsensitive) {\n          pattern = new RegExp(_.escapeRegExp(pattern), 'i');\n        } else {\n          index = this.text.indexOf(pattern, this.pos);\n\n          if (index !== NOT_FOUND) {\n            matched = pattern;\n          }\n        }\n      }\n\n      if (pattern instanceof RegExp) {\n        pattern.lastIndex = this.pos;\n        var result = pattern.exec(this.text);\n\n        if (result) {\n          index = result.index;\n          matched = result[0];\n        } else {\n          index = NOT_FOUND;\n        }\n      }\n\n      var _matched = matched;\n      length = _matched.length;\n      return {\n        index: index,\n        length: length,\n        matched: matched\n      };\n    }\n    /**\n     * Read n chars after current cursor\n     * @param [n] Number of chars to read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var left = this.text.length - this.pos;\n\n      if (left <= 0) {\n        return '';\n      } else if (left < n) {\n        n = left;\n      }\n\n      var result = this.text.substr(this.pos, n);\n      this.pos += n;\n      return result;\n    }\n    /**\n     * Read to text or pattern\n     * @param pattern \n     * @param [options]\n     * @returns Sub-text after current cursor and before (or contains) matched text\n     */\n\n  }, {\n    key: \"readTo\",\n    value: function readTo(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$toEOL = options.toEOL,\n          toEOL = _options$toEOL === void 0 ? false : _options$toEOL,\n          _options$toEOF = options.toEOF,\n          toEOF = _options$toEOF === void 0 ? false : _options$toEOF,\n          _options$consume = options.consume,\n          consume = _options$consume === void 0 ? false : _options$consume,\n          _options$skipMatched = options.skipMatched,\n          skipMatched = _options$skipMatched === void 0 ? false : _options$skipMatched;\n      var start = this.pos;\n\n      var _this$search = this.search(pattern),\n          index = _this$search.index,\n          length = _this$search.length;\n\n      var match = '';\n      var end = -1;\n\n      if (toEOL) {\n        var _this$getPosition3 = this.getPosition(),\n            _line = _this$getPosition3.line;\n\n        end = _line.offset + _line.length;\n      } else if (toEOF) {\n        end = this.text.length;\n      }\n\n      if (index !== NOT_FOUND) {\n        if (toEOL || toEOF) {\n          if (index < end) {\n            end = index;\n          } else {\n            length = 0;\n          }\n        } else {\n          end = index;\n        }\n      }\n\n      if (end !== -1) {\n        this.pos = end;\n\n        if (consume) {\n          end += length;\n          this.pos = end;\n        } else if (skipMatched) {\n          this.pos += length;\n        }\n\n        match = this.text.substring(start, end);\n      }\n\n      this.lastMatch = match;\n      return match;\n    }\n    /**\n     * Read to pattern (contains the matched text)\n     * @param {} pattern Text to find or pattern\n     * @param {object} options Match options\n     * @returns {string} Sub-text after current cursor and until the end of matched text\n     */\n\n  }, {\n    key: \"readOver\",\n    value: function readOver(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        consume: true\n      }));\n    }\n    /**\n     * Read one line\n     * @returns {string} Text containing one line (not including line break)\n     */\n\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var _this$getPosition4 = this.getPosition(),\n          line = _this$getPosition4.line;\n\n      var nextLine = line.next();\n\n      if (this.eof()) {\n        return '';\n      }\n\n      if (nextLine) {\n        this.pos = nextLine.offset;\n        return line.text;\n      } else {\n        var length = line.offset + line.length - this.pos;\n        return this.read(length);\n      }\n    }\n    /**\n     * Move cursor to end of text\n     */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.text.length;\n    }\n    /**\n     * Skip to the beginning of matched text\n     * @param pattern\n     * @param options\n     */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, options);\n      return start !== this.pos;\n    }\n    /**\n     * Skip to the end of matched text\n     * @param pattern\n     */\n\n  }, {\n    key: \"skipOver\",\n    value: function skipOver(pattern, options) {\n      var start = this.pos;\n      this.readTo(pattern, (0, _objectSpread2.default)({}, options, {\n        skipMatched: true\n      }));\n      return start !== this.pos;\n    }\n    /**\n     * Move cursor back\n     * @param n Steps\n     */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.pos -= n;\n    }\n    /**\n     * Check if rest text begins with pattern\n     * @param pattern \n     * @param [options] \n     */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$consume2 = options.consume,\n          consume = _options$consume2 === void 0 ? true : _options$consume2,\n          caseInsensitive = options.caseInsensitive;\n\n      var _this$search2 = this.search(pattern, {\n        caseInsensitive: caseInsensitive\n      }),\n          index = _this$search2.index,\n          length = _this$search2.length,\n          matched = _this$search2.matched;\n\n      if (index !== this.pos) {\n        return '';\n      }\n\n      if (consume) {\n        this.pos += length;\n      }\n\n      this.lastMatch = matched;\n      return matched;\n    }\n    /**\n     * Reset the marker stack\n     */\n\n  }, {\n    key: \"resetMarker\",\n    value: function resetMarker() {\n      this.markers = [];\n    }\n    /**\n     * Add a marker to stack\n     * @param data\n     * @param start\n     */\n\n  }, {\n    key: \"pushMarker\",\n    value: function pushMarker(data, start) {\n      if (_.isUndefined(start)) {\n        start = this.pos;\n      }\n\n      this.markers.push({\n        data: data,\n        start: start\n      });\n    }\n    /**\n     * Set data for current marker\n     * @param data\n     */\n\n  }, {\n    key: \"setMarkerData\",\n    value: function setMarkerData(data) {\n      var marker = _.last(this.markers);\n\n      if (!marker) return;\n\n      _.extend(marker.data, data);\n    }\n    /**\n     * Get data of current markder\n     */\n\n  }, {\n    key: \"getMarkerData\",\n    value: function getMarkerData() {\n      var marker = _.last(this.markers);\n\n      if (!marker) return {};\n      return marker.data;\n    }\n    /**\n     * Return a combined structure of text and it's position according to the previously set start\n     * marker\n     * @param [data] Additional data\n     * @param [end] End marker, if not set, previous set value will be used\n     */\n\n  }, {\n    key: \"popMarker\",\n    value: function popMarker() {\n      var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!_.isPlainObject(_data)) {\n        throw new TypeError('invalid data parameter');\n      }\n\n      if (_.isUndefined(end)) {\n        end = this.pos;\n      }\n\n      var marker = this.markers.pop();\n\n      if (!marker) {\n        return undefined;\n      }\n\n      var data = marker.data,\n          start = marker.start;\n      return {\n        text: this.text.substring(marker.start || 0, end),\n        position: {\n          start: start,\n          end: end\n        },\n        data: (0, _objectSpread2.default)({}, data, _data)\n      };\n    }\n  }, {\n    key: \"findLine\",\n    value: function findLine(text) {\n      return _.find(this.lines, function (line) {\n        return _.trim(line.text) === text;\n      });\n    }\n    /**\n     * Push current cursor to cursor stack, if new position provided, set current cursor to it\n     * @param [pos] \n     */\n\n  }, {\n    key: \"pushCursor\",\n    value: function pushCursor(pos) {\n      if (_.isUndefined(pos)) {\n        pos = this.pos;\n      }\n\n      this.cursorStack.push(this.pos);\n      this.pos = pos;\n    }\n    /**\n     * Pop last from cursor stack and set it to current cursor\n     */\n\n  }, {\n    key: \"popCursor\",\n    value: function popCursor() {\n      if (this.cursorStack.length === 0) {\n        throw new Error('out of cursor stack!');\n      }\n\n      this.pos = this.cursorStack.pop();\n      return this.pos;\n    }\n    /**\n     * Debug a single line\n     * @param line \n     * @param numWidth \n     * @param col \n     */\n\n  }, {\n    key: \"debugLine\",\n    value: function debugLine(line, numWidth, col) {\n      var ln = line.ln,\n          text = line.text;\n\n      if (_.isUndefined(numWidth)) {\n        numWidth = (ln + '').length;\n      }\n\n      if (col) {\n        text = text.substring(0, col - 1) + _chalk.default.bgBlue(text.charAt(col - 1)) + text.substring(col);\n      }\n\n      console.log(\"\".concat(_chalk.default.blueBright(\"\".concat(col ? '>' : ' ', \" \").concat(_.padStart(ln + '', numWidth), \" |\")), \" \").concat(text));\n    }\n    /**\n     * Debug cursor column position\n     * @param text Text of the line\n     * @param col Cursor position\n     * @param numWidth fixed line number width\n     */\n\n  }, {\n    key: \"debugCursor\",\n    value: function debugCursor(text, col, numWidth) {\n      var pos = text.substr(0, col - 1).replace(_constants.P_FULL_WIDTH_CHARACTER, 'XX').length;\n      console.log(_chalk.default.blueBright(\"  \".concat(_.repeat(' ', numWidth), \" | \").concat(_.repeat(' ', pos), \"^ \").concat(col)));\n    }\n    /**\n     * Debug current position state, with previous and following lines set by range\n     * @param range \n     */\n\n  }, {\n    key: \"debugState\",\n    value: function debugState() {\n      var _this = this;\n\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$getPosition5 = this.getPosition(),\n          ln = _this$getPosition5.ln,\n          col = _this$getPosition5.col;\n\n      var lineIndex = ln - 1;\n\n      var lines = _.slice(this.lines, _.max([lineIndex - range, 0]), _.min([lineIndex + range + 1, this.lines.length]));\n\n      var numWidth = _.max(lines.map(function (l) {\n        return (l.ln + '').length;\n      }));\n\n      lines.forEach(function (line) {\n        var isCurrent = line.ln === ln;\n\n        _this.debugLine(line, numWidth, isCurrent ? col : 0);\n\n        if (isCurrent) {\n          _this.debugCursor(line.text, col, numWidth);\n        }\n      });\n      console.log();\n    }\n  }]);\n  return TextStream;\n}();\n\nvar _default = TextStream;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n\n  function ParseError(message, text, from, to) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"message\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"text\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"from\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"to\", void 0);\n    _this.message = message;\n    _this.text = text;\n    _this.from = from;\n    _this.to = to;\n    return _this;\n  }\n\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.default = ParseError;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ = _interopRequireWildcard(require(\"lodash\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _TextStream = _interopRequireDefault(require(\"./TextStream\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Node = _interopRequireWildcard(require(\"./Node\"));\n\nvar _constants = require(\"./constants\");\n\nvar State;\n\n(function (State) {\n  State[State[\"METADATA\"] = 0] = \"METADATA\";\n  State[State[\"NORMAL\"] = 1] = \"NORMAL\";\n  State[State[\"SINGLE_COMMENT\"] = 2] = \"SINGLE_COMMENT\";\n  State[State[\"MULTIPLE_COMMENT\"] = 3] = \"MULTIPLE_COMMENT\";\n  State[State[\"START\"] = 4] = \"START\";\n  State[State[\"TAG_START\"] = 5] = \"TAG_START\";\n  State[State[\"TAG_NAME\"] = 6] = \"TAG_NAME\";\n  State[State[\"ATTRIBUTE_LIST\"] = 7] = \"ATTRIBUTE_LIST\";\n  State[State[\"ATTRIBUTE_NAME\"] = 8] = \"ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_ASSIGN\"] = 9] = \"ATTRIBUTE_ASSIGN\";\n  State[State[\"ATTRIBUTE_VALUE\"] = 10] = \"ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_FINISH\"] = 11] = \"ATTRIBUTE_FINISH\";\n  State[State[\"TAG_END\"] = 12] = \"TAG_END\";\n  State[State[\"LABEL_START\"] = 13] = \"LABEL_START\";\n  State[State[\"ENTITY_START\"] = 14] = \"ENTITY_START\";\n  State[State[\"ENTITY_BODY\"] = 15] = \"ENTITY_BODY\";\n  State[State[\"ENTITY_END\"] = 16] = \"ENTITY_END\";\n  State[State[\"END\"] = 17] = \"END\";\n  State[State[\"FINISH\"] = 18] = \"FINISH\";\n})(State || (State = {}));\n\n;\nvar stateNames = ['METADATA', 'NORMAL', 'SINGLE_COMMENT', 'MULTIPLE_COMMENT', 'START', 'TAG_START', 'TAG_NAME', 'ATTRIBUTE_LIST', 'ATTRIBUTE_NAME', 'ATTRIBUTE_ASSIGN', 'ATTRIBUTE_VALUE', 'ATTRIBUTE_FINISH', 'TAG_END', 'LABEL_START', 'ENTITY_START', 'ENTITY_BODY', 'ENTITY_END', 'END', 'FINISH'];\n\nvar getStateName = function getStateName(state) {\n  return stateNames[state];\n};\n\nvar countLineBreaks = function countLineBreaks(text) {\n  var result = text.match(_constants.P_LINE_BREAK);\n  return result ? result.length : 0;\n};\n\n;\n/**\n * Tokenizer class\n * @class\n */\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  (0, _createClass2.default)(Tokenizer, null, [{\n    key: \"from\",\n    value: function from(text, options) {\n      return new Tokenizer(text, options);\n    }\n  }]);\n  /**\n   * @param text \n   * @param options Constructor options\n   */\n\n  function Tokenizer(text, options) {\n    (0, _classCallCheck2.default)(this, Tokenizer);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"stream\", void 0);\n    (0, _defineProperty2.default)(this, \"options\", void 0);\n    (0, _defineProperty2.default)(this, \"parsed\", void 0);\n    this.text = text;\n    this.stream = new _TextStream.default(text);\n    var defaultOptions = {\n      verbose: process && process.env.DEBUG === 'verbose'\n    };\n    this.options = _.defaults(options, defaultOptions);\n    this.parsed = false;\n  }\n\n  (0, _createClass2.default)(Tokenizer, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n    /**\n     * Process a text and parse to AST\n     * @returns Root node of parsed AST\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this = this;\n\n      var text = this.text,\n          stream = this.stream;\n      var timeStart = Date.now();\n      var state = State.METADATA;\n      var start = 0;\n      var lastState = 0;\n      var lastPos = -1;\n      var states = {\n        unwrapped: false,\n        inline: false,\n        embedded: false,\n        isClosing: false,\n        key: undefined,\n        value: undefined\n      };\n\n      var root = _Node.default.create(_Node.NodeType.ROOT, undefined, {\n        source: text\n      });\n\n      var nodeStack = [];\n      var node = root;\n\n      var getNodeString = function getNodeString(node) {\n        return \"\".concat(node.type).concat(node.name ? \":\".concat(node.name) : '');\n      };\n\n      var debugStack = function debugStack(lastNode) {\n        if (!_this.options.verbose) {\n          return;\n        }\n\n        var separator = ' > ';\n        var stack = nodeStack.concat([node]);\n        var list = stack.map(function (n, i) {\n          var text = getNodeString(n);\n\n          if (i === stack.length - 1) {\n            text = _chalk.default.cyanBright(text);\n          } else {\n            text = _chalk.default.green(text);\n          }\n\n          return text;\n        });\n        var result = list.join(_chalk.default.redBright(separator));\n\n        if (lastNode) {\n          result += _chalk.default.grey(\"\".concat(separator).concat(getNodeString(lastNode)));\n        }\n\n        return result;\n      };\n\n      var pushNode = function pushNode(n) {\n        if (node.start === -1) {\n          node.start = stream.pos;\n        }\n\n        nodeStack.push(node);\n        node = n;\n\n        _this.debug(\"push: \".concat(debugStack(), \"\\n\"));\n      };\n\n      var popNode = function popNode(error) {\n        var lastNode = node;\n        node.end = stream.pos;\n\n        if (node.start === node.end || node.type === _Node.NodeType.PARAGRAPH && !node.hasChild() && node.parent) {\n          node.parent.removeChild(node);\n        }\n\n        node = nodeStack.pop();\n\n        _this.debug(\"pop : \".concat(debugStack(lastNode), \"\\n\"));\n\n        if (!node) {\n          throw createError(error || 'unexpected closing node');\n        }\n      }; // replace wrapping paragraph with current block tag\n\n\n      var levelUpBlock = function levelUpBlock() {\n        if (node.parent && node.parent.type === _Node.NodeType.PARAGRAPH) {\n          var blockNode = node;\n          popNode();\n          node.removeChild(blockNode);\n          popNode();\n          node.appendChild(blockNode);\n          pushNode(blockNode);\n        }\n      };\n\n      var createError = function createError(message) {\n        var from;\n        var to;\n        from = stream.getPosition(lastPos);\n        to = stream.pos === lastPos ? stream.getPosition(lastPos + 1) : stream.getPosition();\n\n        _this.debug(\"error: '\".concat(message, \"' at \").concat(from.ln, \":\").concat(from.col));\n\n        _this.debug('current node:');\n\n        _this.debug(node.toJSON());\n\n        _this.debug('current parsing state:');\n\n        _this.debug(JSON.stringify(root, null, 2));\n\n        return new _ParseError.default(message, text, from, to);\n      };\n\n      while (state !== State.FINISH) {\n        // parse failure watcher\n        if (Date.now() - timeStart >= _constants.PROCESSING_TIMEOUT) {\n          this.debug('parsing timeout!');\n          state = State.FINISH;\n        }\n\n        if (state === lastState && lastPos === stream.pos) {\n          throw new Error('Parser fall into infinite loop!');\n        }\n\n        lastState = state;\n        lastPos = stream.pos;\n        this.debug(_chalk.default.magenta(\"# \".concat(getStateName(state), \", pos = \").concat(stream.pos)));\n\n        if (this.options.verbose) {\n          stream.debugState();\n        }\n\n        switch (state) {\n          case State.METADATA:\n            {\n              stream.eatWhile(_constants.P_WHITE_SPACES_EXT);\n\n              if (stream.match(_constants.T_METADATA_MARKER) || stream.match(_constants.P_ATTRIBUTE_LIST, {\n                consume: false\n              })) {\n                node.states.metadata = true;\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.NORMAL:\n            {\n              if (stream.sol(true) || stream.eol(true)) {\n                stream.eatWhile(_constants.P_WHITE_SPACE);\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK)) {\n                popNode();\n\n                if (node.states.unwrapped) {\n                  popNode();\n                }\n\n                break;\n              }\n\n              start = stream.pos;\n\n              if (node.type !== _Node.NodeType.PARAGRAPH && !node.isInlineBlock && stream.sol(true)) {\n                var child = node.createChild(_Node.NodeType.PARAGRAPH, undefined, {\n                  start: start\n                });\n                pushNode(child);\n              }\n\n              var originalText = stream.readTo(_constants.P_MARKER, {\n                toEOF: true\n              });\n              var _text = originalText;\n\n              if (_text) {\n                if (node.children.length === 0) {\n                  _text = _.trimStart(_text);\n                }\n\n                _text = _text.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, _constants.T_LINE_BREAK);\n                _text = _.trimEnd(_text, _constants.T_LINE_BREAKS);\n\n                if (_text) {\n                  node.appendText(_text, {\n                    start: start,\n                    end: stream.pos\n                  });\n                }\n              }\n\n              if (stream.match(_constants.P_PARAGRAPH_BREAK, {\n                consume: false\n              })) {\n                state = State.NORMAL;\n              } else {\n                state = State.START;\n              }\n\n              break;\n            }\n\n          case State.START:\n            {\n              start = stream.pos;\n              var ch = stream.eat(_constants.P_MARKER);\n              _constants.P_LABEL_START.lastIndex = 0;\n\n              if (ch === _constants.T_SINGLE_LINE_COMMENT) {\n                var rest = stream.eatWhile(_constants.T_SINGLE_LINE_COMMENT);\n\n                if (rest.length === 0) {\n                  state = State.SINGLE_COMMENT;\n                } else {\n                  state = State.MULTIPLE_COMMENT;\n                }\n              } else if (ch === _constants.T_TAG_START) {\n                state = State.TAG_START;\n              } else if (_constants.P_LABEL_START.test(ch)) {\n                states.unwrapped = true;\n                state = State.TAG_START;\n              } else if (ch === _constants.T_TAG_END) {\n                states.isClosing = true;\n                state = State.TAG_END;\n              } else if (ch === _constants.T_ENTITY_START) {\n                state = State.ENTITY_START;\n              } else if (stream.eof()) {\n                state = State.END;\n              } else {\n                throw createError('empty start');\n              }\n\n              break;\n            }\n\n          case State.SINGLE_COMMENT:\n          case State.MULTIPLE_COMMENT:\n            {\n              start = stream.pos;\n              var content = void 0;\n\n              if (state === State.SINGLE_COMMENT) {\n                content = stream.readTo(_constants.P_LINE_BREAK);\n              } else {\n                content = stream.readTo(_constants.P_MULTIPLE_LINE_COMMENT, {\n                  skipMatched: true\n                });\n              }\n\n              if (content) {\n                if (state === State.MULTIPLE_COMMENT) {\n                  content = content.replace(_constants.P_SPACE_WRAPPED_LINE_BREAK, '\\n');\n                }\n\n                content = _.trim(content);\n              }\n\n              if (content) {\n                node.createChild(_Node.NodeType.COMMENT, undefined, {\n                  start: start,\n                  end: stream.pos,\n                  content: content\n                });\n              }\n\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.TAG_START:\n            {\n              if (stream.eat(_constants.T_TAG_CLOSING)) {\n                states.isClosing = true;\n                state = State.TAG_NAME;\n              } else if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (node.type !== _Node.NodeType.ENTITY && (states.unwrapped || stream.eat(_constants.P_LABEL_START))) {\n                state = State.LABEL_START;\n              } else {\n                var _child = _Node.default.create(_Node.NodeType.TAG, '', {\n                  start: start\n                });\n\n                if (states.embedded) {\n                  _child.states.embedded = true;\n                  _child.states.metaKey = states.key;\n                  states.embedded = false;\n                } else {\n                  node.appendChild(_child);\n                }\n\n                pushNode(_child);\n                state = State.TAG_NAME;\n              }\n\n              if (state === State.NORMAL || state === State.LABEL_START) {\n                stream.pushCursor(start);\n                var tagName = stream.sol(true) ? 'BLOCK' : 'INLINE';\n                stream.popCursor();\n\n                if (node.type === _Node.NodeType.PARAGRAPH && tagName === 'BLOCK') {\n                  popNode();\n                }\n\n                var _child2 = node.createChild(_Node.NodeType.TAG, tagName, {\n                  start: start,\n                  states: {\n                    simpleBlock: true,\n                    unwrapped: states.unwrapped\n                  }\n                });\n\n                states.unwrapped = false;\n                pushNode(_child2);\n              }\n\n              break;\n            }\n\n          case State.TAG_NAME:\n            {\n              var name = stream.match(_constants.P_TAG_NAME);\n\n              if (!name) {\n                throw createError('expected tag name');\n              }\n\n              states.inline = name === 'INLINE';\n\n              if (states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  stream.pushCursor(start);\n                  popNode();\n                  stream.popCursor();\n                }\n\n                if (name !== node.name) {\n                  throw createError('unexpected closing tag');\n                }\n\n                var _ch = stream.eat(_constants.T_TAG_END);\n\n                if (!_ch) {\n                  throw createError('invalid closing tag');\n                }\n\n                if (!states.inline && !stream.eol()) {\n                  throw createError('closing block tag must take the whole line');\n                }\n\n                state = State.TAG_END;\n              } else {\n                node.name = name;\n\n                if (node.isWrappingTag) {\n                  stream.pushCursor(node.start || 0);\n\n                  if (node.name === 'BLOCK' && !stream.sol(true)) {\n                    throw createError('unexpected start of block inline');\n                  }\n\n                  stream.popCursor();\n\n                  if (node.isBlock) {\n                    levelUpBlock();\n                  }\n                }\n\n                state = State.ATTRIBUTE_LIST;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_LIST:\n            {\n              var spacePattern = node.states.simpleBlock || node.states.unwrapped ? _constants.P_WHITE_SPACE : _constants.P_WHITE_SPACES_EXT;\n              var spaces = stream.eatWhile(spacePattern);\n              var isParsingMetadata = node.states.metadata;\n\n              if (isParsingMetadata) {\n                var endOfFrontMatter = false;\n\n                if (stream.match(_constants.T_METADATA_MARKER)) {\n                  if (!stream.match(_constants.P_LINE_BREAK)) {\n                    throw createError('expected new line after metadata closed');\n                  }\n\n                  endOfFrontMatter = true;\n                }\n\n                var lineBreaks = countLineBreaks(spaces);\n\n                if (lineBreaks > 1) {\n                  endOfFrontMatter = true;\n                }\n\n                if (endOfFrontMatter) {\n                  state = State.NORMAL;\n                  node.states.metadata = false;\n                  break;\n                } // deal with simple block at the beginning\n\n\n                if (node.type === _Node.NodeType.ROOT && !stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                }) && lineBreaks === 1) {\n                  var _child3 = node.createChild(_Node.NodeType.TAG, 'BLOCK', {\n                    labels: node.labels,\n                    states: {\n                      unwrapped: true\n                    },\n                    metadata: node.metadata\n                  });\n\n                  node.clearLabels();\n                  node.clearMetadata();\n                  pushNode(_child3);\n                  state = State.NORMAL;\n                  break;\n                }\n              }\n\n              if (stream.match(_constants.P_LINE_BREAK)) {\n                state = State.NORMAL;\n              } else if (stream.eat(_constants.T_TAG_END)) {\n                state = State.TAG_END;\n              } else if (stream.match(_constants.P_LABEL_START)) {\n                state = State.LABEL_START;\n              } else {\n                if (!(spaces || isParsingMetadata) && this.stream.pos > 1) {\n                  if (_.isEmpty(node.attributes) && _constants.P_ATTRIBUTE_ASSIGN.test(stream.peek())) {\n                    states.key = node.name;\n                    node.name = 'BLOCK';\n                    node.states.simpleBlock = true;\n                    levelUpBlock();\n                    state = State.ATTRIBUTE_ASSIGN;\n                    break;\n                  } else {\n                    throw createError('expecting end of tag \"}\" or attribute list');\n                  }\n                }\n\n                state = State.ATTRIBUTE_NAME;\n\n                if (stream.match(_constants.P_ATTRIBUTE_LIST, {\n                  consume: false\n                })) {\n                  state = State.ATTRIBUTE_NAME;\n                } else {\n                  state = State.NORMAL;\n                }\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_NAME:\n            {\n              var _key = stream.match(_constants.P_ATTRIBUTE_NAME);\n\n              if (!_key) {\n                throw createError('expecting attribute name');\n              }\n\n              states.key = _key;\n              state = State.ATTRIBUTE_ASSIGN;\n              break;\n            }\n\n          case State.ATTRIBUTE_ASSIGN:\n            {\n              var _ch2 = stream.peek();\n\n              if (_ch2 === _constants.T_TAG_END) {\n                state = State.ATTRIBUTE_FINISH;\n              } else {\n                _ch2 = stream.eat(_constants.P_ATTRIBUTE_ASSIGN);\n\n                if (!_ch2) {\n                  throw createError('expecting assignment \"=\" or \":\"');\n                }\n\n                if (_constants.P_ASSIGN_YAML.test(_ch2)) {\n                  stream.eatSpaces();\n                }\n\n                state = State.ATTRIBUTE_VALUE;\n              }\n\n              break;\n            }\n\n          case State.ATTRIBUTE_VALUE:\n            {\n              var _ch3 = stream.peek();\n\n              var _value = void 0;\n\n              if (_ch3 === _constants.T_TAG_START || _ch3 === _constants.T_ENTITY_START) {\n                states.embedded = true;\n                state = State.START;\n                break;\n              } else if (_ch3 === _constants.T_STRING_START) {\n                _value = stream.match(_constants.P_STRING_LITERAL_QUOTED);\n\n                try {\n                  _value = JSON.parse(_value);\n                } catch (e) {\n                  throw createError('invalid string literal');\n                }\n              } else if (stream.match(_constants.P_DATE_LITERAL)) {\n                _value = stream.lastMatch;\n                _value = new Date(_value);\n              } else if (_constants.P_NUMBER_START.test(_ch3)) {\n                _value = stream.match(_constants.P_NUMBER_LITERAL);\n                _value = parseFloat(_value);\n              } else if (stream.match(_constants.P_BOOLEAN_TRUE)) {\n                _value = true;\n              } else if (stream.match(_constants.P_BOOLEAN_FALSE)) {\n                _value = false;\n              } else {\n                _value = stream.match(_constants.P_STRING_LITERAL_UNQUOTED);\n\n                if (_.isNull(_value)) {\n                  throw createError('unrecognized attribute value');\n                }\n              }\n\n              if (_.isNull(_value)) {\n                throw createError('invalid attribute value');\n              }\n\n              states.value = _value;\n              state = State.ATTRIBUTE_FINISH;\n              break;\n            }\n\n          case State.ATTRIBUTE_FINISH:\n            {\n              var _key2 = states.key,\n                  _value2 = states.value;\n              states.key = undefined;\n              states.value = undefined;\n\n              if (_.isUndefined(_value2)) {\n                _value2 = true;\n              }\n\n              if (node.states.metadata) {\n                node.setMetadata(_key2, _value2);\n              } else {\n                node.setAttribute(_key2, _value2);\n              }\n\n              this.debug(\"# \".concat(node.states.metadata ? 'metadata' : 'attribute', \" \").concat(_key2, \"=\").concat(JSON.stringify(_value2)));\n              this.debug();\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.TAG_END:\n            {\n              var parseMetadata = node.isBlockTag && !states.isClosing;\n              var tagNode = node;\n              states.inline = tagNode.isInlineBlock;\n\n              if (!node.isWrappingTag || states.isClosing) {\n                if (node.type === _Node.NodeType.PARAGRAPH) {\n                  popNode();\n                }\n\n                popNode();\n\n                if (node.type === _Node.NodeType.ENTITY) {\n                  // copy tag properties to entity and remove temporary tag node\n                  node.setAttributes(tagNode.attributes);\n                  node.name = tagNode.name;\n                  node.removeChild(tagNode);\n                  state = State.ENTITY_END;\n                  tagNode = node;\n                  popNode();\n                }\n\n                if (tagNode.states.embedded) {\n                  if (node.states.metadata) {\n                    node.setMetadata(tagNode.states.metaKey, tagNode);\n                  } else {\n                    node.setAttribute(tagNode.states.metaKey, tagNode);\n                  }\n                }\n              }\n\n              if (states.isClosing && !states.inline) {\n                stream.skipOver(_constants.P_LINE_BREAK);\n              }\n\n              states.isClosing = false;\n              states.inline = false;\n\n              if (parseMetadata) {\n                state = State.METADATA;\n              } else if (tagNode.states.embedded && (!tagNode.isWrappingTag || states.isClosing)) {\n                state = State.ATTRIBUTE_LIST;\n              } else {\n                state = State.NORMAL;\n              }\n\n              break;\n            }\n\n          case State.LABEL_START:\n            {\n              var label = stream.match(_constants.P_LABEL_NAME);\n\n              if (!label) {\n                throw createError('expected label name');\n              }\n\n              node.addLabel(label);\n              state = State.ATTRIBUTE_LIST;\n              break;\n            }\n\n          case State.ENTITY_START:\n            {\n              var _child4 = _Node.default.create(_Node.NodeType.ENTITY, '', {\n                start: start\n              });\n\n              if (states.embedded) {\n                _child4.states.embedded = true;\n                _child4.states.metaKey = states.key;\n                states.embedded = false;\n              } else {\n                node.appendChild(_child4);\n              }\n\n              pushNode(_child4);\n              state = State.ENTITY_BODY;\n              break;\n            }\n\n          case State.ENTITY_BODY:\n            {\n              start = stream.pos;\n\n              var _text2 = stream.readTo(_constants.T_ENTITY_END, {\n                skipMatched: true\n              });\n\n              if (!_text2) {\n                throw createError('empty entity');\n              } else if (_text2.search(_constants.P_LINE_BREAK) !== -1) {\n                throw createError('unexpected line break of entity');\n              }\n\n              node.appendText(_text2, {\n                start: start,\n                end: start + _text2.length\n              });\n\n              var _ch4 = stream.eat(_constants.T_TAG_START);\n\n              if (_ch4) {\n                state = State.TAG_START;\n              } else {\n                state = State.ENTITY_END;\n              }\n\n              break;\n            }\n\n          case State.ENTITY_END:\n            {\n              popNode();\n              state = State.NORMAL;\n              break;\n            }\n\n          case State.END:\n            {\n              if (node.type !== _Node.NodeType.ROOT) {\n                popNode();\n              }\n\n              state = State.FINISH;\n              break;\n            }\n\n          case State.FINISH:\n            {\n              break;\n            }\n        }\n      }\n\n      root.toString();\n      this.parsed = true;\n      this.debug('parsed result:');\n      this.debug(JSON.stringify(root.toJSON(), null, 2));\n      return root;\n    }\n  }]);\n  return Tokenizer;\n}();\n\nvar _default = Tokenizer;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Class holding text line data\n */\n\n\nvar TextLine =\n/*#__PURE__*/\nfunction () {\n  function TextLine(lines, text, ln, offset) {\n    (0, _classCallCheck2.default)(this, TextLine);\n    (0, _defineProperty2.default)(this, \"lines\", void 0);\n    (0, _defineProperty2.default)(this, \"text\", void 0);\n    (0, _defineProperty2.default)(this, \"ln\", void 0);\n    (0, _defineProperty2.default)(this, \"offset\", void 0);\n    this.lines = lines;\n    this.text = text;\n    this.ln = ln;\n    this.offset = offset;\n  }\n  /**\n   * Get the previous line\n   */\n\n\n  (0, _createClass2.default)(TextLine, [{\n    key: \"prev\",\n    value: function prev() {\n      return this.lines[this.ln - 2];\n    }\n    /**\n     * Get the next line\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.lines[this.ln];\n    }\n    /**\n     * Get text length of the line\n     */\n\n  }, {\n    key: \"toJSON\",\n\n    /**\n     * Convert to JSON serializable object\n     */\n    value: function toJSON() {\n      return {\n        ln: this.ln,\n        start: this.start,\n        end: this.end,\n        text: this.text\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n    /**\n     * Start position of the line, alias of `offset`\n     */\n\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.offset;\n    }\n    /**\n     * End position of the line\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n  }]);\n  return TextLine;\n}();\n\nvar _default = TextLine;\nexports.default = _default;"],"sourceRoot":""}